---
title: 2017-07-07 Report
date: 2017-07-07 15:27:45
tags: daily report
---
当天完成的工作内容
写了两个API，xxxxxxxxxxx
当天的收获
用一个例子来总结一下关于遇到问题时的方法论。
遇到的问题：某段数据被重复的打印出来
1.我当时的思路和推导过程：
看到数据被重复打印—>我在函数内部写了一条Print语句—>程序将Print语句重复执行了—>我将其判定错误的原因是死循环—>我开始在函数的内部debug寻找导致死循环的代码—>不断的修改变量—>观察debug结果—>始终没有在内部找到原因—>问题得不到解决。
2.伟哥的思路和推导过程：
伟哥看到我一直对数据debug—>伟哥问我凭什么判定是内部死循环了—>伟哥的意思是1.凭什么认为是死循环2.就算是死循环凭什么发生在内部而不是外部逻辑出错—>对这两个假设进行验证—>假设1，在我当时的思路中已经在用在内部增加Print语句将其验证成立—>假设2，如果问题发生在了内部，那么Avatar中使用这部分代码的其他模块应该也会出错—>其他模块功能正常—>假设2不成立，则表明目前问题不是出现在内部—>那么假设死循环发生在外部的逻辑调用上—>在外部debug调试—>发现问题出在将函数调用的语句写在了while循环内—>循环的退出条件存在问题，导致了死循环的调用—>假设成立，目前定位到问题是外部逻辑上发生了死循环—>重写while循环的退出条件—>运行程序，打印结果正常—>问题解决。
3.重新推导这个过程：
看到数据重复打印—>先思考如果是死循环的话会发生什么现象—>两点现象1.输出的语句被重复打印2.程序除非手动终止，否则会一直运行—>开始验证问题是否会发生这两点现象—>在程序内部写一条print语句—>程序运行后将print语句重复执行，并且在一直循环没有退出—>符合发生死循环的现象—>假设目前的问题是死循环成立—>假设1，死循环发生在函数内部。假设2，死循环发生在函数外部—>验证假设1，观察Avatar中同样调用这部分代码的模块—>观察功能运行是否正常—>功能正常，则代表函数内部没有问题—>假设1不成立。—>验证假设2，死循环发生在函数外部—>对外部逻辑进行debug—>发现将函数在没有控制好退出条件的while循环中进行了调用—>假设2成立，死循环发生在了函数外部—>重写while循环的退出条件—>再次运行模块—>打印结果正常，模块功能正常实现—>问题得到解决。
遇到问题思考出可执行的Action plan的方法：
遇到问题—>先假设出问题的发生情况—>缩小问题的范围—>开始对假设逐个进行逻辑验证和思考可执行的测试方法—>得出可执行的action plan—>对假设进行实践验证—>假设如果不成立，再次对其余假设进行思考总结出可执行的action plan后实际验证—>假设成立，代表问题发生与假设相同—>按照之前思考出来的action plan进行实际操作与修复—>修复结束后—>在相同的环境下，再次运行程序—>观察程序结果，确保程序功能正常—>问题得到解决。
记住 “解决问题应该追求高效的方法，而不是凭借混出来的’经验’”
明天的计划
周末看Avatar的xxx和xxx部分的源码，理解Avatar后端的逻辑。
提出疑问或寻求帮助
无。
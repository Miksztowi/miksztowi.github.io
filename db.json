{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"4fced88b3eac4bae63cf3f3475dbf0f3097e2250","modified":1516812660000},{"_id":"source/.DS_Store","hash":"63bba01d85db78c1031f84c965d3d4c194e2ea52","modified":1517206743000},{"_id":"source/baidu_verify_BT2qrx56qZ.html","hash":"1c08d9cab9c9f127a584eedc192957534636e7dc","modified":1516812660000},{"_id":"themes/themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1516883655000},{"_id":"source/google4e36bdd00638b2e4.html","hash":"d42782bd087c8bd8363455e50689937774560e8f","modified":1516812660000},{"_id":"themes/themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1516883655000},{"_id":"themes/themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1516883655000},{"_id":"themes/themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1516883655000},{"_id":"themes/themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1516883655000},{"_id":"themes/themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1516883655000},{"_id":"themes/themes/yilia/_config.yml","hash":"d0d0266b1b0e22e66869923a4b7faab95067dc55","modified":1517206499000},{"_id":"themes/themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1516883655000},{"_id":"themes/themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1516883655000},{"_id":"themes/themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1516883655000},{"_id":"source/_posts/2017-07-03.md","hash":"fc57b56f785ddf577db0414fc741504658d8da9e","modified":1516812660000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1517206737000},{"_id":"source/_posts/2017-07-04.md","hash":"b337dc36b52a33fa1fdfe36435d895ad7927f245","modified":1516812660000},{"_id":"source/_posts/2017-07-05.md","hash":"2503492ff7b18bb550beaf086bb99a0f45dcaff6","modified":1516812660000},{"_id":"source/_posts/2017-07-06.md","hash":"4d9e9fe86102c00961049504a1bebcb8fc9d9cf3","modified":1516812660000},{"_id":"source/_posts/2017-07-07.md","hash":"db76a9ee02888bf9ab60c0e848676656c1de9be5","modified":1516812660000},{"_id":"source/_posts/2017-07-10.md","hash":"9362d3abbba31fa2f0869f029f76b205c00bae9d","modified":1516812660000},{"_id":"source/_posts/2017-07-13.md","hash":"c5ef118b4bf7b1e505ad746a72860524043a59a5","modified":1516812660000},{"_id":"source/_posts/2017-07-12.md","hash":"08b38b842c9151d149293ea3d580bfc9608471d9","modified":1516812660000},{"_id":"source/_posts/2017-07-14.md","hash":"f40e2053d3ee6a0e6526712965978caaaa720576","modified":1516812660000},{"_id":"source/_posts/2017-07-11.md","hash":"3963fa22d4712d3df4c1951fd0d4343776bb61ee","modified":1516812660000},{"_id":"source/_posts/2017-07-20.md","hash":"272d67be82e4b66c466fe1256622441786364f2c","modified":1516812660000},{"_id":"source/_posts/2017-07-18.md","hash":"8ab9a4ccaa9fe0207316f0663c5311cde37d01fd","modified":1516812660000},{"_id":"source/_posts/2017-07-19.md","hash":"3405f46c2b4757ca55e5dc5d7f67838a195438f1","modified":1516812660000},{"_id":"source/_posts/2017-07-17.md","hash":"9ff2301f87722833fe3d10e3ad3c910de2f19621","modified":1516812660000},{"_id":"source/_posts/2017-07-21.md","hash":"77fd0e78a24bbc5b20f329951ebca79313b58032","modified":1516812660000},{"_id":"source/_posts/2017-07-24.md","hash":"fb1716c6180e377ccce369c15283cc491b2a14da","modified":1516812660000},{"_id":"source/_posts/2017-07-26.md","hash":"43ea5bb852c78a94fed3fbb14138b5af17b1951b","modified":1516812660000},{"_id":"source/_posts/2017-07-25.md","hash":"ab421de2c02c8814a7386d70f6c3707b4dfd6a35","modified":1516812660000},{"_id":"source/_posts/2017-07-31.md","hash":"6a2b60ea87a5f9e96fd8a30106d21826c3cfbea4","modified":1516812660000},{"_id":"source/_posts/2017-07-28.md","hash":"de1993d74aa4f92efc7606b168b96ef30d54e823","modified":1516812660000},{"_id":"source/_posts/2017-08-02.md","hash":"8ce468a4626ec138e4633327ce0ece92a635dacd","modified":1516812660000},{"_id":"source/_posts/2017-08-01.md","hash":"ee2528ff39f45a7dd862018b9c0751dcc20b3d13","modified":1516812660000},{"_id":"source/_posts/2017-08-03.md","hash":"d9333c1c2ab4ecbd48198809e906e6b3aff38c75","modified":1516812660000},{"_id":"source/_posts/2017-08-05.md","hash":"8f50a7ca6cf258dcf91ee7e7e0d5301efa7937dc","modified":1516812660000},{"_id":"source/_posts/2017-08-04.md","hash":"c8ea8135d4d6936588903f93798de2e32e172701","modified":1516812660000},{"_id":"source/_posts/2017-08-06.md","hash":"6fb59d7396987e93e0b986f3b6b35016dfea21d9","modified":1516812660000},{"_id":"source/_posts/2017-08-10.md","hash":"a0825d0b871aaad16c920f0ea5ba0269fb87a2eb","modified":1516812660000},{"_id":"source/_posts/2017-08-07.md","hash":"711cae88677e2dd5e4d43a3d309c8899e0d19d46","modified":1516812660000},{"_id":"source/_posts/2017-08-09.md","hash":"34cde762f93e5de7e82864c6ac59cbefd4f3a855","modified":1516812660000},{"_id":"source/_posts/2017-08-16.md","hash":"abb072342b34ee836bd8680065b537d871489c72","modified":1516812660000},{"_id":"source/_posts/2017-08-18.md","hash":"047c358a1d6b37f00fb72fb1896e1bab4a0b5952","modified":1516812660000},{"_id":"source/_posts/2017-08-20.md","hash":"d484f75c53cbc901f70b3d852a1e61e0e4cd0289","modified":1516812660000},{"_id":"source/_posts/Python-Coroutine介绍.md","hash":"0409c4e102f242af78dd3ed823ca99d86b7fae96","modified":1516812660000},{"_id":"source/_posts/2017-08-08.md","hash":"8d2eb36a52a3613080742258269a0767ed4551e4","modified":1516812660000},{"_id":"source/_posts/2017-08-14.md","hash":"a1b0e32774eacf68628c8929a6f5670fe54271a9","modified":1516812660000},{"_id":"source/_posts/Python-Function-Decorators-and-Closures介绍.md","hash":"4222bb5c5aa486018ec0e433cec70e3886250960","modified":1516812660000},{"_id":"source/_posts/Python-Iterators-and-Iterables介绍.md","hash":"328143f55131091546183d2c0e553cee07c5df22","modified":1516812660000},{"_id":"source/_posts/Python-concurrency-with-futures.md","hash":"ea6fea68fed2c5fc3de2506ce4dbc7436308f4b0","modified":1516812660000},{"_id":"source/_posts/Python内置模块bisect介绍.md","hash":"38f0f3726e653f6ab01416c0628f8554608c539c","modified":1516812660000},{"_id":"source/_posts/Python-asyncio模块介绍.md","hash":"2605dbea96975d371594c06b90592309e6b07a3c","modified":1516885481000},{"_id":"source/_posts/python格式化的案例解释.md","hash":"a67d67990776796e416451b69b0cb0a0f9178164","modified":1517206358000},{"_id":"source/_posts/Python-generator-介绍.md","hash":"f161fdc7596ae90c138e798a86ad4e182c5e0e37","modified":1516885596000},{"_id":"source/_posts/函数式编程.md","hash":"69da9143df2a80b85948999ee86d33ae00b30c22","modified":1516812660000},{"_id":"source/_posts/python实现计算机网络rip协议.md","hash":"a526b6e982e7a64791aa1df170b7fbdaf633a4ad","modified":1516812660000},{"_id":"source/_posts/python暑期实习面试.md","hash":"0b4677c8531ad58500e82df3f7ec1b373e64434d","modified":1516812660000},{"_id":"source/_posts/检查清单.md","hash":"a06f1fae06fb5a0bf8b0c6d01326896610a124b4","modified":1516812660000},{"_id":"source/_posts/联合-查找算法.md","hash":"a27f7f3b85b4f07d82f2462a4485d88b9dcd7ded","modified":1516812660000},{"_id":"source/_posts/问题清单.md","hash":"3c2552cdd71cdbc11653da33ac6228f85163ff3d","modified":1516812660000},{"_id":"source/_posts/系统级I-O及Linux-I-O模式解释.md","hash":"b20fe5140550da8a9c0113f78b41e8f3014ef697","modified":1516887729000},{"_id":"themes/themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1516883655000},{"_id":"themes/themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1516883655000},{"_id":"themes/themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1516883135000},{"_id":"themes/themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1516883655000},{"_id":"themes/themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1516883655000},{"_id":"themes/themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1516883655000},{"_id":"themes/themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1516883655000},{"_id":"themes/themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516883655000},{"_id":"themes/themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1516883655000},{"_id":"themes/themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516883655000},{"_id":"themes/themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1516883655000},{"_id":"themes/themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1516883655000},{"_id":"themes/themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1516883655000},{"_id":"themes/themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1516883655000},{"_id":"themes/themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1516883655000},{"_id":"themes/themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1516883655000},{"_id":"themes/themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1516883655000},{"_id":"themes/themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1516883655000},{"_id":"themes/themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1516883655000},{"_id":"themes/themes/yilia/.git/index","hash":"6a4a1d2e5814ad9523f53c1a0bf6a2943d30228e","modified":1516883655000},{"_id":"themes/themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516883655000},{"_id":"themes/themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1516883655000},{"_id":"themes/themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1516883655000},{"_id":"source/_posts/images/io区别.png","hash":"db603b4f38d64ab270d19aae70ffb2cfea5df817","modified":1516778877000},{"_id":"source/_posts/images/io复用.png","hash":"6ee0cdbf608e11933192acce0e240c0f8cf7187d","modified":1516778842000},{"_id":"source/_posts/images/异步io.png","hash":"a75706c12b93fc475e595f95c03011d3072d65df","modified":1516778853000},{"_id":"source/_posts/images/同步io.png","hash":"a763216a6f40974b7c2ce3b7c0c665c4950a2e1d","modified":1516886897000},{"_id":"source/_posts/images/阻塞io.png","hash":"7d52e9a61f6db57908a764f981d72942b270ac9a","modified":1516778816000},{"_id":"source/_posts/images/非阻塞io.png","hash":"e6bba186de66ce07d944459088f418ed8499c9fe","modified":1516778830000},{"_id":"themes/themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1516883135000},{"_id":"themes/themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1516883135000},{"_id":"themes/themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1516883135000},{"_id":"themes/themes/yilia/.git/logs/HEAD","hash":"af3649719b25ae00279e8aed8c558934f6043340","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1516883655000},{"_id":"themes/themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1516883655000},{"_id":"themes/themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1516883655000},{"_id":"themes/themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1516883655000},{"_id":"themes/themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1516883655000},{"_id":"themes/themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1516883655000},{"_id":"themes/themes/yilia/.git/objects/pack/pack-d0efa29f48307b1b5e448d031827e91aa784ca84.idx","hash":"460314e6483bbc8f7981acc69fc2d5e6dbe9f2c6","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1516883655000},{"_id":"themes/themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1516883655000},{"_id":"themes/themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1516883655000},{"_id":"themes/themes/yilia/.git/logs/refs/heads/master","hash":"af3649719b25ae00279e8aed8c558934f6043340","modified":1516883655000},{"_id":"themes/themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1516883655000},{"_id":"themes/themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"af3649719b25ae00279e8aed8c558934f6043340","modified":1516883655000},{"_id":"themes/themes/yilia/.git/objects/pack/pack-d0efa29f48307b1b5e448d031827e91aa784ca84.pack","hash":"6f02b7f292e9da5759ab8dd10f3c3332944b0b34","modified":1516883655000},{"_id":"public/baidu_verify_BT2qrx56qZ.html","hash":"fffa73f922a1d3a2885f77f843f32695c7ef4348","modified":1517206507552},{"_id":"public/google4e36bdd00638b2e4.html","hash":"338d3bd7abf221ba6b17d98eaef49f56a1f626f2","modified":1517206508076},{"_id":"public/atom.xml","hash":"4dce84cc640de149c03324e91444bb2fe6383750","modified":1517206758054},{"_id":"public/sitemap.xml","hash":"f4b8949911c766ab2b924b0a318a79357a359d15","modified":1517206758083},{"_id":"public/content.json","hash":"839c0ffbdd2fde9133353de7040262681f869663","modified":1517206758083},{"_id":"public/baidusitemap.xml","hash":"a0058cca7d854aeb62ddc6e962cdd451fe94b4d8","modified":1517206757715},{"_id":"public/2018/01/25/系统级I-O及Linux-I-O模式解释/index.html","hash":"f82c7c6e95890ed668eed75ab29768d92c4e0f5a","modified":1517206508188},{"_id":"public/2017/12/19/Python-asyncio模块介绍/index.html","hash":"a538c13ed1b2fbd853b5fb4e9a09bff4a7347991","modified":1517206508195},{"_id":"public/2017/12/13/Python-concurrency-with-futures/index.html","hash":"fd5578710f2f894012731e8a4eed1d44f0b65580","modified":1517206508197},{"_id":"public/2017/12/11/Python-Coroutine介绍/index.html","hash":"ca4952252b6204cd5ad368ce886d14e60ee380ea","modified":1517206508197},{"_id":"public/2017/12/02/Python-generator-介绍/index.html","hash":"41729644fc7286a3da445e83dac7e6ec79e0044c","modified":1517206508198},{"_id":"public/2017/12/02/Python-Iterators-and-Iterables介绍/index.html","hash":"7dc11eb736874a538c0c141a32a492fcc4ad5a78","modified":1517206508198},{"_id":"public/2017/11/29/Python-Function-Decorators-and-Closures介绍/index.html","hash":"ca137e146797b0905558d72ef50c0d3272d90757","modified":1517206508198},{"_id":"public/2017/11/20/Python内置模块bisect介绍/index.html","hash":"491771a7e87dbb05e3bf55033e51222e07b829d9","modified":1517206508198},{"_id":"public/2017/11/06/联合-查找算法/index.html","hash":"2fc86cca3829be9f70c39bfc5b1cb8d03224cdb0","modified":1517206758118},{"_id":"public/2017/11/04/函数式编程/index.html","hash":"4f9d1b5d3f612ec82d13eebc0a53e7fcf8ed2e28","modified":1517206508199},{"_id":"public/2017/11/04/问题清单/index.html","hash":"5cba223ee0af64389ce8f69c615c7bdf124bda4e","modified":1517206508200},{"_id":"public/2017/11/04/检查清单/index.html","hash":"201d19c58f85e78c10cc83d78e4799ff6c3c14c7","modified":1517206758118},{"_id":"public/2017/08/20/2017-08-20/index.html","hash":"c96e4a359a917134211d74d7acb774c55b89ad92","modified":1517206508200},{"_id":"public/2017/08/18/2017-08-18/index.html","hash":"cbf7a648ebf570a556559e98ce4b49e9b5ba0631","modified":1517206508201},{"_id":"public/2017/08/16/2017-08-16/index.html","hash":"bcc06db9a943c0ae68be3cbfdcb4ba89acc10b4e","modified":1517206508201},{"_id":"public/2017/08/14/2017-08-14/index.html","hash":"321e30158c63ecea45d321600f7116f143ee8905","modified":1517206508201},{"_id":"public/2017/08/10/2017-08-10/index.html","hash":"76036278a45bd7bdd5ce09fda56dd41425ae21f4","modified":1517206508201},{"_id":"public/2017/08/09/2017-08-09/index.html","hash":"065a3e330ce8758c0186f5719dd306a39f66e417","modified":1517206508202},{"_id":"public/2017/08/08/2017-08-08/index.html","hash":"b6d842c980fec5a000cf7b2e3c04cda786d14a49","modified":1517206508202},{"_id":"public/2017/08/07/2017-08-07/index.html","hash":"4643b2aa17c0d905f8b3dae393fb143a80b5da4d","modified":1517206508202},{"_id":"public/2017/08/06/2017-08-06/index.html","hash":"7bf8f084f6a6c10ee0e19f7284d41db3e6934a58","modified":1517206508202},{"_id":"public/2017/08/05/2017-08-05/index.html","hash":"88f8df29d775cbaaba683cea581ad66b0e5aa28a","modified":1517206508203},{"_id":"public/2017/08/04/2017-08-04/index.html","hash":"c6b2b2439f1ea37cbd2b3d43b280b9b7d93c6503","modified":1517206508203},{"_id":"public/2017/08/03/2017-08-03/index.html","hash":"27254054065f3abfefcce91de76bb022ca269454","modified":1517206508203},{"_id":"public/2017/08/02/2017-08-02/index.html","hash":"d865ea557c5bb77ccf5482df4c81f06fe412a522","modified":1517206508203},{"_id":"public/2017/08/01/2017-08-01/index.html","hash":"bd719e9f63b4d40fd9b7e45f2774b23ec85b1f1d","modified":1517206508203},{"_id":"public/2017/07/31/2017-07-31/index.html","hash":"0da3a55d4a4778b99c1c20f5def0a01f84175eac","modified":1517206508203},{"_id":"public/2017/07/28/2017-07-28/index.html","hash":"3de30d18b0094520c8c990cbba8b3bf9f1085d4a","modified":1517206508204},{"_id":"public/2017/07/26/2017-07-26/index.html","hash":"a894d9af766fc2aa463afd6f18819ae5b80c1477","modified":1517206508204},{"_id":"public/2017/07/25/2017-07-25/index.html","hash":"ad905f3d88a1396daa5cc7a4f6a1ce5095395882","modified":1517206508204},{"_id":"public/2017/07/24/2017-07-24/index.html","hash":"be474779b8e2b86bb24fb4e8dcd6673d1d7af22d","modified":1517206508204},{"_id":"public/2017/07/21/2017-07-21/index.html","hash":"bb9111036cf13f4e3eddcf84bdc4f125b53b05a2","modified":1517206508204},{"_id":"public/2017/07/20/2017-07-20/index.html","hash":"22600792403ed6ff1a03e1b30269496895a2cdaf","modified":1517206508204},{"_id":"public/2017/07/19/2017-07-19/index.html","hash":"e239b9891aba9ed0436ce81e392126cd1a0b720d","modified":1517206508205},{"_id":"public/2017/07/18/2017-07-18/index.html","hash":"34f4cb23bf46ed9109987ba8076f69602af6dc49","modified":1517206508205},{"_id":"public/2017/07/17/2017-07-17/index.html","hash":"8d1aeb8b8605a012f139c1261f2137226dc13853","modified":1517206508205},{"_id":"public/2017/07/14/2017-07-14/index.html","hash":"c78fb7c60bb82f3e8caea6ab84926d8a8cc4afbe","modified":1517206508205},{"_id":"public/2017/07/13/2017-07-13/index.html","hash":"3bd9948b1adca3859401274d8b5515179757595b","modified":1517206508205},{"_id":"public/2017/07/12/2017-07-12/index.html","hash":"4fb7c6a6219ab68e89ed23b09234f6ee7605bbeb","modified":1517206508205},{"_id":"public/2017/07/11/2017-07-11/index.html","hash":"5576c17905758b2e43533423cb702a2cef88b472","modified":1517206508205},{"_id":"public/2017/07/10/2017-07-10/index.html","hash":"f2802fd714577cefb880241f60e41506e5089561","modified":1517206508205},{"_id":"public/2017/07/07/2017-07-07/index.html","hash":"477bb223817a92d65c570a1cf7e45ec048bc4236","modified":1517206508206},{"_id":"public/2017/07/06/2017-07-06/index.html","hash":"403440f160da54b4b055c8fa607be928ea3217be","modified":1517206508206},{"_id":"public/2017/07/05/2017-07-05/index.html","hash":"96dce054af645eb1b18ac3b4586de930a5192cb0","modified":1517206508206},{"_id":"public/2017/07/04/2017-07-04/index.html","hash":"89d860ae6b09ab2ea37b98216bf8491011b344ff","modified":1517206508206},{"_id":"public/2017/07/03/2017-07-03/index.html","hash":"8564252db3b58a7b5d8e9ac5d3bff5dd561d5593","modified":1517206508206},{"_id":"public/2017/06/16/python暑期实习面试/index.html","hash":"da199a1e40df3d1c74058c6ade0366bfdc301018","modified":1517206508206},{"_id":"public/2017/06/01/python实现计算机网络rip协议/index.html","hash":"0454373516f3340decb1847195a85852c0ae11ca","modified":1517206758118},{"_id":"public/archives/index.html","hash":"2e437ce2389ae197264b368beda2d34b7f2fe31a","modified":1517206758118},{"_id":"public/archives/page/2/index.html","hash":"970d0d9cf8dad6c265fb7782599b2a7e96ee5c28","modified":1517206758118},{"_id":"public/archives/page/3/index.html","hash":"947da2f132c24ace9a4808706e852406e53394df","modified":1517206758118},{"_id":"public/archives/page/4/index.html","hash":"df17a55ee2e305b7a17ddfdf4cb5f60112ae5eb6","modified":1517206508207},{"_id":"public/archives/page/5/index.html","hash":"a3a53a465d613d1e973811760c59453a6e2b7d20","modified":1517206508207},{"_id":"public/archives/page/6/index.html","hash":"1829805905fdd9af88fa2a138fd533f80a8f91a7","modified":1517206508207},{"_id":"public/archives/page/7/index.html","hash":"b1944557f295c6298f2a4aef3787e7d0b9af08bb","modified":1517206508207},{"_id":"public/archives/page/8/index.html","hash":"934a67d57138b98b38b70cfbe08c9abe0f9ebd76","modified":1517206508207},{"_id":"public/archives/page/9/index.html","hash":"c3f53a5b00bf829fa6c29d197220a25135117bdb","modified":1517206508207},{"_id":"public/archives/page/10/index.html","hash":"208a45f961363547137a5699ffbacd7782a01ecf","modified":1517206508207},{"_id":"public/archives/2017/index.html","hash":"cbdb192d165d4b067278f86fe839fd47d14d9ae6","modified":1517206758119},{"_id":"public/archives/2017/page/2/index.html","hash":"1b32b899df01f3991281d83a6773c180c23857bb","modified":1517206758119},{"_id":"public/archives/2017/page/3/index.html","hash":"ad2e068d689ef349956dbd2a2e416b6ffad34238","modified":1517206508208},{"_id":"public/archives/2017/page/4/index.html","hash":"18506838fe57c475d5ffb21a9de6460fc2b448e1","modified":1517206508208},{"_id":"public/archives/2017/page/5/index.html","hash":"41be8417afae6bcf6b0712c3b3257e8b9e9587ac","modified":1517206508208},{"_id":"public/archives/2017/page/6/index.html","hash":"b41b07db973a8432dbc70a32cc515e25fac39fb4","modified":1517206508208},{"_id":"public/archives/2017/page/7/index.html","hash":"e028216771af7d0e9987e7e69a5c641983d5f72b","modified":1517206508208},{"_id":"public/archives/2017/page/8/index.html","hash":"16f76ec7f573473fd463f13e52bd93444569881d","modified":1517206508208},{"_id":"public/archives/2017/page/9/index.html","hash":"6a5937758f68497c2222b06ff8b9c78cf796be6f","modified":1517206508208},{"_id":"public/archives/2017/page/10/index.html","hash":"d4c3329807e01f4350b6ccd8217b8c975d322fbb","modified":1517206508208},{"_id":"public/archives/2017/06/index.html","hash":"a9b164cb34c575835909e3c5690f036d13346534","modified":1517206758119},{"_id":"public/archives/2017/07/index.html","hash":"d03a777c2ceac7d3ddcc276a6b6af2e62e58e71d","modified":1517206508209},{"_id":"public/archives/2017/07/page/2/index.html","hash":"5b06c23f31502e5e98fe53de9984e36e9113f02b","modified":1517206508209},{"_id":"public/archives/2017/07/page/3/index.html","hash":"b1e4fb6f9e8f877ff025ab7b962116a3254d7fb0","modified":1517206508209},{"_id":"public/archives/2017/07/page/4/index.html","hash":"b93d8d6e0903c4a50d5f61cda1f96e60ad1c48f8","modified":1517206508209},{"_id":"public/archives/2017/08/index.html","hash":"7c04be786f8be54a316fc55dc030e51a94fc026d","modified":1517206508209},{"_id":"public/archives/2017/08/page/2/index.html","hash":"280b8e0dd378d7bfbdb71c5d19e90becf93e873f","modified":1517206508209},{"_id":"public/archives/2017/08/page/3/index.html","hash":"95e54dd6d4e559a287fdec74637b84e45ad83da5","modified":1517206508209},{"_id":"public/archives/2017/11/index.html","hash":"605bf0a45b2639e3749bd4a8f92e24a093cb0163","modified":1517206758119},{"_id":"public/archives/2017/11/page/2/index.html","hash":"f4281090952443151f65def3e35fe1bd28ca3fee","modified":1517206508210},{"_id":"public/archives/2017/12/index.html","hash":"76c0a716bef672421a55f01106d014d329b49d89","modified":1517206508210},{"_id":"public/archives/2018/index.html","hash":"9c7f76e655c0a01623faf5190ac20e545d4edb9b","modified":1517206508210},{"_id":"public/archives/2018/01/index.html","hash":"6fffe21e7886b5d776852bde4a94be36b558ff16","modified":1517206508210},{"_id":"public/index.html","hash":"b8f30b301e9b6423d9525b13d6f5d4c028bcfb6a","modified":1517206758119},{"_id":"public/page/2/index.html","hash":"6280640468f66b68d461c894cdee22bd85c65e11","modified":1517206758119},{"_id":"public/page/3/index.html","hash":"df409d672a6e8b19f7022ff8609f988c15f2ed62","modified":1517206758119},{"_id":"public/page/4/index.html","hash":"64d81c3cc436da1bfdc2ff7dce914cde7d8ce659","modified":1517206508211},{"_id":"public/page/5/index.html","hash":"647295a1ce1f7b379f8036171139f6ae9cb2387d","modified":1517206508211},{"_id":"public/page/6/index.html","hash":"90fb2de45b6091c3dd3af9314218cd8101b114c5","modified":1517206508211},{"_id":"public/page/7/index.html","hash":"4c0ee60f4f08fc43c3f1e45daa62bf09874ab875","modified":1517206508212},{"_id":"public/page/8/index.html","hash":"6a1ffe739cab787098d8e5f0fd2e6d4c61eee351","modified":1517206508212},{"_id":"public/page/9/index.html","hash":"b053775a7edf2fa2ab5cfbb9b001264a80cb711d","modified":1517206508212},{"_id":"public/page/10/index.html","hash":"39820f5257729a7e75879f87c9c3667c8761445f","modified":1517206508213},{"_id":"public/tags/daily-report/index.html","hash":"e146c93affad608e3834a50e2801463d50b91cf9","modified":1517206758119},{"_id":"public/tags/daily-report/page/2/index.html","hash":"1c76a8e94b86ac3985911c5a867cf0445b75551e","modified":1517206508214},{"_id":"public/tags/daily-report/page/3/index.html","hash":"668b40e40c0969a62cb66a5a78027abb558de415","modified":1517206508214},{"_id":"public/tags/daily-report/page/4/index.html","hash":"bee5a427fa9842c5628fff15454969d1cb73a192","modified":1517206508214},{"_id":"public/tags/daily-report/page/5/index.html","hash":"e8b2566c4350f681da3f1f83541753b1af61e23a","modified":1517206508214},{"_id":"public/tags/daily-report/page/6/index.html","hash":"a967435500b8ba32153bb980441488697a8cd4ec","modified":1517206508215},{"_id":"public/tags/daily-report/page/7/index.html","hash":"045fd08624ce037e54dcc7203961518ef6eeba6f","modified":1517206508215},{"_id":"public/tags/Python/index.html","hash":"2c803c65b5708cb013894c22ce8d27fdd3152d20","modified":1517206508215},{"_id":"public/tags/Python/page/2/index.html","hash":"9789395e2f018facd6d091a8516c9d60a0caccaa","modified":1517206508215},{"_id":"public/tags/函数式/index.html","hash":"8dbbd135de4b905f9bf2a11f2671e9fc6f821092","modified":1517206508216},{"_id":"public/tags/实习面试/index.html","hash":"fd332c6bf94fb65cb6941dab37762a2689dcab41","modified":1517206508216},{"_id":"public/tags/清单/index.html","hash":"adc231426617a06b1606052c6be5e57fc854b64e","modified":1517206758119},{"_id":"public/tags/算法/index.html","hash":"b322f85e41b12f0a764a1c3888bccce044f13f36","modified":1517206508217},{"_id":"public/tags/计算机系统/index.html","hash":"4ac63c6aaac9d808b764750dd97cbf32cccd39bc","modified":1517206508217},{"_id":"public/2018/01/29/python格式化的案例解释/index.html","hash":"e897cfc095b79120120821f04ac294161830bf60","modified":1517206508222},{"_id":"public/CNAME","hash":"4fced88b3eac4bae63cf3f3475dbf0f3097e2250","modified":1517206508224},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1517206508224},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1517206508224},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1517206508224},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1517206508224},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1517206508224},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1517206508225},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1517206508225},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1517206508225},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1517206508225},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1517206508231},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1517206508231},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1517206508231},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1517206508231}],"Category":[],"Data":[],"Page":[{"layout":"false","sitemap":false,"_content":"BT2qrx56qZ","source":"baidu_verify_BT2qrx56qZ.html","raw":"layout: false\nsitemap: false\n---\nBT2qrx56qZ","date":"2018-01-24T16:51:00.000Z","updated":"2018-01-24T16:51:00.000Z","path":"baidu_verify_BT2qrx56qZ.html","title":"","comments":1,"_id":"cjcztkwie0000vmvvsmx90gac","content":"BT2qrx56qZ","site":{"data":{}},"excerpt":"","more":"BT2qrx56qZ"},{"layout":"false","sitemap":false,"_content":"google-site-verification: google4e36bdd00638b2e4.html","source":"google4e36bdd00638b2e4.html","raw":"layout: false\nsitemap: false\n---\ngoogle-site-verification: google4e36bdd00638b2e4.html","date":"2018-01-24T16:51:00.000Z","updated":"2018-01-24T16:51:00.000Z","path":"google4e36bdd00638b2e4.html","title":"","comments":1,"_id":"cjcztkwig0001vmvv6bxwelgb","content":"google-site-verification: google4e36bdd00638b2e4.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google4e36bdd00638b2e4.html"}],"Post":[{"title":"Python Coroutine介绍","date":"2017-12-11T06:58:15.000Z","_content":"\n\n## Concept\n通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。\n\n在coroutine里\n\n1. yield item通常放在=的右边，比如datum = yield item，item可以为None.\n2. 对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。\n3. yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。\n4. 增加了.throw()和.close()方法来扩展caller对coroutine的控制。\n\n\n## The behavior and states of a generator operating as a coroutine.\n\n我们先看一个基础的coroutine demo。\n\n```\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nmy_coro = simple_generator()\nprint(my_coro)\n<generator object simple_generator at 0x1093572b0>\nnext(my_coro)\nmy_coro.send(42)\n\n注意这里传递值时使用了.send()\n```\n看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。\n\ncoroutine只有四种状态：\n\n1. 'GEN_CREATED' 此时等待开始操作。\n2. 'GEN_RUINNING' 当前正在被解释器执行。\n3. 'GEN_SUSPENDED' 当前被一条yield语句挂起。\n4. 'GEN_CLOSED' coroutine已经全部执行完毕。\n\n通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在'GEN_CREATED'状态的coroutine里是无法操作的。\n`TypeError: can't send non-None value to a just-started generator`, 此时需要先通过next()来唤醒。\n\n接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。\n\n```\nfrom inspect import getgeneratorstate\ndef simple_coro2(a):\n    print('-> started: a =', a)\n    b = yield a\n    print('-> received: b =', b)\n    c = yield a + b\n    print('-> received: c = ', c)\n\nif __name__ == '__main__':\n    my_coro2 = simple_coro2(10)\n    print(getgeneratorstate(my_coro2))\n    next(my_coro2)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(20)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(30)\n    \nGEN_CREATED\n-> started: a = 10\nGEN_SUSPENDED\n-> received: b = 20\nGEN_SUSPENDED\n-> received: c =  30\nTraceback (most recent call last):\nStopIteration\n\n通过打印，看到代码运行的流程跟我们的答案符合。\n```\n\n顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，\n所以’b = yield a‘中b的只有caller唤醒后才会赋值。\n\n\n接下来，我们来看一下如何终止一个coroutine.\n\n```\ndef averager():\n    total = count = 0\n    average = None\n    while True:  # 注意看这里，这意味着这个循环会一直进行下去。\n        term = yield average\n        total += term\n        count += 1\n        average = total / count\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send(12))\ncoro_avg.close()\n10.0\n10.5\n11.0\n调用.close()后，将其终止。\nprint(coro_avg.send(14))\nTraceback (most recent call last):\n    print(coro_avg.send(14))\nStopIteration\n调用已经终止的coroutine会抛出Stopiteration的异常。\n```\n\n## Priming a coroutine automaticall with a decorator.\n通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于'慵懒'的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！\n\n```\nfrom functools import wraps\nfrom inspect import getgeneratorstate\n\ndef coroutine(func):\n    @wraps(func)\n    def primer(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n    return primer\n\n@coroutine\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nif __name__ == '__main__':\n    my_coro = simple_generator()\n    print(getgeneratorstate(my_coro))\n    print(my_coro.send(10))\ncoroutine start.\nGEN_SUSPENDED # 已经是挂起状态了!\ncoroutine received  10\n```\n我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！\n\n## How the caller can control a coroutine through .close() and .throw() methods of the generator object.\n对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？\n\n```\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send('a'))\n10.0\n10.5\nTypeError: unsupported operand type(s) for +=: 'int' and 'str'\ncoro_avg.send(12)\nStopIteration    ## 后续的调用会抛出Stopiteration的异常。\n```\n当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。\n所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)\n\n当然，generator对象有两种方法可以发送异常。\n\n1. generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。\n2. generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。\n\n介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。\n\n```\nfrom inspect import getgeneratorstate\nclass DemoException(Exception):\n    \"\"\"\"An exception type for the  demonstration.\"\"\"\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Continuing...')\n        else:\n            print('-> coroutine received: {!r}'.format(x))\n\n    raise RuntimeError('This line should never run.')\nexc_coro = demo_exc_handling()\nnext(exc_coro)\n\n\t# Demo 1\n\tprint(exc_coro.send(11))\n\tprint(exc_coro.send(22))\n\texc_coro.close()\n\tprint(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\nGEN_CLOSED\n\n    # Demo 2\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\n\n    # Demo 3\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(ZeroDivisionError)\n    print(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n'GEN_CLOSED'\n```\n\n注意看上面三种异常的打印，以及异常发生后的generator的状态。\n\n如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。\n\n```\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Continuing...')\n            else:\n                print('-> coroutine received: {!r}'.format(x))\n    finally:\n        print('Coroutine ending...')\n    raise RuntimeError('This line should never run.')\n    \n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\nCoroutine ending...\n```\n\nOK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。\n## How coroutines can return value upon termination.\n\n当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。\n\n```\nfrom collections import namedtuple\n\nResult = namedtuple('result', 'count average')\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)\n    \n    coro_avg = averager()\n    next(coro_avg)\n    coro_avg.send(10)\n    coro_avg.send(11)\n    print(coro_avg.send(None))\n    \nTraceback (most recent call last):\nStopIteration: result(count=2, average=10.5)\n注意这里的StopIteration.它将Result也一起打印了出来。\n\n    try:\n        coro_avg.send(None)\n    except StopIteration as exec:\n        print(exec.value)\nresult(count=2, average=10.5)\n借助try/except我们可以的到正确的result.\n```\n\n后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。\n\n## Usage and semantics of the new yield from syntax.\n\n前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。\n\n**yield from**是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。\n\n\n**yield from x**这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。\n\n**delegating generator**是指函数里包含了yield from <iterable>表达式。\n\n**subgenerator**指yield from <iterable>表达式里<iterable>得到的generator。\n\n**caller**指调用delagating generator的函数。\n\n```\nfrom collections import namedtuple\n\nresult = namedtuple('result', 'count average')\n\n\n# subgenerator\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return result(count, average)\n\n\n# delegating generator\ndef grouper(results, key):\n    while True:\n        results[key] = yield from averager()\n\n# caller\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            group.send(value)\n        group.send(None)  ## important\n\n    report(results)\n\n\ndef report(results):\n    for key, values in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}'.format(\n            values.count, group, values.average, unit\n        ))\n        \ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\nmain(data)\n\n 9 boys  averaging 40.42\n 9 boys  averaging 1.39\n10 girls averaging 42.04\n10 girls averaging 1.43\n```\n理解一下上面的代码：\n* 每一次迭代，调用grouper()创建的实例就是delegating generator.\n* 调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。\n* group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。\n* 当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。\n* 当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。\n\n上面代码的**核心**概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。\n\n如果还没有完全理解yield from,我们再从**PEP 380**中给出的介绍来理解：\n\n1. 任何subgenerator中yield的值都会直接传递给caller.\n2. 任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的__next__()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.\n3. return expr在generator里会抛出StopIteration，并且退出这个generator.\n4. yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。\n5. 通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.\n6. 如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。\n\n为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制\n\n```\nRESULT = yield from EXPR\n\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        _s = yield _y\n        try:\n            _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\n\nRESULT = _r\n\n_i是subgenerator.\n_y是subgenerator里yield出来的值.\n_r是最终结果.\n_s是caller传送给delegating generator的值，跳转给subgenerator.\n_e是一个异常.\n\n如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。\nimport sys\n\nRESULT = yield from EXPR\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except Exception as _e:\n                    _r = _e.value\n                    break\n    else:\n        try:\n            if _s is None:\n                _y = next(_i)\n            else:\n                _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\nRESULT = _r\n\n```\n\n## A use case: coroutines for managing concurrent activities in a simulation.\n\n最后我们通过一个写并发概念的简单demo来梳理一下概念\n\n```\nfrom collections import namedtuple\n\nEvent = namedtuple('Event', 'time proc action')\n\n\ndef taxi_process(ident, trips, start_time=0):\n    \"\"\"Yield to simular issuing event at each state change.\"\"\"\n    time = yield Event(start_time, ident, 'leave garge.')\n    for i in range(trips):\n        time = yield Event(time, ident, 'pick up passenger.')\n        time = yield Event(time, ident, 'drop off passenger.')\n    yield Event(time, ident, 'going home.')\n    taxi = taxi_process(ident=1, trips=2)\n    print(next(taxi))\n    print(taxi.send(7))\n    print(taxi.send(15))\n    print(taxi.send(16))\n    print(taxi.send(23))\n    print(taxi.send(30))\nEvent(time=0, proc=1, action='leave garge.')\nEvent(time=7, proc=1, action='pick up passenger.')\nEvent(time=15, proc=1, action='drop off passenger.')\nEvent(time=16, proc=1, action='pick up passenger.')\nEvent(time=23, proc=1, action='drop off passenger.')\nEvent(time=30, proc=1, action='going home.')\n这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。\n\nimport queue\n\n\nclass Simulator(object):\n    def __init__(self, procs_map):\n        self.events = queue.PriorityQueue()\n        self.procs = dict(procs_map)\n\n    def run(self, end_time):\n        \"\"\"Schedule and display events utill time is up.\"\"\"\n        for _, proc in sorted(self.procs.items()):\n            first_event = next(proc)\n            self.events.put(first_event)\n\n        sim_time = 0\n        while sim_time < end_time:\n            if self.events.empty():\n                print('*** end of events ***')\n                break\n            current_event = self.events.get()\n            sim_time, proc_id, previous_action = current_event\n            print('taxi:', proc_id, proc_id * '  ', current_event)\n            active_proc = self.procs[proc_id]\n            next_time = sim_time + compute_duration(previous_action)\n            try:\n                next_event = active_proc.send(next_time)\n            except StopIteration:\n                del self.procs[proc_id]\n            else:\n                self.events.put(next_event)\n        else:\n            msg = '*** end of simulation time: {} events pending ***'\n            print(msg.format(self.events.qsize()))\n\n\ndef compute_duration(previous_action):\n    duration = 1\n    if previous_action == 'pick up passenger.':\n        duration = 3\n    elif previous_action == 'drop off passenger.':\n        duration = 5\n    return duration\nif __name__ == '__main__':\n    DEPARTURE_INTERVAL = 2\n    num_taxis = 3\n    taxis = {\n        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)\n        for i in range(num_taxis)\n    }\n    sim = Simulator(taxis)\n    print(sim.run(100))\ntaxi: 0  Event(time=0, proc=0, action='leave garge.')\ntaxi: 0  Event(time=1, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=2, proc=1, action='leave garge.')\ntaxi: 1    Event(time=3, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=4, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=4, proc=2, action='leave garge.')\ntaxi: 2      Event(time=5, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=6, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=8, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=9, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=11, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=12, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=13, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=14, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=16, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=17, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=19, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=20, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=21, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=22, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=24, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=25, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=27, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=28, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=29, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=30, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=32, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=33, proc=0, action='going home.')\ntaxi: 1    Event(time=35, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=37, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=38, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=40, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=43, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=45, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=46, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=48, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=51, proc=1, action='going home.')\ntaxi: 2      Event(time=53, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=56, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=61, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=64, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=69, proc=2, action='going home.')\n*** end of events ***\n```\n\n请记住这个例子，之后在介绍**asyncio**时会进行详细的讲解。\n\n\n## Summary\n\n\n\n对于coroutine的介绍就到这里了，希望你已经理解了**yield from**的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！\n\n感谢你的阅读，希望能收到你的feedback :)\n\n本文代码地址: [https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo)","source":"_posts/Python-Coroutine介绍.md","raw":"---\ntitle: Python Coroutine介绍\ndate: 2017-12-11 14:58:15\ntags: Python\n\n---\n\n\n## Concept\n通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。\n\n在coroutine里\n\n1. yield item通常放在=的右边，比如datum = yield item，item可以为None.\n2. 对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。\n3. yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。\n4. 增加了.throw()和.close()方法来扩展caller对coroutine的控制。\n\n\n## The behavior and states of a generator operating as a coroutine.\n\n我们先看一个基础的coroutine demo。\n\n```\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nmy_coro = simple_generator()\nprint(my_coro)\n<generator object simple_generator at 0x1093572b0>\nnext(my_coro)\nmy_coro.send(42)\n\n注意这里传递值时使用了.send()\n```\n看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。\n\ncoroutine只有四种状态：\n\n1. 'GEN_CREATED' 此时等待开始操作。\n2. 'GEN_RUINNING' 当前正在被解释器执行。\n3. 'GEN_SUSPENDED' 当前被一条yield语句挂起。\n4. 'GEN_CLOSED' coroutine已经全部执行完毕。\n\n通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在'GEN_CREATED'状态的coroutine里是无法操作的。\n`TypeError: can't send non-None value to a just-started generator`, 此时需要先通过next()来唤醒。\n\n接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。\n\n```\nfrom inspect import getgeneratorstate\ndef simple_coro2(a):\n    print('-> started: a =', a)\n    b = yield a\n    print('-> received: b =', b)\n    c = yield a + b\n    print('-> received: c = ', c)\n\nif __name__ == '__main__':\n    my_coro2 = simple_coro2(10)\n    print(getgeneratorstate(my_coro2))\n    next(my_coro2)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(20)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(30)\n    \nGEN_CREATED\n-> started: a = 10\nGEN_SUSPENDED\n-> received: b = 20\nGEN_SUSPENDED\n-> received: c =  30\nTraceback (most recent call last):\nStopIteration\n\n通过打印，看到代码运行的流程跟我们的答案符合。\n```\n\n顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，\n所以’b = yield a‘中b的只有caller唤醒后才会赋值。\n\n\n接下来，我们来看一下如何终止一个coroutine.\n\n```\ndef averager():\n    total = count = 0\n    average = None\n    while True:  # 注意看这里，这意味着这个循环会一直进行下去。\n        term = yield average\n        total += term\n        count += 1\n        average = total / count\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send(12))\ncoro_avg.close()\n10.0\n10.5\n11.0\n调用.close()后，将其终止。\nprint(coro_avg.send(14))\nTraceback (most recent call last):\n    print(coro_avg.send(14))\nStopIteration\n调用已经终止的coroutine会抛出Stopiteration的异常。\n```\n\n## Priming a coroutine automaticall with a decorator.\n通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于'慵懒'的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！\n\n```\nfrom functools import wraps\nfrom inspect import getgeneratorstate\n\ndef coroutine(func):\n    @wraps(func)\n    def primer(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n    return primer\n\n@coroutine\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nif __name__ == '__main__':\n    my_coro = simple_generator()\n    print(getgeneratorstate(my_coro))\n    print(my_coro.send(10))\ncoroutine start.\nGEN_SUSPENDED # 已经是挂起状态了!\ncoroutine received  10\n```\n我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！\n\n## How the caller can control a coroutine through .close() and .throw() methods of the generator object.\n对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？\n\n```\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send('a'))\n10.0\n10.5\nTypeError: unsupported operand type(s) for +=: 'int' and 'str'\ncoro_avg.send(12)\nStopIteration    ## 后续的调用会抛出Stopiteration的异常。\n```\n当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。\n所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)\n\n当然，generator对象有两种方法可以发送异常。\n\n1. generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。\n2. generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。\n\n介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。\n\n```\nfrom inspect import getgeneratorstate\nclass DemoException(Exception):\n    \"\"\"\"An exception type for the  demonstration.\"\"\"\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Continuing...')\n        else:\n            print('-> coroutine received: {!r}'.format(x))\n\n    raise RuntimeError('This line should never run.')\nexc_coro = demo_exc_handling()\nnext(exc_coro)\n\n\t# Demo 1\n\tprint(exc_coro.send(11))\n\tprint(exc_coro.send(22))\n\texc_coro.close()\n\tprint(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\nGEN_CLOSED\n\n    # Demo 2\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\n\n    # Demo 3\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(ZeroDivisionError)\n    print(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n'GEN_CLOSED'\n```\n\n注意看上面三种异常的打印，以及异常发生后的generator的状态。\n\n如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。\n\n```\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Continuing...')\n            else:\n                print('-> coroutine received: {!r}'.format(x))\n    finally:\n        print('Coroutine ending...')\n    raise RuntimeError('This line should never run.')\n    \n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\nCoroutine ending...\n```\n\nOK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。\n## How coroutines can return value upon termination.\n\n当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。\n\n```\nfrom collections import namedtuple\n\nResult = namedtuple('result', 'count average')\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)\n    \n    coro_avg = averager()\n    next(coro_avg)\n    coro_avg.send(10)\n    coro_avg.send(11)\n    print(coro_avg.send(None))\n    \nTraceback (most recent call last):\nStopIteration: result(count=2, average=10.5)\n注意这里的StopIteration.它将Result也一起打印了出来。\n\n    try:\n        coro_avg.send(None)\n    except StopIteration as exec:\n        print(exec.value)\nresult(count=2, average=10.5)\n借助try/except我们可以的到正确的result.\n```\n\n后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。\n\n## Usage and semantics of the new yield from syntax.\n\n前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。\n\n**yield from**是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。\n\n\n**yield from x**这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。\n\n**delegating generator**是指函数里包含了yield from <iterable>表达式。\n\n**subgenerator**指yield from <iterable>表达式里<iterable>得到的generator。\n\n**caller**指调用delagating generator的函数。\n\n```\nfrom collections import namedtuple\n\nresult = namedtuple('result', 'count average')\n\n\n# subgenerator\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return result(count, average)\n\n\n# delegating generator\ndef grouper(results, key):\n    while True:\n        results[key] = yield from averager()\n\n# caller\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            group.send(value)\n        group.send(None)  ## important\n\n    report(results)\n\n\ndef report(results):\n    for key, values in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}'.format(\n            values.count, group, values.average, unit\n        ))\n        \ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\nmain(data)\n\n 9 boys  averaging 40.42\n 9 boys  averaging 1.39\n10 girls averaging 42.04\n10 girls averaging 1.43\n```\n理解一下上面的代码：\n* 每一次迭代，调用grouper()创建的实例就是delegating generator.\n* 调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。\n* group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。\n* 当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。\n* 当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。\n\n上面代码的**核心**概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。\n\n如果还没有完全理解yield from,我们再从**PEP 380**中给出的介绍来理解：\n\n1. 任何subgenerator中yield的值都会直接传递给caller.\n2. 任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的__next__()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.\n3. return expr在generator里会抛出StopIteration，并且退出这个generator.\n4. yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。\n5. 通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.\n6. 如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。\n\n为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制\n\n```\nRESULT = yield from EXPR\n\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        _s = yield _y\n        try:\n            _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\n\nRESULT = _r\n\n_i是subgenerator.\n_y是subgenerator里yield出来的值.\n_r是最终结果.\n_s是caller传送给delegating generator的值，跳转给subgenerator.\n_e是一个异常.\n\n如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。\nimport sys\n\nRESULT = yield from EXPR\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except Exception as _e:\n                    _r = _e.value\n                    break\n    else:\n        try:\n            if _s is None:\n                _y = next(_i)\n            else:\n                _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\nRESULT = _r\n\n```\n\n## A use case: coroutines for managing concurrent activities in a simulation.\n\n最后我们通过一个写并发概念的简单demo来梳理一下概念\n\n```\nfrom collections import namedtuple\n\nEvent = namedtuple('Event', 'time proc action')\n\n\ndef taxi_process(ident, trips, start_time=0):\n    \"\"\"Yield to simular issuing event at each state change.\"\"\"\n    time = yield Event(start_time, ident, 'leave garge.')\n    for i in range(trips):\n        time = yield Event(time, ident, 'pick up passenger.')\n        time = yield Event(time, ident, 'drop off passenger.')\n    yield Event(time, ident, 'going home.')\n    taxi = taxi_process(ident=1, trips=2)\n    print(next(taxi))\n    print(taxi.send(7))\n    print(taxi.send(15))\n    print(taxi.send(16))\n    print(taxi.send(23))\n    print(taxi.send(30))\nEvent(time=0, proc=1, action='leave garge.')\nEvent(time=7, proc=1, action='pick up passenger.')\nEvent(time=15, proc=1, action='drop off passenger.')\nEvent(time=16, proc=1, action='pick up passenger.')\nEvent(time=23, proc=1, action='drop off passenger.')\nEvent(time=30, proc=1, action='going home.')\n这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。\n\nimport queue\n\n\nclass Simulator(object):\n    def __init__(self, procs_map):\n        self.events = queue.PriorityQueue()\n        self.procs = dict(procs_map)\n\n    def run(self, end_time):\n        \"\"\"Schedule and display events utill time is up.\"\"\"\n        for _, proc in sorted(self.procs.items()):\n            first_event = next(proc)\n            self.events.put(first_event)\n\n        sim_time = 0\n        while sim_time < end_time:\n            if self.events.empty():\n                print('*** end of events ***')\n                break\n            current_event = self.events.get()\n            sim_time, proc_id, previous_action = current_event\n            print('taxi:', proc_id, proc_id * '  ', current_event)\n            active_proc = self.procs[proc_id]\n            next_time = sim_time + compute_duration(previous_action)\n            try:\n                next_event = active_proc.send(next_time)\n            except StopIteration:\n                del self.procs[proc_id]\n            else:\n                self.events.put(next_event)\n        else:\n            msg = '*** end of simulation time: {} events pending ***'\n            print(msg.format(self.events.qsize()))\n\n\ndef compute_duration(previous_action):\n    duration = 1\n    if previous_action == 'pick up passenger.':\n        duration = 3\n    elif previous_action == 'drop off passenger.':\n        duration = 5\n    return duration\nif __name__ == '__main__':\n    DEPARTURE_INTERVAL = 2\n    num_taxis = 3\n    taxis = {\n        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)\n        for i in range(num_taxis)\n    }\n    sim = Simulator(taxis)\n    print(sim.run(100))\ntaxi: 0  Event(time=0, proc=0, action='leave garge.')\ntaxi: 0  Event(time=1, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=2, proc=1, action='leave garge.')\ntaxi: 1    Event(time=3, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=4, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=4, proc=2, action='leave garge.')\ntaxi: 2      Event(time=5, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=6, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=8, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=9, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=11, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=12, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=13, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=14, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=16, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=17, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=19, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=20, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=21, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=22, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=24, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=25, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=27, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=28, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=29, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=30, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=32, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=33, proc=0, action='going home.')\ntaxi: 1    Event(time=35, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=37, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=38, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=40, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=43, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=45, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=46, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=48, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=51, proc=1, action='going home.')\ntaxi: 2      Event(time=53, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=56, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=61, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=64, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=69, proc=2, action='going home.')\n*** end of events ***\n```\n\n请记住这个例子，之后在介绍**asyncio**时会进行详细的讲解。\n\n\n## Summary\n\n\n\n对于coroutine的介绍就到这里了，希望你已经理解了**yield from**的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！\n\n感谢你的阅读，希望能收到你的feedback :)\n\n本文代码地址: [https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo)","slug":"Python-Coroutine介绍","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkp001tvmvvokoq1exd","content":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。</p>\n<p>在coroutine里</p>\n<ol>\n<li>yield item通常放在=的右边，比如datum = yield item，item可以为None.</li>\n<li>对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。</li>\n<li>yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。</li>\n<li>增加了.throw()和.close()方法来扩展caller对coroutine的控制。</li>\n</ol>\n<h2 id=\"The-behavior-and-states-of-a-generator-operating-as-a-coroutine\"><a href=\"#The-behavior-and-states-of-a-generator-operating-as-a-coroutine\" class=\"headerlink\" title=\"The behavior and states of a generator operating as a coroutine.\"></a>The behavior and states of a generator operating as a coroutine.</h2><p>我们先看一个基础的coroutine demo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">my_coro = simple_generator()</div><div class=\"line\">print(my_coro)</div><div class=\"line\">&lt;generator object simple_generator at 0x1093572b0&gt;</div><div class=\"line\">next(my_coro)</div><div class=\"line\">my_coro.send(42)</div><div class=\"line\"></div><div class=\"line\">注意这里传递值时使用了.send()</div></pre></td></tr></table></figure>\n<p>看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。</p>\n<p>coroutine只有四种状态：</p>\n<ol>\n<li>‘GEN_CREATED’ 此时等待开始操作。</li>\n<li>‘GEN_RUINNING’ 当前正在被解释器执行。</li>\n<li>‘GEN_SUSPENDED’ 当前被一条yield语句挂起。</li>\n<li>‘GEN_CLOSED’ coroutine已经全部执行完毕。</li>\n</ol>\n<p>通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在’GEN_CREATED’状态的coroutine里是无法操作的。<br><code>TypeError: can&#39;t send non-None value to a just-started generator</code>, 此时需要先通过next()来唤醒。</p>\n<p>接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">def simple_coro2(a):</div><div class=\"line\">    print(&apos;-&gt; started: a =&apos;, a)</div><div class=\"line\">    b = yield a</div><div class=\"line\">    print(&apos;-&gt; received: b =&apos;, b)</div><div class=\"line\">    c = yield a + b</div><div class=\"line\">    print(&apos;-&gt; received: c = &apos;, c)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro2 = simple_coro2(10)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    next(my_coro2)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(20)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(30)</div><div class=\"line\">    </div><div class=\"line\">GEN_CREATED</div><div class=\"line\">-&gt; started: a = 10</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: b = 20</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: c =  30</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration</div><div class=\"line\"></div><div class=\"line\">通过打印，看到代码运行的流程跟我们的答案符合。</div></pre></td></tr></table></figure>\n<p>顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，<br>所以’b = yield a‘中b的只有caller唤醒后才会赋值。</p>\n<p>接下来，我们来看一下如何终止一个coroutine.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:  # 注意看这里，这意味着这个循环会一直进行下去。</div><div class=\"line\">        term = yield average</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(12))</div><div class=\"line\">coro_avg.close()</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div><div class=\"line\">调用.close()后，将其终止。</div><div class=\"line\">print(coro_avg.send(14))</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">    print(coro_avg.send(14))</div><div class=\"line\">StopIteration</div><div class=\"line\">调用已经终止的coroutine会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<h2 id=\"Priming-a-coroutine-automaticall-with-a-decorator\"><a href=\"#Priming-a-coroutine-automaticall-with-a-decorator\" class=\"headerlink\" title=\"Priming a coroutine automaticall with a decorator.\"></a>Priming a coroutine automaticall with a decorator.</h2><p>通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于’慵懒’的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from functools import wraps</div><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\"></div><div class=\"line\">def coroutine(func):</div><div class=\"line\">    @wraps(func)</div><div class=\"line\">    def primer(*args, **kwargs):</div><div class=\"line\">        gen = func(*args, **kwargs)</div><div class=\"line\">        next(gen)</div><div class=\"line\">        return gen</div><div class=\"line\">    return primer</div><div class=\"line\"></div><div class=\"line\">@coroutine</div><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro = simple_generator()</div><div class=\"line\">    print(getgeneratorstate(my_coro))</div><div class=\"line\">    print(my_coro.send(10))</div><div class=\"line\">coroutine start.</div><div class=\"line\">GEN_SUSPENDED # 已经是挂起状态了!</div><div class=\"line\">coroutine received  10</div></pre></td></tr></table></figure>\n<p>我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！</p>\n<h2 id=\"How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\"><a href=\"#How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\" class=\"headerlink\" title=\"How the caller can control a coroutine through .close() and .throw() methods of the generator object.\"></a>How the caller can control a coroutine through .close() and .throw() methods of the generator object.</h2><p>对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(&apos;a&apos;))</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">TypeError: unsupported operand type(s) for +=: &apos;int&apos; and &apos;str&apos;</div><div class=\"line\">coro_avg.send(12)</div><div class=\"line\">StopIteration    ## 后续的调用会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<p>当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。<br>所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)</p>\n<p>当然，generator对象有两种方法可以发送异常。</p>\n<ol>\n<li>generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。</li>\n<li>generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。</li>\n</ol>\n<p>介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">class DemoException(Exception):</div><div class=\"line\">    &quot;&quot;&quot;&quot;An exception type for the  demonstration.&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    while True:</div><div class=\"line\">        try:</div><div class=\"line\">            x = yield</div><div class=\"line\">        except DemoException:</div><div class=\"line\">            print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\"></div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">exc_coro = demo_exc_handling()</div><div class=\"line\">next(exc_coro)</div><div class=\"line\"></div><div class=\"line\">\t# Demo 1</div><div class=\"line\">\tprint(exc_coro.send(11))</div><div class=\"line\">\tprint(exc_coro.send(22))</div><div class=\"line\">\texc_coro.close()</div><div class=\"line\">\tprint(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">GEN_CLOSED</div><div class=\"line\"></div><div class=\"line\">    # Demo 2</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\"></div><div class=\"line\">    # Demo 3</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(ZeroDivisionError)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">&apos;GEN_CLOSED&apos;</div></pre></td></tr></table></figure>\n<p>注意看上面三种异常的打印，以及异常发生后的generator的状态。</p>\n<p>如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    try:</div><div class=\"line\">        while True:</div><div class=\"line\">            try:</div><div class=\"line\">                x = yield</div><div class=\"line\">            except DemoException:</div><div class=\"line\">                print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">            else:</div><div class=\"line\">                print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\">    finally:</div><div class=\"line\">        print(&apos;Coroutine ending...&apos;)</div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">    </div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">Coroutine ending...</div></pre></td></tr></table></figure>\n<p>OK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。</p>\n<h2 id=\"How-coroutines-can-return-value-upon-termination\"><a href=\"#How-coroutines-can-return-value-upon-termination\" class=\"headerlink\" title=\"How coroutines can return value upon termination.\"></a>How coroutines can return value upon termination.</h2><p>当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return Result(count, average)</div><div class=\"line\">    </div><div class=\"line\">    coro_avg = averager()</div><div class=\"line\">    next(coro_avg)</div><div class=\"line\">    coro_avg.send(10)</div><div class=\"line\">    coro_avg.send(11)</div><div class=\"line\">    print(coro_avg.send(None))</div><div class=\"line\">    </div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration: result(count=2, average=10.5)</div><div class=\"line\">注意这里的StopIteration.它将Result也一起打印了出来。</div><div class=\"line\"></div><div class=\"line\">    try:</div><div class=\"line\">        coro_avg.send(None)</div><div class=\"line\">    except StopIteration as exec:</div><div class=\"line\">        print(exec.value)</div><div class=\"line\">result(count=2, average=10.5)</div><div class=\"line\">借助try/except我们可以的到正确的result.</div></pre></td></tr></table></figure>\n<p>后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。</p>\n<h2 id=\"Usage-and-semantics-of-the-new-yield-from-syntax\"><a href=\"#Usage-and-semantics-of-the-new-yield-from-syntax\" class=\"headerlink\" title=\"Usage and semantics of the new yield from syntax.\"></a>Usage and semantics of the new yield from syntax.</h2><p>前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。</p>\n<p><strong>yield from</strong>是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。</p>\n<p><strong>yield from x</strong>这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。</p>\n<p><strong>delegating generator</strong>是指函数里包含了yield from <iterable>表达式。</iterable></p>\n<p><strong>subgenerator</strong>指yield from <iterable>表达式里<iterable>得到的generator。</iterable></iterable></p>\n<p><strong>caller</strong>指调用delagating generator的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># subgenerator</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return result(count, average)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># delegating generator</div><div class=\"line\">def grouper(results, key):</div><div class=\"line\">    while True:</div><div class=\"line\">        results[key] = yield from averager()</div><div class=\"line\"></div><div class=\"line\"># caller</div><div class=\"line\">def main(data):</div><div class=\"line\">    results = &#123;&#125;</div><div class=\"line\">    for key, values in data.items():</div><div class=\"line\">        group = grouper(results, key)</div><div class=\"line\">        next(group)</div><div class=\"line\">        for value in values:</div><div class=\"line\">            group.send(value)</div><div class=\"line\">        group.send(None)  ## important</div><div class=\"line\"></div><div class=\"line\">    report(results)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def report(results):</div><div class=\"line\">    for key, values in sorted(results.items()):</div><div class=\"line\">        group, unit = key.split(&apos;;&apos;)</div><div class=\"line\">        print(&apos;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&apos;.format(</div><div class=\"line\">            values.count, group, values.average, unit</div><div class=\"line\">        ))</div><div class=\"line\">        </div><div class=\"line\">data = &#123;</div><div class=\"line\">    &apos;girls;kg&apos;:</div><div class=\"line\">        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],</div><div class=\"line\">    &apos;girls;m&apos;:</div><div class=\"line\">        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],</div><div class=\"line\">    &apos;boys;kg&apos;:</div><div class=\"line\">        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],</div><div class=\"line\">    &apos;boys;m&apos;:</div><div class=\"line\">        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],</div><div class=\"line\">&#125;</div><div class=\"line\">main(data)</div><div class=\"line\"></div><div class=\"line\"> 9 boys  averaging 40.42</div><div class=\"line\"> 9 boys  averaging 1.39</div><div class=\"line\">10 girls averaging 42.04</div><div class=\"line\">10 girls averaging 1.43</div></pre></td></tr></table></figure>\n<p>理解一下上面的代码：</p>\n<ul>\n<li>每一次迭代，调用grouper()创建的实例就是delegating generator.</li>\n<li>调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。</li>\n<li>group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。</li>\n<li>当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。</li>\n<li>当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。</li>\n</ul>\n<p>上面代码的<strong>核心</strong>概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。</p>\n<p>如果还没有完全理解yield from,我们再从<strong>PEP 380</strong>中给出的介绍来理解：</p>\n<ol>\n<li>任何subgenerator中yield的值都会直接传递给caller.</li>\n<li>任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的<strong>next</strong>()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.</li>\n<li>return expr在generator里会抛出StopIteration，并且退出这个generator.</li>\n<li>yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。</li>\n<li>通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.</li>\n<li>如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。</li>\n</ol>\n<p>为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\"></div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        _s = yield _y</div><div class=\"line\">        try:</div><div class=\"line\">            _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\"></div><div class=\"line\">RESULT = _r</div><div class=\"line\"></div><div class=\"line\">_i是subgenerator.</div><div class=\"line\">_y是subgenerator里yield出来的值.</div><div class=\"line\">_r是最终结果.</div><div class=\"line\">_s是caller传送给delegating generator的值，跳转给subgenerator.</div><div class=\"line\">_e是一个异常.</div><div class=\"line\"></div><div class=\"line\">如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        try:</div><div class=\"line\">            _s = yield _y</div><div class=\"line\">        except GeneratorExit as _e:</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.close</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                pass</div><div class=\"line\">            else:</div><div class=\"line\">                _m()</div><div class=\"line\">            raise _e</div><div class=\"line\">        except BaseException as _e:</div><div class=\"line\">            _x = sys.exc_info()</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.throw</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                raise _e</div><div class=\"line\">            else:</div><div class=\"line\">                try:</div><div class=\"line\">                    _y = _m(*_x)</div><div class=\"line\">                except Exception as _e:</div><div class=\"line\">                    _r = _e.value</div><div class=\"line\">                    break</div><div class=\"line\">    else:</div><div class=\"line\">        try:</div><div class=\"line\">            if _s is None:</div><div class=\"line\">                _y = next(_i)</div><div class=\"line\">            else:</div><div class=\"line\">                _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\">RESULT = _r</div></pre></td></tr></table></figure>\n<h2 id=\"A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\"><a href=\"#A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\" class=\"headerlink\" title=\"A use case: coroutines for managing concurrent activities in a simulation.\"></a>A use case: coroutines for managing concurrent activities in a simulation.</h2><p>最后我们通过一个写并发概念的简单demo来梳理一下概念</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Event = namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def taxi_process(ident, trips, start_time=0):</div><div class=\"line\">    &quot;&quot;&quot;Yield to simular issuing event at each state change.&quot;&quot;&quot;</div><div class=\"line\">    time = yield Event(start_time, ident, &apos;leave garge.&apos;)</div><div class=\"line\">    for i in range(trips):</div><div class=\"line\">        time = yield Event(time, ident, &apos;pick up passenger.&apos;)</div><div class=\"line\">        time = yield Event(time, ident, &apos;drop off passenger.&apos;)</div><div class=\"line\">    yield Event(time, ident, &apos;going home.&apos;)</div><div class=\"line\">    taxi = taxi_process(ident=1, trips=2)</div><div class=\"line\">    print(next(taxi))</div><div class=\"line\">    print(taxi.send(7))</div><div class=\"line\">    print(taxi.send(15))</div><div class=\"line\">    print(taxi.send(16))</div><div class=\"line\">    print(taxi.send(23))</div><div class=\"line\">    print(taxi.send(30))</div><div class=\"line\">Event(time=0, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">Event(time=7, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=15, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=16, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=23, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=30, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。</div><div class=\"line\"></div><div class=\"line\">import queue</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Simulator(object):</div><div class=\"line\">    def __init__(self, procs_map):</div><div class=\"line\">        self.events = queue.PriorityQueue()</div><div class=\"line\">        self.procs = dict(procs_map)</div><div class=\"line\"></div><div class=\"line\">    def run(self, end_time):</div><div class=\"line\">        &quot;&quot;&quot;Schedule and display events utill time is up.&quot;&quot;&quot;</div><div class=\"line\">        for _, proc in sorted(self.procs.items()):</div><div class=\"line\">            first_event = next(proc)</div><div class=\"line\">            self.events.put(first_event)</div><div class=\"line\"></div><div class=\"line\">        sim_time = 0</div><div class=\"line\">        while sim_time &lt; end_time:</div><div class=\"line\">            if self.events.empty():</div><div class=\"line\">                print(&apos;*** end of events ***&apos;)</div><div class=\"line\">                break</div><div class=\"line\">            current_event = self.events.get()</div><div class=\"line\">            sim_time, proc_id, previous_action = current_event</div><div class=\"line\">            print(&apos;taxi:&apos;, proc_id, proc_id * &apos;  &apos;, current_event)</div><div class=\"line\">            active_proc = self.procs[proc_id]</div><div class=\"line\">            next_time = sim_time + compute_duration(previous_action)</div><div class=\"line\">            try:</div><div class=\"line\">                next_event = active_proc.send(next_time)</div><div class=\"line\">            except StopIteration:</div><div class=\"line\">                del self.procs[proc_id]</div><div class=\"line\">            else:</div><div class=\"line\">                self.events.put(next_event)</div><div class=\"line\">        else:</div><div class=\"line\">            msg = &apos;*** end of simulation time: &#123;&#125; events pending ***&apos;</div><div class=\"line\">            print(msg.format(self.events.qsize()))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def compute_duration(previous_action):</div><div class=\"line\">    duration = 1</div><div class=\"line\">    if previous_action == &apos;pick up passenger.&apos;:</div><div class=\"line\">        duration = 3</div><div class=\"line\">    elif previous_action == &apos;drop off passenger.&apos;:</div><div class=\"line\">        duration = 5</div><div class=\"line\">    return duration</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    DEPARTURE_INTERVAL = 2</div><div class=\"line\">    num_taxis = 3</div><div class=\"line\">    taxis = &#123;</div><div class=\"line\">        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)</div><div class=\"line\">        for i in range(num_taxis)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sim = Simulator(taxis)</div><div class=\"line\">    print(sim.run(100))</div><div class=\"line\">taxi: 0  Event(time=0, proc=0, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 0  Event(time=1, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=2, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 1    Event(time=3, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=4, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=4, proc=2, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 2      Event(time=5, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=6, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=8, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=9, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=11, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=12, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=13, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=14, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=16, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=17, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=19, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=20, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=21, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=22, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=24, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=25, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=27, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=28, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=29, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=30, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=32, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=33, proc=0, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 1    Event(time=35, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=37, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=38, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=40, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=43, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=45, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=46, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=48, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=51, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 2      Event(time=53, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=56, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=61, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=64, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=69, proc=2, action=&apos;going home.&apos;)</div><div class=\"line\">*** end of events ***</div></pre></td></tr></table></figure>\n<p>请记住这个例子，之后在介绍<strong>asyncio</strong>时会进行详细的讲解。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>对于coroutine的介绍就到这里了，希望你已经理解了<strong>yield from</strong>的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！</p>\n<p>感谢你的阅读，希望能收到你的feedback :)</p>\n<p>本文代码地址: <a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。</p>\n<p>在coroutine里</p>\n<ol>\n<li>yield item通常放在=的右边，比如datum = yield item，item可以为None.</li>\n<li>对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。</li>\n<li>yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。</li>\n<li>增加了.throw()和.close()方法来扩展caller对coroutine的控制。</li>\n</ol>\n<h2 id=\"The-behavior-and-states-of-a-generator-operating-as-a-coroutine\"><a href=\"#The-behavior-and-states-of-a-generator-operating-as-a-coroutine\" class=\"headerlink\" title=\"The behavior and states of a generator operating as a coroutine.\"></a>The behavior and states of a generator operating as a coroutine.</h2><p>我们先看一个基础的coroutine demo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">my_coro = simple_generator()</div><div class=\"line\">print(my_coro)</div><div class=\"line\">&lt;generator object simple_generator at 0x1093572b0&gt;</div><div class=\"line\">next(my_coro)</div><div class=\"line\">my_coro.send(42)</div><div class=\"line\"></div><div class=\"line\">注意这里传递值时使用了.send()</div></pre></td></tr></table></figure>\n<p>看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。</p>\n<p>coroutine只有四种状态：</p>\n<ol>\n<li>‘GEN_CREATED’ 此时等待开始操作。</li>\n<li>‘GEN_RUINNING’ 当前正在被解释器执行。</li>\n<li>‘GEN_SUSPENDED’ 当前被一条yield语句挂起。</li>\n<li>‘GEN_CLOSED’ coroutine已经全部执行完毕。</li>\n</ol>\n<p>通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在’GEN_CREATED’状态的coroutine里是无法操作的。<br><code>TypeError: can&#39;t send non-None value to a just-started generator</code>, 此时需要先通过next()来唤醒。</p>\n<p>接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">def simple_coro2(a):</div><div class=\"line\">    print(&apos;-&gt; started: a =&apos;, a)</div><div class=\"line\">    b = yield a</div><div class=\"line\">    print(&apos;-&gt; received: b =&apos;, b)</div><div class=\"line\">    c = yield a + b</div><div class=\"line\">    print(&apos;-&gt; received: c = &apos;, c)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro2 = simple_coro2(10)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    next(my_coro2)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(20)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(30)</div><div class=\"line\">    </div><div class=\"line\">GEN_CREATED</div><div class=\"line\">-&gt; started: a = 10</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: b = 20</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: c =  30</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration</div><div class=\"line\"></div><div class=\"line\">通过打印，看到代码运行的流程跟我们的答案符合。</div></pre></td></tr></table></figure>\n<p>顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，<br>所以’b = yield a‘中b的只有caller唤醒后才会赋值。</p>\n<p>接下来，我们来看一下如何终止一个coroutine.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:  # 注意看这里，这意味着这个循环会一直进行下去。</div><div class=\"line\">        term = yield average</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(12))</div><div class=\"line\">coro_avg.close()</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div><div class=\"line\">调用.close()后，将其终止。</div><div class=\"line\">print(coro_avg.send(14))</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">    print(coro_avg.send(14))</div><div class=\"line\">StopIteration</div><div class=\"line\">调用已经终止的coroutine会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<h2 id=\"Priming-a-coroutine-automaticall-with-a-decorator\"><a href=\"#Priming-a-coroutine-automaticall-with-a-decorator\" class=\"headerlink\" title=\"Priming a coroutine automaticall with a decorator.\"></a>Priming a coroutine automaticall with a decorator.</h2><p>通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于’慵懒’的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from functools import wraps</div><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\"></div><div class=\"line\">def coroutine(func):</div><div class=\"line\">    @wraps(func)</div><div class=\"line\">    def primer(*args, **kwargs):</div><div class=\"line\">        gen = func(*args, **kwargs)</div><div class=\"line\">        next(gen)</div><div class=\"line\">        return gen</div><div class=\"line\">    return primer</div><div class=\"line\"></div><div class=\"line\">@coroutine</div><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro = simple_generator()</div><div class=\"line\">    print(getgeneratorstate(my_coro))</div><div class=\"line\">    print(my_coro.send(10))</div><div class=\"line\">coroutine start.</div><div class=\"line\">GEN_SUSPENDED # 已经是挂起状态了!</div><div class=\"line\">coroutine received  10</div></pre></td></tr></table></figure>\n<p>我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！</p>\n<h2 id=\"How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\"><a href=\"#How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\" class=\"headerlink\" title=\"How the caller can control a coroutine through .close() and .throw() methods of the generator object.\"></a>How the caller can control a coroutine through .close() and .throw() methods of the generator object.</h2><p>对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(&apos;a&apos;))</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">TypeError: unsupported operand type(s) for +=: &apos;int&apos; and &apos;str&apos;</div><div class=\"line\">coro_avg.send(12)</div><div class=\"line\">StopIteration    ## 后续的调用会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<p>当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。<br>所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)</p>\n<p>当然，generator对象有两种方法可以发送异常。</p>\n<ol>\n<li>generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。</li>\n<li>generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。</li>\n</ol>\n<p>介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">class DemoException(Exception):</div><div class=\"line\">    &quot;&quot;&quot;&quot;An exception type for the  demonstration.&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    while True:</div><div class=\"line\">        try:</div><div class=\"line\">            x = yield</div><div class=\"line\">        except DemoException:</div><div class=\"line\">            print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\"></div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">exc_coro = demo_exc_handling()</div><div class=\"line\">next(exc_coro)</div><div class=\"line\"></div><div class=\"line\">\t# Demo 1</div><div class=\"line\">\tprint(exc_coro.send(11))</div><div class=\"line\">\tprint(exc_coro.send(22))</div><div class=\"line\">\texc_coro.close()</div><div class=\"line\">\tprint(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">GEN_CLOSED</div><div class=\"line\"></div><div class=\"line\">    # Demo 2</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\"></div><div class=\"line\">    # Demo 3</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(ZeroDivisionError)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">&apos;GEN_CLOSED&apos;</div></pre></td></tr></table></figure>\n<p>注意看上面三种异常的打印，以及异常发生后的generator的状态。</p>\n<p>如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    try:</div><div class=\"line\">        while True:</div><div class=\"line\">            try:</div><div class=\"line\">                x = yield</div><div class=\"line\">            except DemoException:</div><div class=\"line\">                print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">            else:</div><div class=\"line\">                print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\">    finally:</div><div class=\"line\">        print(&apos;Coroutine ending...&apos;)</div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">    </div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">Coroutine ending...</div></pre></td></tr></table></figure>\n<p>OK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。</p>\n<h2 id=\"How-coroutines-can-return-value-upon-termination\"><a href=\"#How-coroutines-can-return-value-upon-termination\" class=\"headerlink\" title=\"How coroutines can return value upon termination.\"></a>How coroutines can return value upon termination.</h2><p>当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return Result(count, average)</div><div class=\"line\">    </div><div class=\"line\">    coro_avg = averager()</div><div class=\"line\">    next(coro_avg)</div><div class=\"line\">    coro_avg.send(10)</div><div class=\"line\">    coro_avg.send(11)</div><div class=\"line\">    print(coro_avg.send(None))</div><div class=\"line\">    </div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration: result(count=2, average=10.5)</div><div class=\"line\">注意这里的StopIteration.它将Result也一起打印了出来。</div><div class=\"line\"></div><div class=\"line\">    try:</div><div class=\"line\">        coro_avg.send(None)</div><div class=\"line\">    except StopIteration as exec:</div><div class=\"line\">        print(exec.value)</div><div class=\"line\">result(count=2, average=10.5)</div><div class=\"line\">借助try/except我们可以的到正确的result.</div></pre></td></tr></table></figure>\n<p>后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。</p>\n<h2 id=\"Usage-and-semantics-of-the-new-yield-from-syntax\"><a href=\"#Usage-and-semantics-of-the-new-yield-from-syntax\" class=\"headerlink\" title=\"Usage and semantics of the new yield from syntax.\"></a>Usage and semantics of the new yield from syntax.</h2><p>前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。</p>\n<p><strong>yield from</strong>是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。</p>\n<p><strong>yield from x</strong>这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。</p>\n<p><strong>delegating generator</strong>是指函数里包含了yield from <iterable>表达式。</iterable></p>\n<p><strong>subgenerator</strong>指yield from <iterable>表达式里<iterable>得到的generator。</iterable></iterable></p>\n<p><strong>caller</strong>指调用delagating generator的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># subgenerator</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return result(count, average)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># delegating generator</div><div class=\"line\">def grouper(results, key):</div><div class=\"line\">    while True:</div><div class=\"line\">        results[key] = yield from averager()</div><div class=\"line\"></div><div class=\"line\"># caller</div><div class=\"line\">def main(data):</div><div class=\"line\">    results = &#123;&#125;</div><div class=\"line\">    for key, values in data.items():</div><div class=\"line\">        group = grouper(results, key)</div><div class=\"line\">        next(group)</div><div class=\"line\">        for value in values:</div><div class=\"line\">            group.send(value)</div><div class=\"line\">        group.send(None)  ## important</div><div class=\"line\"></div><div class=\"line\">    report(results)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def report(results):</div><div class=\"line\">    for key, values in sorted(results.items()):</div><div class=\"line\">        group, unit = key.split(&apos;;&apos;)</div><div class=\"line\">        print(&apos;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&apos;.format(</div><div class=\"line\">            values.count, group, values.average, unit</div><div class=\"line\">        ))</div><div class=\"line\">        </div><div class=\"line\">data = &#123;</div><div class=\"line\">    &apos;girls;kg&apos;:</div><div class=\"line\">        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],</div><div class=\"line\">    &apos;girls;m&apos;:</div><div class=\"line\">        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],</div><div class=\"line\">    &apos;boys;kg&apos;:</div><div class=\"line\">        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],</div><div class=\"line\">    &apos;boys;m&apos;:</div><div class=\"line\">        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],</div><div class=\"line\">&#125;</div><div class=\"line\">main(data)</div><div class=\"line\"></div><div class=\"line\"> 9 boys  averaging 40.42</div><div class=\"line\"> 9 boys  averaging 1.39</div><div class=\"line\">10 girls averaging 42.04</div><div class=\"line\">10 girls averaging 1.43</div></pre></td></tr></table></figure>\n<p>理解一下上面的代码：</p>\n<ul>\n<li>每一次迭代，调用grouper()创建的实例就是delegating generator.</li>\n<li>调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。</li>\n<li>group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。</li>\n<li>当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。</li>\n<li>当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。</li>\n</ul>\n<p>上面代码的<strong>核心</strong>概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。</p>\n<p>如果还没有完全理解yield from,我们再从<strong>PEP 380</strong>中给出的介绍来理解：</p>\n<ol>\n<li>任何subgenerator中yield的值都会直接传递给caller.</li>\n<li>任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的<strong>next</strong>()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.</li>\n<li>return expr在generator里会抛出StopIteration，并且退出这个generator.</li>\n<li>yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。</li>\n<li>通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.</li>\n<li>如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。</li>\n</ol>\n<p>为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\"></div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        _s = yield _y</div><div class=\"line\">        try:</div><div class=\"line\">            _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\"></div><div class=\"line\">RESULT = _r</div><div class=\"line\"></div><div class=\"line\">_i是subgenerator.</div><div class=\"line\">_y是subgenerator里yield出来的值.</div><div class=\"line\">_r是最终结果.</div><div class=\"line\">_s是caller传送给delegating generator的值，跳转给subgenerator.</div><div class=\"line\">_e是一个异常.</div><div class=\"line\"></div><div class=\"line\">如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        try:</div><div class=\"line\">            _s = yield _y</div><div class=\"line\">        except GeneratorExit as _e:</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.close</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                pass</div><div class=\"line\">            else:</div><div class=\"line\">                _m()</div><div class=\"line\">            raise _e</div><div class=\"line\">        except BaseException as _e:</div><div class=\"line\">            _x = sys.exc_info()</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.throw</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                raise _e</div><div class=\"line\">            else:</div><div class=\"line\">                try:</div><div class=\"line\">                    _y = _m(*_x)</div><div class=\"line\">                except Exception as _e:</div><div class=\"line\">                    _r = _e.value</div><div class=\"line\">                    break</div><div class=\"line\">    else:</div><div class=\"line\">        try:</div><div class=\"line\">            if _s is None:</div><div class=\"line\">                _y = next(_i)</div><div class=\"line\">            else:</div><div class=\"line\">                _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\">RESULT = _r</div></pre></td></tr></table></figure>\n<h2 id=\"A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\"><a href=\"#A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\" class=\"headerlink\" title=\"A use case: coroutines for managing concurrent activities in a simulation.\"></a>A use case: coroutines for managing concurrent activities in a simulation.</h2><p>最后我们通过一个写并发概念的简单demo来梳理一下概念</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Event = namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def taxi_process(ident, trips, start_time=0):</div><div class=\"line\">    &quot;&quot;&quot;Yield to simular issuing event at each state change.&quot;&quot;&quot;</div><div class=\"line\">    time = yield Event(start_time, ident, &apos;leave garge.&apos;)</div><div class=\"line\">    for i in range(trips):</div><div class=\"line\">        time = yield Event(time, ident, &apos;pick up passenger.&apos;)</div><div class=\"line\">        time = yield Event(time, ident, &apos;drop off passenger.&apos;)</div><div class=\"line\">    yield Event(time, ident, &apos;going home.&apos;)</div><div class=\"line\">    taxi = taxi_process(ident=1, trips=2)</div><div class=\"line\">    print(next(taxi))</div><div class=\"line\">    print(taxi.send(7))</div><div class=\"line\">    print(taxi.send(15))</div><div class=\"line\">    print(taxi.send(16))</div><div class=\"line\">    print(taxi.send(23))</div><div class=\"line\">    print(taxi.send(30))</div><div class=\"line\">Event(time=0, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">Event(time=7, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=15, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=16, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=23, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=30, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。</div><div class=\"line\"></div><div class=\"line\">import queue</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Simulator(object):</div><div class=\"line\">    def __init__(self, procs_map):</div><div class=\"line\">        self.events = queue.PriorityQueue()</div><div class=\"line\">        self.procs = dict(procs_map)</div><div class=\"line\"></div><div class=\"line\">    def run(self, end_time):</div><div class=\"line\">        &quot;&quot;&quot;Schedule and display events utill time is up.&quot;&quot;&quot;</div><div class=\"line\">        for _, proc in sorted(self.procs.items()):</div><div class=\"line\">            first_event = next(proc)</div><div class=\"line\">            self.events.put(first_event)</div><div class=\"line\"></div><div class=\"line\">        sim_time = 0</div><div class=\"line\">        while sim_time &lt; end_time:</div><div class=\"line\">            if self.events.empty():</div><div class=\"line\">                print(&apos;*** end of events ***&apos;)</div><div class=\"line\">                break</div><div class=\"line\">            current_event = self.events.get()</div><div class=\"line\">            sim_time, proc_id, previous_action = current_event</div><div class=\"line\">            print(&apos;taxi:&apos;, proc_id, proc_id * &apos;  &apos;, current_event)</div><div class=\"line\">            active_proc = self.procs[proc_id]</div><div class=\"line\">            next_time = sim_time + compute_duration(previous_action)</div><div class=\"line\">            try:</div><div class=\"line\">                next_event = active_proc.send(next_time)</div><div class=\"line\">            except StopIteration:</div><div class=\"line\">                del self.procs[proc_id]</div><div class=\"line\">            else:</div><div class=\"line\">                self.events.put(next_event)</div><div class=\"line\">        else:</div><div class=\"line\">            msg = &apos;*** end of simulation time: &#123;&#125; events pending ***&apos;</div><div class=\"line\">            print(msg.format(self.events.qsize()))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def compute_duration(previous_action):</div><div class=\"line\">    duration = 1</div><div class=\"line\">    if previous_action == &apos;pick up passenger.&apos;:</div><div class=\"line\">        duration = 3</div><div class=\"line\">    elif previous_action == &apos;drop off passenger.&apos;:</div><div class=\"line\">        duration = 5</div><div class=\"line\">    return duration</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    DEPARTURE_INTERVAL = 2</div><div class=\"line\">    num_taxis = 3</div><div class=\"line\">    taxis = &#123;</div><div class=\"line\">        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)</div><div class=\"line\">        for i in range(num_taxis)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sim = Simulator(taxis)</div><div class=\"line\">    print(sim.run(100))</div><div class=\"line\">taxi: 0  Event(time=0, proc=0, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 0  Event(time=1, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=2, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 1    Event(time=3, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=4, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=4, proc=2, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 2      Event(time=5, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=6, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=8, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=9, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=11, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=12, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=13, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=14, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=16, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=17, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=19, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=20, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=21, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=22, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=24, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=25, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=27, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=28, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=29, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=30, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=32, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=33, proc=0, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 1    Event(time=35, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=37, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=38, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=40, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=43, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=45, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=46, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=48, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=51, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 2      Event(time=53, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=56, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=61, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=64, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=69, proc=2, action=&apos;going home.&apos;)</div><div class=\"line\">*** end of events ***</div></pre></td></tr></table></figure>\n<p>请记住这个例子，之后在介绍<strong>asyncio</strong>时会进行详细的讲解。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>对于coroutine的介绍就到这里了，希望你已经理解了<strong>yield from</strong>的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！</p>\n<p>感谢你的阅读，希望能收到你的feedback :)</p>\n<p>本文代码地址: <a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo</a></p>\n"},{"title":"Python Function Decorators and Closures介绍","date":"2017-11-29T08:17:13.000Z","_content":"\n\n## Preface\n本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. **注意**本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。\n\n## How Python evaluates decorator syntax?\nPython对装饰器的使用了语法糖，如：\n\n```\n@decorate\ndef target():\n    print('Running target()')\n\ndef target():\n    print('Running target()')\ntarget = decorate(target)\n```\n二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。\n\n## When Python executes decorators?\n首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。\n装饰器是在import time被执行的，我们来看一个例子：\n\n```\nregistry = []\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('Running f1()')\n\n@register\ndef f2():\n    print('Running f2()')\n\ndef main():\n    print('running main')\n    print('registry ->', registry)\n    f1()\n    f2()\nif __name__ == '__main__':\n    main()\n------------------------------------------------------------------------    \nrunning register(<function f1 at 0x100c70158>)\nrunning register(<function f2 at 0x100c701e0>)\nrunning main\nregistry -> [<function f1 at 0x100c70158>, <function f2 at 0x100c701e0>]\nRunning f1()\nRunning f2()\n```\n通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。\n## How Python decides whether a variable is local?\n**Variable scope rules**这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。\n\n```\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n3\nNameError: name 'b' is not defined\nb = 6\nf1(3)\n3\n6\n\n接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\nf2(3)\n3\nUnboundLocalError: local variable 'b' referenced before assignment\n希望你可以先思考一下为什么没有打印出6。\n事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，\nprint()时发现b还未被赋值，所以抛出了错误。\n我们再通过字节码来确认一下是不是这样。\n\nprint(dis.dis(f1))\n  5           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n  6          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_GLOBAL              1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n             20 LOAD_CONST               0 (None)\n             23 RETURN_VALUE\n\nprint(dis.dis(f2))\n  9           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n 10          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_FAST                1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n\n 11          20 LOAD_CONST               1 (9)\n             23 STORE_FAST               1 (b)\n             26 LOAD_CONST               0 (None)\n对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。\n```\n如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。\n\n\n\n## Why closures exist and how they work?\n\n**闭包**，老样子，我们还是先思考一个例子。\n假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。\n\n```\n它的实现结果看起来应该是这样的\navg(10)\n10.0\navg(11)\n10.5\navg(12)\n11.0\n\n如果你已经思考过怎么实现这个函数了，那么继续往下看吧。\n\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n```\n我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是\nmake_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，\n并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？\n\npython里有个概念是**free variable**，而avarager里的series就是**free variable**.我们可以打印出来看看是不是这样。\n\n```\n    print(avg.__code__.co_varnames)\n    print(avg.__code__.co_freevars)\n    print(avg.__closure__[0].cell_contents)\n('new_value', 'total')\n('series',)\n[10, 11, 12]\n\n```\n可以看到，确实存在**free variable**这个属性，并且值是series.\n\n**总结一下**\n闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。\n\n\n## What problem is solved by nonlocal?\n爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        total += new_value\n        count += 1\n        return total / count\n    return averager\n\nif __name__ == '__main__':\n    avg = make_averager()\n    avg(10)    \n>>> UnboundLocalError: local variable 'total' referenced before assignment\n\n因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，\n根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量\n而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series\n一直是avg的自由变量。\n```\n所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal total, count\n        total += new_value\n        count += 1\n        return total / count\n    return averager\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n10.0\n10.5\n11.0\n```\n\n## Implementing a simple decorator\n\n通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。\n\n```\nimport time\n\ndef clock(func):\n    series = []\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\nprint('*' * 40, 'Calling snooze(0.123)')\nsnooze(.123)\n\n>>>**************************************** Calling snooze(0.123)\n>>>[0.12566963s] snooze (0.123) -> None\n\nprint(snooze.__name__)\nclocked\n\n如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()\n\ndef clock(func):\n    series = []\n    @functools.wraps(func)\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n\n    return clocked\n像上面这样的使用，就能消除装饰器的影响了。\n```\n\n## Summary\n感谢阅读，希望你能从这篇文章中有所收获。\n如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。\n\n本文的代码链接：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators)\n","source":"_posts/Python-Function-Decorators-and-Closures介绍.md","raw":"---\ntitle: Python Function Decorators and Closures介绍\ndate: 2017-11-29 16:17:13\ntags: Python\n\n---\n\n\n## Preface\n本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. **注意**本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。\n\n## How Python evaluates decorator syntax?\nPython对装饰器的使用了语法糖，如：\n\n```\n@decorate\ndef target():\n    print('Running target()')\n\ndef target():\n    print('Running target()')\ntarget = decorate(target)\n```\n二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。\n\n## When Python executes decorators?\n首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。\n装饰器是在import time被执行的，我们来看一个例子：\n\n```\nregistry = []\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('Running f1()')\n\n@register\ndef f2():\n    print('Running f2()')\n\ndef main():\n    print('running main')\n    print('registry ->', registry)\n    f1()\n    f2()\nif __name__ == '__main__':\n    main()\n------------------------------------------------------------------------    \nrunning register(<function f1 at 0x100c70158>)\nrunning register(<function f2 at 0x100c701e0>)\nrunning main\nregistry -> [<function f1 at 0x100c70158>, <function f2 at 0x100c701e0>]\nRunning f1()\nRunning f2()\n```\n通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。\n## How Python decides whether a variable is local?\n**Variable scope rules**这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。\n\n```\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n3\nNameError: name 'b' is not defined\nb = 6\nf1(3)\n3\n6\n\n接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\nf2(3)\n3\nUnboundLocalError: local variable 'b' referenced before assignment\n希望你可以先思考一下为什么没有打印出6。\n事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，\nprint()时发现b还未被赋值，所以抛出了错误。\n我们再通过字节码来确认一下是不是这样。\n\nprint(dis.dis(f1))\n  5           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n  6          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_GLOBAL              1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n             20 LOAD_CONST               0 (None)\n             23 RETURN_VALUE\n\nprint(dis.dis(f2))\n  9           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n 10          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_FAST                1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n\n 11          20 LOAD_CONST               1 (9)\n             23 STORE_FAST               1 (b)\n             26 LOAD_CONST               0 (None)\n对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。\n```\n如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。\n\n\n\n## Why closures exist and how they work?\n\n**闭包**，老样子，我们还是先思考一个例子。\n假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。\n\n```\n它的实现结果看起来应该是这样的\navg(10)\n10.0\navg(11)\n10.5\navg(12)\n11.0\n\n如果你已经思考过怎么实现这个函数了，那么继续往下看吧。\n\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n```\n我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是\nmake_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，\n并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？\n\npython里有个概念是**free variable**，而avarager里的series就是**free variable**.我们可以打印出来看看是不是这样。\n\n```\n    print(avg.__code__.co_varnames)\n    print(avg.__code__.co_freevars)\n    print(avg.__closure__[0].cell_contents)\n('new_value', 'total')\n('series',)\n[10, 11, 12]\n\n```\n可以看到，确实存在**free variable**这个属性，并且值是series.\n\n**总结一下**\n闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。\n\n\n## What problem is solved by nonlocal?\n爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        total += new_value\n        count += 1\n        return total / count\n    return averager\n\nif __name__ == '__main__':\n    avg = make_averager()\n    avg(10)    \n>>> UnboundLocalError: local variable 'total' referenced before assignment\n\n因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，\n根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量\n而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series\n一直是avg的自由变量。\n```\n所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal total, count\n        total += new_value\n        count += 1\n        return total / count\n    return averager\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n10.0\n10.5\n11.0\n```\n\n## Implementing a simple decorator\n\n通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。\n\n```\nimport time\n\ndef clock(func):\n    series = []\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\nprint('*' * 40, 'Calling snooze(0.123)')\nsnooze(.123)\n\n>>>**************************************** Calling snooze(0.123)\n>>>[0.12566963s] snooze (0.123) -> None\n\nprint(snooze.__name__)\nclocked\n\n如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()\n\ndef clock(func):\n    series = []\n    @functools.wraps(func)\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n\n    return clocked\n像上面这样的使用，就能消除装饰器的影响了。\n```\n\n## Summary\n感谢阅读，希望你能从这篇文章中有所收获。\n如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。\n\n本文的代码链接：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators)\n","slug":"Python-Function-Decorators-and-Closures介绍","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkr001vvmvvme7aohkv","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. <strong>注意</strong>本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。</p>\n<h2 id=\"How-Python-evaluates-decorator-syntax\"><a href=\"#How-Python-evaluates-decorator-syntax\" class=\"headerlink\" title=\"How Python evaluates decorator syntax?\"></a>How Python evaluates decorator syntax?</h2><p>Python对装饰器的使用了语法糖，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@decorate</div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\"></div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\">target = decorate(target)</div></pre></td></tr></table></figure>\n<p>二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。</p>\n<h2 id=\"When-Python-executes-decorators\"><a href=\"#When-Python-executes-decorators\" class=\"headerlink\" title=\"When Python executes decorators?\"></a>When Python executes decorators?</h2><p>首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。<br>装饰器是在import time被执行的，我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">registry = []</div><div class=\"line\">def register(func):</div><div class=\"line\">    print(&apos;running register(%s)&apos; % func)</div><div class=\"line\">    registry.append(func)</div><div class=\"line\">    return func</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f1():</div><div class=\"line\">    print(&apos;Running f1()&apos;)</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f2():</div><div class=\"line\">    print(&apos;Running f2()&apos;)</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print(&apos;running main&apos;)</div><div class=\"line\">    print(&apos;registry -&gt;&apos;, registry)</div><div class=\"line\">    f1()</div><div class=\"line\">    f2()</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">------------------------------------------------------------------------    </div><div class=\"line\">running register(&lt;function f1 at 0x100c70158&gt;)</div><div class=\"line\">running register(&lt;function f2 at 0x100c701e0&gt;)</div><div class=\"line\">running main</div><div class=\"line\">registry -&gt; [&lt;function f1 at 0x100c70158&gt;, &lt;function f2 at 0x100c701e0&gt;]</div><div class=\"line\">Running f1()</div><div class=\"line\">Running f2()</div></pre></td></tr></table></figure>\n<p>通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。</p>\n<h2 id=\"How-Python-decides-whether-a-variable-is-local\"><a href=\"#How-Python-decides-whether-a-variable-is-local\" class=\"headerlink\" title=\"How Python decides whether a variable is local?\"></a>How Python decides whether a variable is local?</h2><p><strong>Variable scope rules</strong>这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\"></div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">NameError: name &apos;b&apos; is not defined</div><div class=\"line\">b = 6</div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。</div><div class=\"line\">def f2(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\">    b = 9</div><div class=\"line\">f2(3)</div><div class=\"line\">3</div><div class=\"line\">UnboundLocalError: local variable &apos;b&apos; referenced before assignment</div><div class=\"line\">希望你可以先思考一下为什么没有打印出6。</div><div class=\"line\">事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，</div><div class=\"line\">print()时发现b还未被赋值，所以抛出了错误。</div><div class=\"line\">我们再通过字节码来确认一下是不是这样。</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f1))</div><div class=\"line\">  5           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\">  6          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_GLOBAL              1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\">             20 LOAD_CONST               0 (None)</div><div class=\"line\">             23 RETURN_VALUE</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f2))</div><div class=\"line\">  9           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 10          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_FAST                1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 11          20 LOAD_CONST               1 (9)</div><div class=\"line\">             23 STORE_FAST               1 (b)</div><div class=\"line\">             26 LOAD_CONST               0 (None)</div><div class=\"line\">对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。</div></pre></td></tr></table></figure>\n<p>如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。</p>\n<h2 id=\"Why-closures-exist-and-how-they-work\"><a href=\"#Why-closures-exist-and-how-they-work\" class=\"headerlink\" title=\"Why closures exist and how they work?\"></a>Why closures exist and how they work?</h2><p><strong>闭包</strong>，老样子，我们还是先思考一个例子。<br>假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">它的实现结果看起来应该是这样的</div><div class=\"line\">avg(10)</div><div class=\"line\">10.0</div><div class=\"line\">avg(11)</div><div class=\"line\">10.5</div><div class=\"line\">avg(12)</div><div class=\"line\">11.0</div><div class=\"line\"></div><div class=\"line\">如果你已经思考过怎么实现这个函数了，那么继续往下看吧。</div><div class=\"line\"></div><div class=\"line\">def make_averager():</div><div class=\"line\">    series = []</div><div class=\"line\"></div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        series.append(new_value)</div><div class=\"line\">        total = sum(series)</div><div class=\"line\">        return total / len(series)</div><div class=\"line\"></div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div></pre></td></tr></table></figure>\n<p>我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是<br>make_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，<br>并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？</p>\n<p>python里有个概念是<strong>free variable</strong>，而avarager里的series就是<strong>free variable</strong>.我们可以打印出来看看是不是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    print(avg.__code__.co_varnames)</div><div class=\"line\">    print(avg.__code__.co_freevars)</div><div class=\"line\">    print(avg.__closure__[0].cell_contents)</div><div class=\"line\">(&apos;new_value&apos;, &apos;total&apos;)</div><div class=\"line\">(&apos;series&apos;,)</div><div class=\"line\">[10, 11, 12]</div></pre></td></tr></table></figure>\n<p>可以看到，确实存在<strong>free variable</strong>这个属性，并且值是series.</p>\n<p><strong>总结一下</strong><br>闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。</p>\n<h2 id=\"What-problem-is-solved-by-nonlocal\"><a href=\"#What-problem-is-solved-by-nonlocal\" class=\"headerlink\" title=\"What problem is solved by nonlocal?\"></a>What problem is solved by nonlocal?</h2><p>爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    avg = make_averager()</div><div class=\"line\">    avg(10)    </div><div class=\"line\">&gt;&gt;&gt; UnboundLocalError: local variable &apos;total&apos; referenced before assignment</div><div class=\"line\"></div><div class=\"line\">因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，</div><div class=\"line\">根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量</div><div class=\"line\">而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series</div><div class=\"line\">一直是avg的自由变量。</div></pre></td></tr></table></figure>\n<p>所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        nonlocal total, count</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div><div class=\"line\"></div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div></pre></td></tr></table></figure>\n<h2 id=\"Implementing-a-simple-decorator\"><a href=\"#Implementing-a-simple-decorator\" class=\"headerlink\" title=\"Implementing a simple decorator\"></a>Implementing a simple decorator</h2><p>通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\">    return clocked</div><div class=\"line\"></div><div class=\"line\">@clock</div><div class=\"line\">def snooze(seconds):</div><div class=\"line\">    time.sleep(seconds)</div><div class=\"line\"></div><div class=\"line\">print(&apos;*&apos; * 40, &apos;Calling snooze(0.123)&apos;)</div><div class=\"line\">snooze(.123)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;**************************************** Calling snooze(0.123)</div><div class=\"line\">&gt;&gt;&gt;[0.12566963s] snooze (0.123) -&gt; None</div><div class=\"line\"></div><div class=\"line\">print(snooze.__name__)</div><div class=\"line\">clocked</div><div class=\"line\"></div><div class=\"line\">如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\"></div><div class=\"line\">    return clocked</div><div class=\"line\">像上面这样的使用，就能消除装饰器的影响了。</div></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你能从这篇文章中有所收获。<br>如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。</p>\n<p>本文的代码链接：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. <strong>注意</strong>本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。</p>\n<h2 id=\"How-Python-evaluates-decorator-syntax\"><a href=\"#How-Python-evaluates-decorator-syntax\" class=\"headerlink\" title=\"How Python evaluates decorator syntax?\"></a>How Python evaluates decorator syntax?</h2><p>Python对装饰器的使用了语法糖，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@decorate</div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\"></div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\">target = decorate(target)</div></pre></td></tr></table></figure>\n<p>二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。</p>\n<h2 id=\"When-Python-executes-decorators\"><a href=\"#When-Python-executes-decorators\" class=\"headerlink\" title=\"When Python executes decorators?\"></a>When Python executes decorators?</h2><p>首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。<br>装饰器是在import time被执行的，我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">registry = []</div><div class=\"line\">def register(func):</div><div class=\"line\">    print(&apos;running register(%s)&apos; % func)</div><div class=\"line\">    registry.append(func)</div><div class=\"line\">    return func</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f1():</div><div class=\"line\">    print(&apos;Running f1()&apos;)</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f2():</div><div class=\"line\">    print(&apos;Running f2()&apos;)</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print(&apos;running main&apos;)</div><div class=\"line\">    print(&apos;registry -&gt;&apos;, registry)</div><div class=\"line\">    f1()</div><div class=\"line\">    f2()</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">------------------------------------------------------------------------    </div><div class=\"line\">running register(&lt;function f1 at 0x100c70158&gt;)</div><div class=\"line\">running register(&lt;function f2 at 0x100c701e0&gt;)</div><div class=\"line\">running main</div><div class=\"line\">registry -&gt; [&lt;function f1 at 0x100c70158&gt;, &lt;function f2 at 0x100c701e0&gt;]</div><div class=\"line\">Running f1()</div><div class=\"line\">Running f2()</div></pre></td></tr></table></figure>\n<p>通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。</p>\n<h2 id=\"How-Python-decides-whether-a-variable-is-local\"><a href=\"#How-Python-decides-whether-a-variable-is-local\" class=\"headerlink\" title=\"How Python decides whether a variable is local?\"></a>How Python decides whether a variable is local?</h2><p><strong>Variable scope rules</strong>这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\"></div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">NameError: name &apos;b&apos; is not defined</div><div class=\"line\">b = 6</div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。</div><div class=\"line\">def f2(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\">    b = 9</div><div class=\"line\">f2(3)</div><div class=\"line\">3</div><div class=\"line\">UnboundLocalError: local variable &apos;b&apos; referenced before assignment</div><div class=\"line\">希望你可以先思考一下为什么没有打印出6。</div><div class=\"line\">事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，</div><div class=\"line\">print()时发现b还未被赋值，所以抛出了错误。</div><div class=\"line\">我们再通过字节码来确认一下是不是这样。</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f1))</div><div class=\"line\">  5           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\">  6          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_GLOBAL              1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\">             20 LOAD_CONST               0 (None)</div><div class=\"line\">             23 RETURN_VALUE</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f2))</div><div class=\"line\">  9           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 10          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_FAST                1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 11          20 LOAD_CONST               1 (9)</div><div class=\"line\">             23 STORE_FAST               1 (b)</div><div class=\"line\">             26 LOAD_CONST               0 (None)</div><div class=\"line\">对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。</div></pre></td></tr></table></figure>\n<p>如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。</p>\n<h2 id=\"Why-closures-exist-and-how-they-work\"><a href=\"#Why-closures-exist-and-how-they-work\" class=\"headerlink\" title=\"Why closures exist and how they work?\"></a>Why closures exist and how they work?</h2><p><strong>闭包</strong>，老样子，我们还是先思考一个例子。<br>假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">它的实现结果看起来应该是这样的</div><div class=\"line\">avg(10)</div><div class=\"line\">10.0</div><div class=\"line\">avg(11)</div><div class=\"line\">10.5</div><div class=\"line\">avg(12)</div><div class=\"line\">11.0</div><div class=\"line\"></div><div class=\"line\">如果你已经思考过怎么实现这个函数了，那么继续往下看吧。</div><div class=\"line\"></div><div class=\"line\">def make_averager():</div><div class=\"line\">    series = []</div><div class=\"line\"></div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        series.append(new_value)</div><div class=\"line\">        total = sum(series)</div><div class=\"line\">        return total / len(series)</div><div class=\"line\"></div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div></pre></td></tr></table></figure>\n<p>我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是<br>make_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，<br>并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？</p>\n<p>python里有个概念是<strong>free variable</strong>，而avarager里的series就是<strong>free variable</strong>.我们可以打印出来看看是不是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    print(avg.__code__.co_varnames)</div><div class=\"line\">    print(avg.__code__.co_freevars)</div><div class=\"line\">    print(avg.__closure__[0].cell_contents)</div><div class=\"line\">(&apos;new_value&apos;, &apos;total&apos;)</div><div class=\"line\">(&apos;series&apos;,)</div><div class=\"line\">[10, 11, 12]</div></pre></td></tr></table></figure>\n<p>可以看到，确实存在<strong>free variable</strong>这个属性，并且值是series.</p>\n<p><strong>总结一下</strong><br>闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。</p>\n<h2 id=\"What-problem-is-solved-by-nonlocal\"><a href=\"#What-problem-is-solved-by-nonlocal\" class=\"headerlink\" title=\"What problem is solved by nonlocal?\"></a>What problem is solved by nonlocal?</h2><p>爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    avg = make_averager()</div><div class=\"line\">    avg(10)    </div><div class=\"line\">&gt;&gt;&gt; UnboundLocalError: local variable &apos;total&apos; referenced before assignment</div><div class=\"line\"></div><div class=\"line\">因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，</div><div class=\"line\">根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量</div><div class=\"line\">而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series</div><div class=\"line\">一直是avg的自由变量。</div></pre></td></tr></table></figure>\n<p>所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        nonlocal total, count</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div><div class=\"line\"></div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div></pre></td></tr></table></figure>\n<h2 id=\"Implementing-a-simple-decorator\"><a href=\"#Implementing-a-simple-decorator\" class=\"headerlink\" title=\"Implementing a simple decorator\"></a>Implementing a simple decorator</h2><p>通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\">    return clocked</div><div class=\"line\"></div><div class=\"line\">@clock</div><div class=\"line\">def snooze(seconds):</div><div class=\"line\">    time.sleep(seconds)</div><div class=\"line\"></div><div class=\"line\">print(&apos;*&apos; * 40, &apos;Calling snooze(0.123)&apos;)</div><div class=\"line\">snooze(.123)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;**************************************** Calling snooze(0.123)</div><div class=\"line\">&gt;&gt;&gt;[0.12566963s] snooze (0.123) -&gt; None</div><div class=\"line\"></div><div class=\"line\">print(snooze.__name__)</div><div class=\"line\">clocked</div><div class=\"line\"></div><div class=\"line\">如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\"></div><div class=\"line\">    return clocked</div><div class=\"line\">像上面这样的使用，就能消除装饰器的影响了。</div></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你能从这篇文章中有所收获。<br>如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。</p>\n<p>本文的代码链接：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators</a></p>\n"},{"title":"Python Iterators and Iterables介绍","date":"2017-12-02T07:02:24.000Z","_content":"## Concept\nIteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行**惰性**读取，意味着每次操作只读取一条数据-----而这就是Iterator模式。\n\n\n## Iterables\n`iterable `  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了__ iter__方法并且返回一个iterator，那么称对象是iterable.\n\n在Python里所有的集合都是可迭代的，例如：\n\n* for 循环\n* 集合类型和其扩展\n* list, dict, set类型的解析式\n* tuple类型的unpack\n* 对函数的*args形参进行unpack\n\n诸如此类的操作，都是iterable.\n\n通过例子我们再来探索一下\n\n```\nRE_WORD = re.compile(r'\\w+')\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __len__(self):\n        return len(self.words)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。\n```\n\n\n## How the iter(...) built-in function is used to internally to hanlde iterable objects.\n\n每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？\n这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。\n\niter()方法的使用规则：\n\n1. 检查对象是否实现了__ iter__方法，如果有，则调用得到一个iterator.\n2. 如果__ iter__ 方法没有被实现，但是对象实现了__ getitem__方法，那么Python会创建一个Iterator并按照顺序从0开始索引.\n3. 如果没有实现以上方法，或者操作失败。Python会抛出**TypeError**， 如：TypeError: 'Sentence' object is not iterable.\n\n而正是Python的序列对象都实现了 __ getitem__方法，所以它们都是可迭代的。（通常标准的sequences也会实现 __ iter__方法）\n\n\n## How to implement the classic Iterator pattern in Python.\niterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:\n\n```\ns = 'ABC'\nfor char in s:\n    print(char)\nA\nB\nC\n这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。\n\ns = 'ABC'\nit = iter(s)\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        del it\n        break\n```\n**StopIteration** 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。\n\n标准的iterator接口有两个方法：\n\n1.  __ next__  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。\n2.  __ iter__  返回自身；这样可用于for循环操作。\n\n当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了__ iter__ 方法，调用它也只能获得它本身，所以不可能进行重设操作。\n\n`iterator` 是指实现了__ next__ 和__ iter__方法的对象, __ next__ 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了__ iter__方法，所以iterator同时也是iterable。\n\n接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n    def __iter__(self):\n        return SentenceIterator(self.words)\n\n\nclass SentenceIterator(object):\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n```\n通过这个例子，可以看到： iterable实现了 __ iter__方法，每次调用会返回一个iterator实例。iterator对象实现了 __ next__ 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), __ iter__ 方法每次返回自身。\n因此，我们可以说**iterator是iterable，但是iterable不是iterator.**\n\n\n最后我们作出一个猜想： 我们可不可以在Sentence类里实现__ next__方法呢，使Sentence既是iterator也是iterable，岂不美哉？\n\n答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。\n\n**Iterator Pattern**里有一点：to support multiple traversals of aggregate objects.\n如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了__ next__方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。\n\n\n## Summary\n感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。\n\n本文代码链接:[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。\n\n值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念**generator**也与其有关。因为篇幅原因，我将其拆分为另一篇文章[a](a)，打铁要趁热！！！快来学习一下！！！\n\n\n","source":"_posts/Python-Iterators-and-Iterables介绍.md","raw":"---\ntitle: Python Iterators and Iterables介绍\ndate: 2017-12-02 15:02:24\ntags: Python\n\n---\n## Concept\nIteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行**惰性**读取，意味着每次操作只读取一条数据-----而这就是Iterator模式。\n\n\n## Iterables\n`iterable `  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了__ iter__方法并且返回一个iterator，那么称对象是iterable.\n\n在Python里所有的集合都是可迭代的，例如：\n\n* for 循环\n* 集合类型和其扩展\n* list, dict, set类型的解析式\n* tuple类型的unpack\n* 对函数的*args形参进行unpack\n\n诸如此类的操作，都是iterable.\n\n通过例子我们再来探索一下\n\n```\nRE_WORD = re.compile(r'\\w+')\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __len__(self):\n        return len(self.words)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。\n```\n\n\n## How the iter(...) built-in function is used to internally to hanlde iterable objects.\n\n每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？\n这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。\n\niter()方法的使用规则：\n\n1. 检查对象是否实现了__ iter__方法，如果有，则调用得到一个iterator.\n2. 如果__ iter__ 方法没有被实现，但是对象实现了__ getitem__方法，那么Python会创建一个Iterator并按照顺序从0开始索引.\n3. 如果没有实现以上方法，或者操作失败。Python会抛出**TypeError**， 如：TypeError: 'Sentence' object is not iterable.\n\n而正是Python的序列对象都实现了 __ getitem__方法，所以它们都是可迭代的。（通常标准的sequences也会实现 __ iter__方法）\n\n\n## How to implement the classic Iterator pattern in Python.\niterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:\n\n```\ns = 'ABC'\nfor char in s:\n    print(char)\nA\nB\nC\n这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。\n\ns = 'ABC'\nit = iter(s)\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        del it\n        break\n```\n**StopIteration** 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。\n\n标准的iterator接口有两个方法：\n\n1.  __ next__  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。\n2.  __ iter__  返回自身；这样可用于for循环操作。\n\n当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了__ iter__ 方法，调用它也只能获得它本身，所以不可能进行重设操作。\n\n`iterator` 是指实现了__ next__ 和__ iter__方法的对象, __ next__ 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了__ iter__方法，所以iterator同时也是iterable。\n\n接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n    def __iter__(self):\n        return SentenceIterator(self.words)\n\n\nclass SentenceIterator(object):\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n```\n通过这个例子，可以看到： iterable实现了 __ iter__方法，每次调用会返回一个iterator实例。iterator对象实现了 __ next__ 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), __ iter__ 方法每次返回自身。\n因此，我们可以说**iterator是iterable，但是iterable不是iterator.**\n\n\n最后我们作出一个猜想： 我们可不可以在Sentence类里实现__ next__方法呢，使Sentence既是iterator也是iterable，岂不美哉？\n\n答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。\n\n**Iterator Pattern**里有一点：to support multiple traversals of aggregate objects.\n如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了__ next__方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。\n\n\n## Summary\n感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。\n\n本文代码链接:[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。\n\n值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念**generator**也与其有关。因为篇幅原因，我将其拆分为另一篇文章[a](a)，打铁要趁热！！！快来学习一下！！！\n\n\n","slug":"Python-Iterators-and-Iterables介绍","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkr001yvmvvbpbk9bs4","content":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行<strong>惰性</strong>读取，意味着每次操作只读取一条数据—–而这就是Iterator模式。</p>\n<h2 id=\"Iterables\"><a href=\"#Iterables\" class=\"headerlink\" title=\"Iterables\"></a>Iterables</h2><p><code>iterable</code>  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了<strong> iter</strong>方法并且返回一个iterator，那么称对象是iterable.</p>\n<p>在Python里所有的集合都是可迭代的，例如：</p>\n<ul>\n<li>for 循环</li>\n<li>集合类型和其扩展</li>\n<li>list, dict, set类型的解析式</li>\n<li>tuple类型的unpack</li>\n<li>对函数的*args形参进行unpack</li>\n</ul>\n<p>诸如此类的操作，都是iterable.</p>\n<p>通过例子我们再来探索一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __len__(self):</div><div class=\"line\">        return len(self.words)</div><div class=\"line\"></div><div class=\"line\">    def __getitem__(self, index):</div><div class=\"line\">        return self.words[index]</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\"><a href=\"#How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\" class=\"headerlink\" title=\"How the iter(…) built-in function is used to internally to hanlde iterable objects.\"></a>How the iter(…) built-in function is used to internally to hanlde iterable objects.</h2><p>每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？<br>这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。</p>\n<p>iter()方法的使用规则：</p>\n<ol>\n<li>检查对象是否实现了<strong> iter</strong>方法，如果有，则调用得到一个iterator.</li>\n<li>如果<strong> iter</strong> 方法没有被实现，但是对象实现了<strong> getitem</strong>方法，那么Python会创建一个Iterator并按照顺序从0开始索引.</li>\n<li>如果没有实现以上方法，或者操作失败。Python会抛出<strong>TypeError</strong>， 如：TypeError: ‘Sentence’ object is not iterable.</li>\n</ol>\n<p>而正是Python的序列对象都实现了 <strong> getitem</strong>方法，所以它们都是可迭代的。（通常标准的sequences也会实现 <strong> iter</strong>方法）</p>\n<h2 id=\"How-to-implement-the-classic-Iterator-pattern-in-Python\"><a href=\"#How-to-implement-the-classic-Iterator-pattern-in-Python\" class=\"headerlink\" title=\"How to implement the classic Iterator pattern in Python.\"></a>How to implement the classic Iterator pattern in Python.</h2><p>iterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">for char in s:</div><div class=\"line\">    print(char)</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\">这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。</div><div class=\"line\"></div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">it = iter(s)</div><div class=\"line\">while True:</div><div class=\"line\">    try:</div><div class=\"line\">        print(next(it))</div><div class=\"line\">    except StopIteration:</div><div class=\"line\">        del it</div><div class=\"line\">        break</div></pre></td></tr></table></figure>\n<p><strong>StopIteration</strong> 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。</p>\n<p>标准的iterator接口有两个方法：</p>\n<ol>\n<li><strong> next</strong>  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。</li>\n<li><strong> iter</strong>  返回自身；这样可用于for循环操作。</li>\n</ol>\n<p>当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了<strong> iter</strong> 方法，调用它也只能获得它本身，所以不可能进行重设操作。</p>\n<p><code>iterator</code> 是指实现了<strong> next</strong> 和<strong> iter</strong>方法的对象, <strong> next</strong> 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了<strong> iter</strong>方法，所以iterator同时也是iterable。</p>\n<p>接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return SentenceIterator(self.words)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class SentenceIterator(object):</div><div class=\"line\">    def __init__(self, words):</div><div class=\"line\">        self.words = words</div><div class=\"line\">        self.index = 0</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return self</div><div class=\"line\"></div><div class=\"line\">    def __next__(self):</div><div class=\"line\">        try:</div><div class=\"line\">            word = self.words[self.index]</div><div class=\"line\">        except IndexError:</div><div class=\"line\">            raise StopIteration()</div><div class=\"line\">        self.index += 1</div><div class=\"line\">        return word</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div></pre></td></tr></table></figure>\n<p>通过这个例子，可以看到： iterable实现了 <strong> iter</strong>方法，每次调用会返回一个iterator实例。iterator对象实现了 <strong> next</strong> 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), <strong> iter</strong> 方法每次返回自身。<br>因此，我们可以说<strong>iterator是iterable，但是iterable不是iterator.</strong></p>\n<p>最后我们作出一个猜想： 我们可不可以在Sentence类里实现<strong> next</strong>方法呢，使Sentence既是iterator也是iterable，岂不美哉？</p>\n<p>答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。</p>\n<p><strong>Iterator Pattern</strong>里有一点：to support multiple traversals of aggregate objects.<br>如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了<strong> next</strong>方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。</p>\n<p>本文代码链接:<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n<p>如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。</p>\n<p>值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念<strong>generator</strong>也与其有关。因为篇幅原因，我将其拆分为另一篇文章<a href=\"a\">a</a>，打铁要趁热！！！快来学习一下！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行<strong>惰性</strong>读取，意味着每次操作只读取一条数据—–而这就是Iterator模式。</p>\n<h2 id=\"Iterables\"><a href=\"#Iterables\" class=\"headerlink\" title=\"Iterables\"></a>Iterables</h2><p><code>iterable</code>  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了<strong> iter</strong>方法并且返回一个iterator，那么称对象是iterable.</p>\n<p>在Python里所有的集合都是可迭代的，例如：</p>\n<ul>\n<li>for 循环</li>\n<li>集合类型和其扩展</li>\n<li>list, dict, set类型的解析式</li>\n<li>tuple类型的unpack</li>\n<li>对函数的*args形参进行unpack</li>\n</ul>\n<p>诸如此类的操作，都是iterable.</p>\n<p>通过例子我们再来探索一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __len__(self):</div><div class=\"line\">        return len(self.words)</div><div class=\"line\"></div><div class=\"line\">    def __getitem__(self, index):</div><div class=\"line\">        return self.words[index]</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\"><a href=\"#How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\" class=\"headerlink\" title=\"How the iter(…) built-in function is used to internally to hanlde iterable objects.\"></a>How the iter(…) built-in function is used to internally to hanlde iterable objects.</h2><p>每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？<br>这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。</p>\n<p>iter()方法的使用规则：</p>\n<ol>\n<li>检查对象是否实现了<strong> iter</strong>方法，如果有，则调用得到一个iterator.</li>\n<li>如果<strong> iter</strong> 方法没有被实现，但是对象实现了<strong> getitem</strong>方法，那么Python会创建一个Iterator并按照顺序从0开始索引.</li>\n<li>如果没有实现以上方法，或者操作失败。Python会抛出<strong>TypeError</strong>， 如：TypeError: ‘Sentence’ object is not iterable.</li>\n</ol>\n<p>而正是Python的序列对象都实现了 <strong> getitem</strong>方法，所以它们都是可迭代的。（通常标准的sequences也会实现 <strong> iter</strong>方法）</p>\n<h2 id=\"How-to-implement-the-classic-Iterator-pattern-in-Python\"><a href=\"#How-to-implement-the-classic-Iterator-pattern-in-Python\" class=\"headerlink\" title=\"How to implement the classic Iterator pattern in Python.\"></a>How to implement the classic Iterator pattern in Python.</h2><p>iterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">for char in s:</div><div class=\"line\">    print(char)</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\">这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。</div><div class=\"line\"></div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">it = iter(s)</div><div class=\"line\">while True:</div><div class=\"line\">    try:</div><div class=\"line\">        print(next(it))</div><div class=\"line\">    except StopIteration:</div><div class=\"line\">        del it</div><div class=\"line\">        break</div></pre></td></tr></table></figure>\n<p><strong>StopIteration</strong> 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。</p>\n<p>标准的iterator接口有两个方法：</p>\n<ol>\n<li><strong> next</strong>  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。</li>\n<li><strong> iter</strong>  返回自身；这样可用于for循环操作。</li>\n</ol>\n<p>当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了<strong> iter</strong> 方法，调用它也只能获得它本身，所以不可能进行重设操作。</p>\n<p><code>iterator</code> 是指实现了<strong> next</strong> 和<strong> iter</strong>方法的对象, <strong> next</strong> 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了<strong> iter</strong>方法，所以iterator同时也是iterable。</p>\n<p>接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return SentenceIterator(self.words)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class SentenceIterator(object):</div><div class=\"line\">    def __init__(self, words):</div><div class=\"line\">        self.words = words</div><div class=\"line\">        self.index = 0</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return self</div><div class=\"line\"></div><div class=\"line\">    def __next__(self):</div><div class=\"line\">        try:</div><div class=\"line\">            word = self.words[self.index]</div><div class=\"line\">        except IndexError:</div><div class=\"line\">            raise StopIteration()</div><div class=\"line\">        self.index += 1</div><div class=\"line\">        return word</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div></pre></td></tr></table></figure>\n<p>通过这个例子，可以看到： iterable实现了 <strong> iter</strong>方法，每次调用会返回一个iterator实例。iterator对象实现了 <strong> next</strong> 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), <strong> iter</strong> 方法每次返回自身。<br>因此，我们可以说<strong>iterator是iterable，但是iterable不是iterator.</strong></p>\n<p>最后我们作出一个猜想： 我们可不可以在Sentence类里实现<strong> next</strong>方法呢，使Sentence既是iterator也是iterable，岂不美哉？</p>\n<p>答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。</p>\n<p><strong>Iterator Pattern</strong>里有一点：to support multiple traversals of aggregate objects.<br>如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了<strong> next</strong>方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。</p>\n<p>本文代码链接:<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n<p>如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。</p>\n<p>值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念<strong>generator</strong>也与其有关。因为篇幅原因，我将其拆分为另一篇文章<a href=\"a\">a</a>，打铁要趁热！！！快来学习一下！！！</p>\n"},{"title":"Python concurrency with futures","date":"2017-12-13T03:42:48.000Z","_content":"## Preface\n\n当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。\n\n\n## Sequential \n```\nimport os\nimport time\nimport sys\n\nimport requests  # It's not the standard library, so separate it from top with a blank line.\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    resp = requests.get(url)\n    return resp.content\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()  # flush stdout buffter.\n\n\ndef download_many(cc_list):\n    for cc in sorted(cc_list):\n        image = get_flag(cc)\n        show(cc)\n        save_flags(image, cc.lower() + '.gif')\n\n    return len(cc_list)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\n\n\nif __name__ == '__main__':\n    main(download_many)\n\nBD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN \n19 flags download in 21.66s\n```\n\n\n## Concurrent.futures\n\n主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。\n\n```\nfrom concurrent import futures\n\nfrom Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main\n\nMAX_WORKERS = 20\n\ndef download_one(cc):\n    image = get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))\n    with futures.ThreadPoolExecutor(workers) as executor:\n        res = executor.map(download_one, sorted(cc_list))\n\n    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。\n\nif __name__ == '__main__':\n    main(download_many)\n    \nTR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD \n19 flags download in 1.69s\n\n```\n1. 在上下文管理器中，executor的__exit__方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。\n2. 注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。\n\n\n看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？\n\n* future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。\n* 它是Future class的实例，表示已经结束或者还未结束的计算的延时。\n* Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。\n* 虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。\n* 只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。\n\n\n接下来我们用concurrency.futures.as_completed()修改上面写过的代码。\n\n```\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=3) as executor:\n        to_do = []\n        for cc in sorted(cc_list):\n            future = executor.submit(download_one, cc)\n            to_do.append(future)\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n\n        results = []\n        for future in futures.as_completed(to_do):\n            res = future.result()\n            msg = '{} result: {!r}'\n            print(msg.format(future, res))\n            results.append(res)\n\n    return len(results)\n\nScheduled for BR: <Future at 0x1020f2080 state=running>\nScheduled for CN: <Future at 0x1020f27f0 state=running>\nScheduled for ID: <Future at 0x1020f27b8 state=running>\nScheduled for IN: <Future at 0x1020fe320 state=pending>\nScheduled for US: <Future at 0x1020fe3c8 state=pending>\nBR <Future at 0x1020f2080 state=finished returned str> result: 'BR'\nID <Future at 0x1020f27b8 state=finished returned str> result: 'ID'\nIN <Future at 0x1020fe320 state=finished returned str> result: 'IN'\nUS <Future at 0x1020fe3c8 state=finished returned str> result: 'US'\nCN <Future at 0x1020f27f0 state=finished returned str> result: 'CN'\n\n5 flags download in 3.39s\n```\n\nexecutor.submit(download_one, cc)安排download _one被执行，它会返回future。\n注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。\n\n\n\n##### Experimenting with Executor.map\n\n```\nfrom time import sleep, strftime\nfrom concurrent import futures\n\n\ndef display(*args):\n    print(strftime('[%H:%M:%S]'), end=' ')\n    print(*args)\n\n\ndef loiter(n):\n    msg = '{}loiter({}): doing nothing for {}s...'\n    display(msg.format('\\t' * n, n, n))\n    sleep(n)\n    msg = '{}loiter({}): done'\n    display(msg.format('\\t' * n, n))\n    return n * 10\n\n\ndef main():\n    display('Script starting.')\n    executor = futures.ThreadPoolExecutor(max_workers=3)\n    results = executor.map(loiter, range(5))\n    display('results:', results)\n    display('Wating for individual results:')\n    for i, result in enumerate(results):\n        display('result {}: {}'.format(i, result))\nif __name__ == '__main__':\n    main()\n[10:08:03] Script starting.\n[10:08:03] loiter(0): doing nothing for 0s...\n[10:08:03] loiter(0): done\n[10:08:03] \tloiter(1): doing nothing for 1s...\n[10:08:03] \t\tloiter(2): doing nothing for 2s...\n[10:08:03] results: <generator object Executor.map.<locals>.result_iterator at 0x10d6ef468>\n[10:08:03] Wating for individual results:\n[10:08:03] result 0: 0\n[10:08:03] \t\t\tloiter(3): doing nothing for 3s...\n[10:08:04] \tloiter(1): done\n[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...\n[10:08:04] result 1: 10\n[10:08:05] \t\tloiter(2): done\n[10:08:05] result 2: 20\n[10:08:06] \t\t\tloiter(3): done\n[10:08:06] result 3: 30\n[10:08:08] \t\t\t\tloiter(4): done\n[10:08:08] result 4: 40\n注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。\n```\n\n推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。\n\n这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。\n\n\n## Downloads with progress display and error handing\n\n我们先介绍python中一个有趣的库**tqdm**，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。\n\n```\nimport time\nfrom tqdm import tqdm\n    for i in tqdm(range(100)):\n        time.sleep(0.1)\n100%|██████████| 100/100 [00:10<00:00,  9.70it/s]\n```\n\n先看sequentially download\n\n```\n\ndef get_flag(base_url, cc):\n    url = '{}/{cc}/{cc}.gif'.format(base_url, cc=cc.lower())\n    resp = requests.get(url)\n    if resp.status_code != 200:\n        resp.raise_for_status()\n    return resp.content\n\n\ndef download_one(cc, base_url, verbose=False):\n    try:\n        image = get_flag(base_url, cc)\n    except requests.exceptions.HTTPError as exc:\n        res = exc.response\n        if res.status_code == 404:\n            status = HTTPStatus.NOT_FOUND\n            msg = 'not found'\n        else:\n            raise\n\n    else:\n        save_flags(image, cc.lower() + '.gif')\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose:\n        print(cc, msg)\n\n    return Result(status, cc)\n\n\ndef download_many(cc_list, base_url, verbose, max_req):\n    counter = Counter()\n    cc_iter = sorted(cc_list)\n    if not verbose:\n        cc_iter = tqdm(cc_iter)\n    for cc in cc_iter:\n        try:\n            res = download_one(cc, base_url, verbose)\n        except requests.exceptions.HTTPError as exc:\n            error_msg = 'HTTP error {res.status_code} - {res.reason}'\n            error_msg = error_msg.format(res=exc.response)\n        except requests.exceptions.ConnectionError as exc:\n            error_msg = 'Connection error'\n        else:\n            error_msg = ''\n            status = res.status\n\n    if error_msg:\n        status = HTTPStatus.error\n\n    counter[status] += 1\n    if verbose and error_msg:\n        print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n我们用futures.as_completed来做thread error handling。\n\n\n```\ndef download_many(cc_list, base_url, verbose, concur_req):\n    counter = collections.Counter()\n    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:\n        to_do_map = {}\n        for cc in sorted(cc_list):\n            future = executor.submit(\n                download_one,\n                cc, base_url, verbose\n            )\n            to_do_map[future] = cc\n\n        done_iter = futures.as_completed(to_do_map)\n\n        if not verbose:\n            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))\n\n        for future in done_iter:\n            try:\n                res = future.result()\n            except requests.exceptions.HTTPError as exc:\n                error_msg = 'HTTP error {res.status_code} - {res.reason}'\n                error_msg = error_msg.format(res=exc.response)\n            except requests.exceptions.ConnectionError as exc:\n                error_msg = 'Connection error'\n            else:\n                error_msg = ''\n                status = res.status\n\n            if error_msg:\n                status = HTTPStatus.error\n\n            counter[status] += 1\n\n            if verbose and error_msg:\n                cc = to_do_map[future]\n                print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n## Blocking I/O and the GIL\n\n\n尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是**并行的**。这是因为CPython解释器中的GIL模式导致的。\n\n**为什么要有GIL呢？**因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程**通常**无法同时使用CPU的多核。\n\n当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。\n\n然而，所有的标准库在等待从OS返回阻塞的I/O结果时，**都可以释放GIL\n！**这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。*Tips: time.sleep()函数也会释放GIL.* \n\n\nProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。\n\n\n## 最后\n感谢阅读。\n\n本文代码地址：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo)\n\n","source":"_posts/Python-concurrency-with-futures.md","raw":"---\ntitle: Python concurrency with futures\ndate: 2017-12-13 11:42:48\ntags: Python\n\n---\n## Preface\n\n当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。\n\n\n## Sequential \n```\nimport os\nimport time\nimport sys\n\nimport requests  # It's not the standard library, so separate it from top with a blank line.\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    resp = requests.get(url)\n    return resp.content\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()  # flush stdout buffter.\n\n\ndef download_many(cc_list):\n    for cc in sorted(cc_list):\n        image = get_flag(cc)\n        show(cc)\n        save_flags(image, cc.lower() + '.gif')\n\n    return len(cc_list)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\n\n\nif __name__ == '__main__':\n    main(download_many)\n\nBD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN \n19 flags download in 21.66s\n```\n\n\n## Concurrent.futures\n\n主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。\n\n```\nfrom concurrent import futures\n\nfrom Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main\n\nMAX_WORKERS = 20\n\ndef download_one(cc):\n    image = get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))\n    with futures.ThreadPoolExecutor(workers) as executor:\n        res = executor.map(download_one, sorted(cc_list))\n\n    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。\n\nif __name__ == '__main__':\n    main(download_many)\n    \nTR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD \n19 flags download in 1.69s\n\n```\n1. 在上下文管理器中，executor的__exit__方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。\n2. 注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。\n\n\n看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？\n\n* future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。\n* 它是Future class的实例，表示已经结束或者还未结束的计算的延时。\n* Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。\n* 虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。\n* 只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。\n\n\n接下来我们用concurrency.futures.as_completed()修改上面写过的代码。\n\n```\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=3) as executor:\n        to_do = []\n        for cc in sorted(cc_list):\n            future = executor.submit(download_one, cc)\n            to_do.append(future)\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n\n        results = []\n        for future in futures.as_completed(to_do):\n            res = future.result()\n            msg = '{} result: {!r}'\n            print(msg.format(future, res))\n            results.append(res)\n\n    return len(results)\n\nScheduled for BR: <Future at 0x1020f2080 state=running>\nScheduled for CN: <Future at 0x1020f27f0 state=running>\nScheduled for ID: <Future at 0x1020f27b8 state=running>\nScheduled for IN: <Future at 0x1020fe320 state=pending>\nScheduled for US: <Future at 0x1020fe3c8 state=pending>\nBR <Future at 0x1020f2080 state=finished returned str> result: 'BR'\nID <Future at 0x1020f27b8 state=finished returned str> result: 'ID'\nIN <Future at 0x1020fe320 state=finished returned str> result: 'IN'\nUS <Future at 0x1020fe3c8 state=finished returned str> result: 'US'\nCN <Future at 0x1020f27f0 state=finished returned str> result: 'CN'\n\n5 flags download in 3.39s\n```\n\nexecutor.submit(download_one, cc)安排download _one被执行，它会返回future。\n注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。\n\n\n\n##### Experimenting with Executor.map\n\n```\nfrom time import sleep, strftime\nfrom concurrent import futures\n\n\ndef display(*args):\n    print(strftime('[%H:%M:%S]'), end=' ')\n    print(*args)\n\n\ndef loiter(n):\n    msg = '{}loiter({}): doing nothing for {}s...'\n    display(msg.format('\\t' * n, n, n))\n    sleep(n)\n    msg = '{}loiter({}): done'\n    display(msg.format('\\t' * n, n))\n    return n * 10\n\n\ndef main():\n    display('Script starting.')\n    executor = futures.ThreadPoolExecutor(max_workers=3)\n    results = executor.map(loiter, range(5))\n    display('results:', results)\n    display('Wating for individual results:')\n    for i, result in enumerate(results):\n        display('result {}: {}'.format(i, result))\nif __name__ == '__main__':\n    main()\n[10:08:03] Script starting.\n[10:08:03] loiter(0): doing nothing for 0s...\n[10:08:03] loiter(0): done\n[10:08:03] \tloiter(1): doing nothing for 1s...\n[10:08:03] \t\tloiter(2): doing nothing for 2s...\n[10:08:03] results: <generator object Executor.map.<locals>.result_iterator at 0x10d6ef468>\n[10:08:03] Wating for individual results:\n[10:08:03] result 0: 0\n[10:08:03] \t\t\tloiter(3): doing nothing for 3s...\n[10:08:04] \tloiter(1): done\n[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...\n[10:08:04] result 1: 10\n[10:08:05] \t\tloiter(2): done\n[10:08:05] result 2: 20\n[10:08:06] \t\t\tloiter(3): done\n[10:08:06] result 3: 30\n[10:08:08] \t\t\t\tloiter(4): done\n[10:08:08] result 4: 40\n注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。\n```\n\n推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。\n\n这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。\n\n\n## Downloads with progress display and error handing\n\n我们先介绍python中一个有趣的库**tqdm**，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。\n\n```\nimport time\nfrom tqdm import tqdm\n    for i in tqdm(range(100)):\n        time.sleep(0.1)\n100%|██████████| 100/100 [00:10<00:00,  9.70it/s]\n```\n\n先看sequentially download\n\n```\n\ndef get_flag(base_url, cc):\n    url = '{}/{cc}/{cc}.gif'.format(base_url, cc=cc.lower())\n    resp = requests.get(url)\n    if resp.status_code != 200:\n        resp.raise_for_status()\n    return resp.content\n\n\ndef download_one(cc, base_url, verbose=False):\n    try:\n        image = get_flag(base_url, cc)\n    except requests.exceptions.HTTPError as exc:\n        res = exc.response\n        if res.status_code == 404:\n            status = HTTPStatus.NOT_FOUND\n            msg = 'not found'\n        else:\n            raise\n\n    else:\n        save_flags(image, cc.lower() + '.gif')\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose:\n        print(cc, msg)\n\n    return Result(status, cc)\n\n\ndef download_many(cc_list, base_url, verbose, max_req):\n    counter = Counter()\n    cc_iter = sorted(cc_list)\n    if not verbose:\n        cc_iter = tqdm(cc_iter)\n    for cc in cc_iter:\n        try:\n            res = download_one(cc, base_url, verbose)\n        except requests.exceptions.HTTPError as exc:\n            error_msg = 'HTTP error {res.status_code} - {res.reason}'\n            error_msg = error_msg.format(res=exc.response)\n        except requests.exceptions.ConnectionError as exc:\n            error_msg = 'Connection error'\n        else:\n            error_msg = ''\n            status = res.status\n\n    if error_msg:\n        status = HTTPStatus.error\n\n    counter[status] += 1\n    if verbose and error_msg:\n        print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n我们用futures.as_completed来做thread error handling。\n\n\n```\ndef download_many(cc_list, base_url, verbose, concur_req):\n    counter = collections.Counter()\n    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:\n        to_do_map = {}\n        for cc in sorted(cc_list):\n            future = executor.submit(\n                download_one,\n                cc, base_url, verbose\n            )\n            to_do_map[future] = cc\n\n        done_iter = futures.as_completed(to_do_map)\n\n        if not verbose:\n            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))\n\n        for future in done_iter:\n            try:\n                res = future.result()\n            except requests.exceptions.HTTPError as exc:\n                error_msg = 'HTTP error {res.status_code} - {res.reason}'\n                error_msg = error_msg.format(res=exc.response)\n            except requests.exceptions.ConnectionError as exc:\n                error_msg = 'Connection error'\n            else:\n                error_msg = ''\n                status = res.status\n\n            if error_msg:\n                status = HTTPStatus.error\n\n            counter[status] += 1\n\n            if verbose and error_msg:\n                cc = to_do_map[future]\n                print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n## Blocking I/O and the GIL\n\n\n尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是**并行的**。这是因为CPython解释器中的GIL模式导致的。\n\n**为什么要有GIL呢？**因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程**通常**无法同时使用CPU的多核。\n\n当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。\n\n然而，所有的标准库在等待从OS返回阻塞的I/O结果时，**都可以释放GIL\n！**这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。*Tips: time.sleep()函数也会释放GIL.* \n\n\nProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。\n\n\n## 最后\n感谢阅读。\n\n本文代码地址：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo)\n\n","slug":"Python-concurrency-with-futures","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwks0020vmvvhf1l60to","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。</p>\n<h2 id=\"Sequential\"><a href=\"#Sequential\" class=\"headerlink\" title=\"Sequential\"></a>Sequential</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\">import time</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">import requests  # It&apos;s not the standard library, so separate it from top with a blank line.</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\"></div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()  # flush stdout buffter.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    for cc in sorted(cc_list):</div><div class=\"line\">        image = get_flag(cc)</div><div class=\"line\">        show(cc)</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\"></div><div class=\"line\">    return len(cc_list)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\"></div><div class=\"line\">BD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN </div><div class=\"line\">19 flags download in 21.66s</div></pre></td></tr></table></figure>\n<h2 id=\"Concurrent-futures\"><a href=\"#Concurrent-futures\" class=\"headerlink\" title=\"Concurrent.futures\"></a>Concurrent.futures</h2><p>主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main</div><div class=\"line\"></div><div class=\"line\">MAX_WORKERS = 20</div><div class=\"line\"></div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    workers = min(MAX_WORKERS, len(cc_list))</div><div class=\"line\">    with futures.ThreadPoolExecutor(workers) as executor:</div><div class=\"line\">        res = executor.map(download_one, sorted(cc_list))</div><div class=\"line\"></div><div class=\"line\">    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\">    </div><div class=\"line\">TR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD </div><div class=\"line\">19 flags download in 1.69s</div></pre></td></tr></table></figure>\n<ol>\n<li>在上下文管理器中，executor的<strong>exit</strong>方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。</li>\n<li>注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。</li>\n</ol>\n<p>看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？</p>\n<ul>\n<li>future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。</li>\n<li>它是Future class的实例，表示已经结束或者还未结束的计算的延时。</li>\n<li>Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。</li>\n<li>虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。</li>\n<li>只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。</li>\n</ul>\n<p>接下来我们用concurrency.futures.as_completed()修改上面写过的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    cc_list = cc_list[:5]</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=3) as executor:</div><div class=\"line\">        to_do = []</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(download_one, cc)</div><div class=\"line\">            to_do.append(future)</div><div class=\"line\">            msg = &apos;Scheduled for &#123;&#125;: &#123;&#125;&apos;</div><div class=\"line\">            print(msg.format(cc, future))</div><div class=\"line\"></div><div class=\"line\">        results = []</div><div class=\"line\">        for future in futures.as_completed(to_do):</div><div class=\"line\">            res = future.result()</div><div class=\"line\">            msg = &apos;&#123;&#125; result: &#123;!r&#125;&apos;</div><div class=\"line\">            print(msg.format(future, res))</div><div class=\"line\">            results.append(res)</div><div class=\"line\"></div><div class=\"line\">    return len(results)</div><div class=\"line\"></div><div class=\"line\">Scheduled for BR: &lt;Future at 0x1020f2080 state=running&gt;</div><div class=\"line\">Scheduled for CN: &lt;Future at 0x1020f27f0 state=running&gt;</div><div class=\"line\">Scheduled for ID: &lt;Future at 0x1020f27b8 state=running&gt;</div><div class=\"line\">Scheduled for IN: &lt;Future at 0x1020fe320 state=pending&gt;</div><div class=\"line\">Scheduled for US: &lt;Future at 0x1020fe3c8 state=pending&gt;</div><div class=\"line\">BR &lt;Future at 0x1020f2080 state=finished returned str&gt; result: &apos;BR&apos;</div><div class=\"line\">ID &lt;Future at 0x1020f27b8 state=finished returned str&gt; result: &apos;ID&apos;</div><div class=\"line\">IN &lt;Future at 0x1020fe320 state=finished returned str&gt; result: &apos;IN&apos;</div><div class=\"line\">US &lt;Future at 0x1020fe3c8 state=finished returned str&gt; result: &apos;US&apos;</div><div class=\"line\">CN &lt;Future at 0x1020f27f0 state=finished returned str&gt; result: &apos;CN&apos;</div><div class=\"line\"></div><div class=\"line\">5 flags download in 3.39s</div></pre></td></tr></table></figure>\n<p>executor.submit(download_one, cc)安排download _one被执行，它会返回future。<br>注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。</p>\n<h5 id=\"Experimenting-with-Executor-map\"><a href=\"#Experimenting-with-Executor-map\" class=\"headerlink\" title=\"Experimenting with Executor.map\"></a>Experimenting with Executor.map</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">from time import sleep, strftime</div><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def display(*args):</div><div class=\"line\">    print(strftime(&apos;[%H:%M:%S]&apos;), end=&apos; &apos;)</div><div class=\"line\">    print(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def loiter(n):</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n, n))</div><div class=\"line\">    sleep(n)</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): done&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n))</div><div class=\"line\">    return n * 10</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    display(&apos;Script starting.&apos;)</div><div class=\"line\">    executor = futures.ThreadPoolExecutor(max_workers=3)</div><div class=\"line\">    results = executor.map(loiter, range(5))</div><div class=\"line\">    display(&apos;results:&apos;, results)</div><div class=\"line\">    display(&apos;Wating for individual results:&apos;)</div><div class=\"line\">    for i, result in enumerate(results):</div><div class=\"line\">        display(&apos;result &#123;&#125;: &#123;&#125;&apos;.format(i, result))</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">[10:08:03] Script starting.</div><div class=\"line\">[10:08:03] loiter(0): doing nothing for 0s...</div><div class=\"line\">[10:08:03] loiter(0): done</div><div class=\"line\">[10:08:03] \tloiter(1): doing nothing for 1s...</div><div class=\"line\">[10:08:03] \t\tloiter(2): doing nothing for 2s...</div><div class=\"line\">[10:08:03] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d6ef468&gt;</div><div class=\"line\">[10:08:03] Wating for individual results:</div><div class=\"line\">[10:08:03] result 0: 0</div><div class=\"line\">[10:08:03] \t\t\tloiter(3): doing nothing for 3s...</div><div class=\"line\">[10:08:04] \tloiter(1): done</div><div class=\"line\">[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...</div><div class=\"line\">[10:08:04] result 1: 10</div><div class=\"line\">[10:08:05] \t\tloiter(2): done</div><div class=\"line\">[10:08:05] result 2: 20</div><div class=\"line\">[10:08:06] \t\t\tloiter(3): done</div><div class=\"line\">[10:08:06] result 3: 30</div><div class=\"line\">[10:08:08] \t\t\t\tloiter(4): done</div><div class=\"line\">[10:08:08] result 4: 40</div><div class=\"line\">注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。</div></pre></td></tr></table></figure>\n<p>推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。</p>\n<p>这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。</p>\n<h2 id=\"Downloads-with-progress-display-and-error-handing\"><a href=\"#Downloads-with-progress-display-and-error-handing\" class=\"headerlink\" title=\"Downloads with progress display and error handing\"></a>Downloads with progress display and error handing</h2><p>我们先介绍python中一个有趣的库<strong>tqdm</strong>，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\">from tqdm import tqdm</div><div class=\"line\">    for i in tqdm(range(100)):</div><div class=\"line\">        time.sleep(0.1)</div><div class=\"line\">100%|██████████| 100/100 [00:10&lt;00:00,  9.70it/s]</div></pre></td></tr></table></figure>\n<p>先看sequentially download</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def get_flag(base_url, cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(base_url, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    if resp.status_code != 200:</div><div class=\"line\">        resp.raise_for_status()</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_one(cc, base_url, verbose=False):</div><div class=\"line\">    try:</div><div class=\"line\">        image = get_flag(base_url, cc)</div><div class=\"line\">    except requests.exceptions.HTTPError as exc:</div><div class=\"line\">        res = exc.response</div><div class=\"line\">        if res.status_code == 404:</div><div class=\"line\">            status = HTTPStatus.NOT_FOUND</div><div class=\"line\">            msg = &apos;not found&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            raise</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list, base_url, verbose, max_req):</div><div class=\"line\">    counter = Counter()</div><div class=\"line\">    cc_iter = sorted(cc_list)</div><div class=\"line\">    if not verbose:</div><div class=\"line\">        cc_iter = tqdm(cc_iter)</div><div class=\"line\">    for cc in cc_iter:</div><div class=\"line\">        try:</div><div class=\"line\">            res = download_one(cc, base_url, verbose)</div><div class=\"line\">        except requests.exceptions.HTTPError as exc:</div><div class=\"line\">            error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">            error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">        except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">            error_msg = &apos;Connection error&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            error_msg = &apos;&apos;</div><div class=\"line\">            status = res.status</div><div class=\"line\"></div><div class=\"line\">    if error_msg:</div><div class=\"line\">        status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">    counter[status] += 1</div><div class=\"line\">    if verbose and error_msg:</div><div class=\"line\">        print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<p>我们用futures.as_completed来做thread error handling。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list, base_url, verbose, concur_req):</div><div class=\"line\">    counter = collections.Counter()</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:</div><div class=\"line\">        to_do_map = &#123;&#125;</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(</div><div class=\"line\">                download_one,</div><div class=\"line\">                cc, base_url, verbose</div><div class=\"line\">            )</div><div class=\"line\">            to_do_map[future] = cc</div><div class=\"line\"></div><div class=\"line\">        done_iter = futures.as_completed(to_do_map)</div><div class=\"line\"></div><div class=\"line\">        if not verbose:</div><div class=\"line\">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</div><div class=\"line\"></div><div class=\"line\">        for future in done_iter:</div><div class=\"line\">            try:</div><div class=\"line\">                res = future.result()</div><div class=\"line\">            except requests.exceptions.HTTPError as exc:</div><div class=\"line\">                error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">                error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">            except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">                error_msg = &apos;Connection error&apos;</div><div class=\"line\">            else:</div><div class=\"line\">                error_msg = &apos;&apos;</div><div class=\"line\">                status = res.status</div><div class=\"line\"></div><div class=\"line\">            if error_msg:</div><div class=\"line\">                status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">            counter[status] += 1</div><div class=\"line\"></div><div class=\"line\">            if verbose and error_msg:</div><div class=\"line\">                cc = to_do_map[future]</div><div class=\"line\">                print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<h2 id=\"Blocking-I-O-and-the-GIL\"><a href=\"#Blocking-I-O-and-the-GIL\" class=\"headerlink\" title=\"Blocking I/O and the GIL\"></a>Blocking I/O and the GIL</h2><p>尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是<strong>并行的</strong>。这是因为CPython解释器中的GIL模式导致的。</p>\n<p><strong>为什么要有GIL呢？</strong>因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程<strong>通常</strong>无法同时使用CPU的多核。</p>\n<p>当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。</p>\n<p>然而，所有的标准库在等待从OS返回阻塞的I/O结果时，<strong>都可以释放GIL<br>！</strong>这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。<em>Tips: time.sleep()函数也会释放GIL.</em> </p>\n<p>ProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>感谢阅读。</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。</p>\n<h2 id=\"Sequential\"><a href=\"#Sequential\" class=\"headerlink\" title=\"Sequential\"></a>Sequential</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\">import time</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">import requests  # It&apos;s not the standard library, so separate it from top with a blank line.</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\"></div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()  # flush stdout buffter.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    for cc in sorted(cc_list):</div><div class=\"line\">        image = get_flag(cc)</div><div class=\"line\">        show(cc)</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\"></div><div class=\"line\">    return len(cc_list)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\"></div><div class=\"line\">BD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN </div><div class=\"line\">19 flags download in 21.66s</div></pre></td></tr></table></figure>\n<h2 id=\"Concurrent-futures\"><a href=\"#Concurrent-futures\" class=\"headerlink\" title=\"Concurrent.futures\"></a>Concurrent.futures</h2><p>主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main</div><div class=\"line\"></div><div class=\"line\">MAX_WORKERS = 20</div><div class=\"line\"></div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    workers = min(MAX_WORKERS, len(cc_list))</div><div class=\"line\">    with futures.ThreadPoolExecutor(workers) as executor:</div><div class=\"line\">        res = executor.map(download_one, sorted(cc_list))</div><div class=\"line\"></div><div class=\"line\">    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\">    </div><div class=\"line\">TR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD </div><div class=\"line\">19 flags download in 1.69s</div></pre></td></tr></table></figure>\n<ol>\n<li>在上下文管理器中，executor的<strong>exit</strong>方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。</li>\n<li>注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。</li>\n</ol>\n<p>看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？</p>\n<ul>\n<li>future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。</li>\n<li>它是Future class的实例，表示已经结束或者还未结束的计算的延时。</li>\n<li>Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。</li>\n<li>虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。</li>\n<li>只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。</li>\n</ul>\n<p>接下来我们用concurrency.futures.as_completed()修改上面写过的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    cc_list = cc_list[:5]</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=3) as executor:</div><div class=\"line\">        to_do = []</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(download_one, cc)</div><div class=\"line\">            to_do.append(future)</div><div class=\"line\">            msg = &apos;Scheduled for &#123;&#125;: &#123;&#125;&apos;</div><div class=\"line\">            print(msg.format(cc, future))</div><div class=\"line\"></div><div class=\"line\">        results = []</div><div class=\"line\">        for future in futures.as_completed(to_do):</div><div class=\"line\">            res = future.result()</div><div class=\"line\">            msg = &apos;&#123;&#125; result: &#123;!r&#125;&apos;</div><div class=\"line\">            print(msg.format(future, res))</div><div class=\"line\">            results.append(res)</div><div class=\"line\"></div><div class=\"line\">    return len(results)</div><div class=\"line\"></div><div class=\"line\">Scheduled for BR: &lt;Future at 0x1020f2080 state=running&gt;</div><div class=\"line\">Scheduled for CN: &lt;Future at 0x1020f27f0 state=running&gt;</div><div class=\"line\">Scheduled for ID: &lt;Future at 0x1020f27b8 state=running&gt;</div><div class=\"line\">Scheduled for IN: &lt;Future at 0x1020fe320 state=pending&gt;</div><div class=\"line\">Scheduled for US: &lt;Future at 0x1020fe3c8 state=pending&gt;</div><div class=\"line\">BR &lt;Future at 0x1020f2080 state=finished returned str&gt; result: &apos;BR&apos;</div><div class=\"line\">ID &lt;Future at 0x1020f27b8 state=finished returned str&gt; result: &apos;ID&apos;</div><div class=\"line\">IN &lt;Future at 0x1020fe320 state=finished returned str&gt; result: &apos;IN&apos;</div><div class=\"line\">US &lt;Future at 0x1020fe3c8 state=finished returned str&gt; result: &apos;US&apos;</div><div class=\"line\">CN &lt;Future at 0x1020f27f0 state=finished returned str&gt; result: &apos;CN&apos;</div><div class=\"line\"></div><div class=\"line\">5 flags download in 3.39s</div></pre></td></tr></table></figure>\n<p>executor.submit(download_one, cc)安排download _one被执行，它会返回future。<br>注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。</p>\n<h5 id=\"Experimenting-with-Executor-map\"><a href=\"#Experimenting-with-Executor-map\" class=\"headerlink\" title=\"Experimenting with Executor.map\"></a>Experimenting with Executor.map</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">from time import sleep, strftime</div><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def display(*args):</div><div class=\"line\">    print(strftime(&apos;[%H:%M:%S]&apos;), end=&apos; &apos;)</div><div class=\"line\">    print(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def loiter(n):</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n, n))</div><div class=\"line\">    sleep(n)</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): done&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n))</div><div class=\"line\">    return n * 10</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    display(&apos;Script starting.&apos;)</div><div class=\"line\">    executor = futures.ThreadPoolExecutor(max_workers=3)</div><div class=\"line\">    results = executor.map(loiter, range(5))</div><div class=\"line\">    display(&apos;results:&apos;, results)</div><div class=\"line\">    display(&apos;Wating for individual results:&apos;)</div><div class=\"line\">    for i, result in enumerate(results):</div><div class=\"line\">        display(&apos;result &#123;&#125;: &#123;&#125;&apos;.format(i, result))</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">[10:08:03] Script starting.</div><div class=\"line\">[10:08:03] loiter(0): doing nothing for 0s...</div><div class=\"line\">[10:08:03] loiter(0): done</div><div class=\"line\">[10:08:03] \tloiter(1): doing nothing for 1s...</div><div class=\"line\">[10:08:03] \t\tloiter(2): doing nothing for 2s...</div><div class=\"line\">[10:08:03] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d6ef468&gt;</div><div class=\"line\">[10:08:03] Wating for individual results:</div><div class=\"line\">[10:08:03] result 0: 0</div><div class=\"line\">[10:08:03] \t\t\tloiter(3): doing nothing for 3s...</div><div class=\"line\">[10:08:04] \tloiter(1): done</div><div class=\"line\">[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...</div><div class=\"line\">[10:08:04] result 1: 10</div><div class=\"line\">[10:08:05] \t\tloiter(2): done</div><div class=\"line\">[10:08:05] result 2: 20</div><div class=\"line\">[10:08:06] \t\t\tloiter(3): done</div><div class=\"line\">[10:08:06] result 3: 30</div><div class=\"line\">[10:08:08] \t\t\t\tloiter(4): done</div><div class=\"line\">[10:08:08] result 4: 40</div><div class=\"line\">注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。</div></pre></td></tr></table></figure>\n<p>推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。</p>\n<p>这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。</p>\n<h2 id=\"Downloads-with-progress-display-and-error-handing\"><a href=\"#Downloads-with-progress-display-and-error-handing\" class=\"headerlink\" title=\"Downloads with progress display and error handing\"></a>Downloads with progress display and error handing</h2><p>我们先介绍python中一个有趣的库<strong>tqdm</strong>，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\">from tqdm import tqdm</div><div class=\"line\">    for i in tqdm(range(100)):</div><div class=\"line\">        time.sleep(0.1)</div><div class=\"line\">100%|██████████| 100/100 [00:10&lt;00:00,  9.70it/s]</div></pre></td></tr></table></figure>\n<p>先看sequentially download</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def get_flag(base_url, cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(base_url, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    if resp.status_code != 200:</div><div class=\"line\">        resp.raise_for_status()</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_one(cc, base_url, verbose=False):</div><div class=\"line\">    try:</div><div class=\"line\">        image = get_flag(base_url, cc)</div><div class=\"line\">    except requests.exceptions.HTTPError as exc:</div><div class=\"line\">        res = exc.response</div><div class=\"line\">        if res.status_code == 404:</div><div class=\"line\">            status = HTTPStatus.NOT_FOUND</div><div class=\"line\">            msg = &apos;not found&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            raise</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list, base_url, verbose, max_req):</div><div class=\"line\">    counter = Counter()</div><div class=\"line\">    cc_iter = sorted(cc_list)</div><div class=\"line\">    if not verbose:</div><div class=\"line\">        cc_iter = tqdm(cc_iter)</div><div class=\"line\">    for cc in cc_iter:</div><div class=\"line\">        try:</div><div class=\"line\">            res = download_one(cc, base_url, verbose)</div><div class=\"line\">        except requests.exceptions.HTTPError as exc:</div><div class=\"line\">            error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">            error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">        except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">            error_msg = &apos;Connection error&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            error_msg = &apos;&apos;</div><div class=\"line\">            status = res.status</div><div class=\"line\"></div><div class=\"line\">    if error_msg:</div><div class=\"line\">        status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">    counter[status] += 1</div><div class=\"line\">    if verbose and error_msg:</div><div class=\"line\">        print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<p>我们用futures.as_completed来做thread error handling。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list, base_url, verbose, concur_req):</div><div class=\"line\">    counter = collections.Counter()</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:</div><div class=\"line\">        to_do_map = &#123;&#125;</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(</div><div class=\"line\">                download_one,</div><div class=\"line\">                cc, base_url, verbose</div><div class=\"line\">            )</div><div class=\"line\">            to_do_map[future] = cc</div><div class=\"line\"></div><div class=\"line\">        done_iter = futures.as_completed(to_do_map)</div><div class=\"line\"></div><div class=\"line\">        if not verbose:</div><div class=\"line\">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</div><div class=\"line\"></div><div class=\"line\">        for future in done_iter:</div><div class=\"line\">            try:</div><div class=\"line\">                res = future.result()</div><div class=\"line\">            except requests.exceptions.HTTPError as exc:</div><div class=\"line\">                error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">                error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">            except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">                error_msg = &apos;Connection error&apos;</div><div class=\"line\">            else:</div><div class=\"line\">                error_msg = &apos;&apos;</div><div class=\"line\">                status = res.status</div><div class=\"line\"></div><div class=\"line\">            if error_msg:</div><div class=\"line\">                status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">            counter[status] += 1</div><div class=\"line\"></div><div class=\"line\">            if verbose and error_msg:</div><div class=\"line\">                cc = to_do_map[future]</div><div class=\"line\">                print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<h2 id=\"Blocking-I-O-and-the-GIL\"><a href=\"#Blocking-I-O-and-the-GIL\" class=\"headerlink\" title=\"Blocking I/O and the GIL\"></a>Blocking I/O and the GIL</h2><p>尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是<strong>并行的</strong>。这是因为CPython解释器中的GIL模式导致的。</p>\n<p><strong>为什么要有GIL呢？</strong>因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程<strong>通常</strong>无法同时使用CPU的多核。</p>\n<p>当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。</p>\n<p>然而，所有的标准库在等待从OS返回阻塞的I/O结果时，<strong>都可以释放GIL<br>！</strong>这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。<em>Tips: time.sleep()函数也会释放GIL.</em> </p>\n<p>ProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>感谢阅读。</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo</a></p>\n"},{"title":"Python内置模块bisect介绍","date":"2017-11-20T06:33:07.000Z","_content":"\n\n\n在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的**bisect**模块.\t\n\n## 介绍\n\n对于bisect，官网的解释是：\n\nThis module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。\n\n## 模块内提供的函数\n\n#### 查找：\n\n`bisect.bisect_left(a, x, lo=0, hi=len(a))`\n\na是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使`all(val < x for val in a[lo:i])` 在左侧， `all(val >= x for val in a[i:hi])` 在右侧。返回值为可插入的第一个位置(有相同的item).\n\n`bisect.bisect_right(a, x, lo=0, hi=len(a))`\n\n`bisect.bisect(a, x, lo=0, hi=len(a))`\n\n这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即`all(val <= x for val in a[lo:i])` 在左侧 `all(val > x for val in a[i:hi])` 在右侧。\n\n#### 插入：\n`bisect.insort_left(a, x, lo=0, hi=len(a))`\n\n函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).\n\n`bisect.insort_right(a, x, lo=0, hi=len(a))`\n\n`bisect.insort(a, x, lo=0, hi=len(a))`\n\n\n## 事例讲解\n用一个排序后的lists查找案例来练习一下吧。\n\n```\ndef index(a, x):\n    'Locate the leftmost value exactly equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n\ndef find_lt(a, x):\n    'Find rightmost value less than x'\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_le(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect.bisect_right(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bisect.bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n\n\ndef find_ge(a, x):\n    'Find leftmost item greater than or equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n```\n\n\n## 进入正题\n\n最后leetcode的题目是：\n\nImplement a MyCalendar class to store your events.\nA new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end).\nFormally, this represents a booking on the half open interval [start, end),\nthe range of real numbers x such that start <= x < end.\nA double booking happens when two events have some non-empty intersection\n(ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book,\nreturn true if the event can be added to the calendar successfully without causing a double booking. Otherwise,\nreturn false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n\n代码：\n\n```\nimport bisect\n\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.calendar = []\n        self._start_sorted = []\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        if not self.calendar:\n            self.calendar += (start, end),\n            self._start_sorted += start,\n            return True\n        floor_index = bisect.bisect_left(self._start_sorted, start)\n        if floor_index and self.calendar[floor_index - 1][1] > start:\n                return False\n\n        ceiling_index = bisect.bisect_right(self._start_sorted, start)\n        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] < end:\n                return False\n        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] < end:\n                return False\n\n        self.calendar.insert(floor_index, (start, end))\n        self._start_sorted.insert(floor_index, start)\n        return True\n```\n\n## 最后\n详细的代码和用例：\n[https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py](https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py)\n\n\n","source":"_posts/Python内置模块bisect介绍.md","raw":"---\ntitle: Python内置模块bisect介绍\ndate: 2017-11-20 14:33:07\ntags: Python\n---\n\n\n\n在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的**bisect**模块.\t\n\n## 介绍\n\n对于bisect，官网的解释是：\n\nThis module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。\n\n## 模块内提供的函数\n\n#### 查找：\n\n`bisect.bisect_left(a, x, lo=0, hi=len(a))`\n\na是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使`all(val < x for val in a[lo:i])` 在左侧， `all(val >= x for val in a[i:hi])` 在右侧。返回值为可插入的第一个位置(有相同的item).\n\n`bisect.bisect_right(a, x, lo=0, hi=len(a))`\n\n`bisect.bisect(a, x, lo=0, hi=len(a))`\n\n这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即`all(val <= x for val in a[lo:i])` 在左侧 `all(val > x for val in a[i:hi])` 在右侧。\n\n#### 插入：\n`bisect.insort_left(a, x, lo=0, hi=len(a))`\n\n函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).\n\n`bisect.insort_right(a, x, lo=0, hi=len(a))`\n\n`bisect.insort(a, x, lo=0, hi=len(a))`\n\n\n## 事例讲解\n用一个排序后的lists查找案例来练习一下吧。\n\n```\ndef index(a, x):\n    'Locate the leftmost value exactly equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n\ndef find_lt(a, x):\n    'Find rightmost value less than x'\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_le(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect.bisect_right(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bisect.bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n\n\ndef find_ge(a, x):\n    'Find leftmost item greater than or equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n```\n\n\n## 进入正题\n\n最后leetcode的题目是：\n\nImplement a MyCalendar class to store your events.\nA new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end).\nFormally, this represents a booking on the half open interval [start, end),\nthe range of real numbers x such that start <= x < end.\nA double booking happens when two events have some non-empty intersection\n(ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book,\nreturn true if the event can be added to the calendar successfully without causing a double booking. Otherwise,\nreturn false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n\n代码：\n\n```\nimport bisect\n\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.calendar = []\n        self._start_sorted = []\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        if not self.calendar:\n            self.calendar += (start, end),\n            self._start_sorted += start,\n            return True\n        floor_index = bisect.bisect_left(self._start_sorted, start)\n        if floor_index and self.calendar[floor_index - 1][1] > start:\n                return False\n\n        ceiling_index = bisect.bisect_right(self._start_sorted, start)\n        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] < end:\n                return False\n        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] < end:\n                return False\n\n        self.calendar.insert(floor_index, (start, end))\n        self._start_sorted.insert(floor_index, start)\n        return True\n```\n\n## 最后\n详细的代码和用例：\n[https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py](https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py)\n\n\n","slug":"Python内置模块bisect介绍","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkt0022vmvvrtfexemn","content":"<p>在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的<strong>bisect</strong>模块.    </p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于bisect，官网的解释是：</p>\n<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>\n<p>大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。</p>\n<h2 id=\"模块内提供的函数\"><a href=\"#模块内提供的函数\" class=\"headerlink\" title=\"模块内提供的函数\"></a>模块内提供的函数</h2><h4 id=\"查找：\"><a href=\"#查找：\" class=\"headerlink\" title=\"查找：\"></a>查找：</h4><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></p>\n<p>a是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使<code>all(val &lt; x for val in a[lo:i])</code> 在左侧， <code>all(val &gt;= x for val in a[i:hi])</code> 在右侧。返回值为可插入的第一个位置(有相同的item).</p>\n<p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></p>\n<p>这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即<code>all(val &lt;= x for val in a[lo:i])</code> 在左侧 <code>all(val &gt; x for val in a[i:hi])</code> 在右侧。</p>\n<h4 id=\"插入：\"><a href=\"#插入：\" class=\"headerlink\" title=\"插入：\"></a>插入：</h4><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></p>\n<p>函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).</p>\n<p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.insort(a, x, lo=0, hi=len(a))</code></p>\n<h2 id=\"事例讲解\"><a href=\"#事例讲解\" class=\"headerlink\" title=\"事例讲解\"></a>事例讲解</h2><p>用一个排序后的lists查找案例来练习一下吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def index(a, x):</div><div class=\"line\">    &apos;Locate the leftmost value exactly equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a) and a[i] == x:</div><div class=\"line\">        return i</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_lt(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_le(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_gt(a, x):</div><div class=\"line\">    &apos;Find leftmost value greater than x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_ge(a, x):</div><div class=\"line\">    &apos;Find leftmost item greater than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div></pre></td></tr></table></figure>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><p>最后leetcode的题目是：</p>\n<p>Implement a MyCalendar class to store your events.<br>A new event can be added if adding the event will not cause a double booking.<br>Your class will have the method, book(int start, int end).<br>Formally, this represents a booking on the half open interval [start, end),<br>the range of real numbers x such that start &lt;= x &lt; end.<br>A double booking happens when two events have some non-empty intersection<br>(ie., there is some time that is common to both events.)<br>For each call to the method MyCalendar.book,<br>return true if the event can be added to the calendar successfully without causing a double booking. Otherwise,<br>return false and do not add the event to the calendar.<br>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">import bisect</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class MyCalendar(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        self.calendar = []</div><div class=\"line\">        self._start_sorted = []</div><div class=\"line\"></div><div class=\"line\">    def book(self, start, end):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type start: int</div><div class=\"line\">        :type end: int</div><div class=\"line\">        :rtype: bool</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        if not self.calendar:</div><div class=\"line\">            self.calendar += (start, end),</div><div class=\"line\">            self._start_sorted += start,</div><div class=\"line\">            return True</div><div class=\"line\">        floor_index = bisect.bisect_left(self._start_sorted, start)</div><div class=\"line\">        if floor_index and self.calendar[floor_index - 1][1] &gt; start:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        ceiling_index = bisect.bisect_right(self._start_sorted, start)</div><div class=\"line\">        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\">        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        self.calendar.insert(floor_index, (start, end))</div><div class=\"line\">        self._start_sorted.insert(floor_index, start)</div><div class=\"line\">        return True</div></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>详细的代码和用例：<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的<strong>bisect</strong>模块.    </p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于bisect，官网的解释是：</p>\n<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>\n<p>大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。</p>\n<h2 id=\"模块内提供的函数\"><a href=\"#模块内提供的函数\" class=\"headerlink\" title=\"模块内提供的函数\"></a>模块内提供的函数</h2><h4 id=\"查找：\"><a href=\"#查找：\" class=\"headerlink\" title=\"查找：\"></a>查找：</h4><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></p>\n<p>a是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使<code>all(val &lt; x for val in a[lo:i])</code> 在左侧， <code>all(val &gt;= x for val in a[i:hi])</code> 在右侧。返回值为可插入的第一个位置(有相同的item).</p>\n<p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></p>\n<p>这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即<code>all(val &lt;= x for val in a[lo:i])</code> 在左侧 <code>all(val &gt; x for val in a[i:hi])</code> 在右侧。</p>\n<h4 id=\"插入：\"><a href=\"#插入：\" class=\"headerlink\" title=\"插入：\"></a>插入：</h4><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></p>\n<p>函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).</p>\n<p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.insort(a, x, lo=0, hi=len(a))</code></p>\n<h2 id=\"事例讲解\"><a href=\"#事例讲解\" class=\"headerlink\" title=\"事例讲解\"></a>事例讲解</h2><p>用一个排序后的lists查找案例来练习一下吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def index(a, x):</div><div class=\"line\">    &apos;Locate the leftmost value exactly equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a) and a[i] == x:</div><div class=\"line\">        return i</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_lt(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_le(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_gt(a, x):</div><div class=\"line\">    &apos;Find leftmost value greater than x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_ge(a, x):</div><div class=\"line\">    &apos;Find leftmost item greater than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div></pre></td></tr></table></figure>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><p>最后leetcode的题目是：</p>\n<p>Implement a MyCalendar class to store your events.<br>A new event can be added if adding the event will not cause a double booking.<br>Your class will have the method, book(int start, int end).<br>Formally, this represents a booking on the half open interval [start, end),<br>the range of real numbers x such that start &lt;= x &lt; end.<br>A double booking happens when two events have some non-empty intersection<br>(ie., there is some time that is common to both events.)<br>For each call to the method MyCalendar.book,<br>return true if the event can be added to the calendar successfully without causing a double booking. Otherwise,<br>return false and do not add the event to the calendar.<br>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">import bisect</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class MyCalendar(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        self.calendar = []</div><div class=\"line\">        self._start_sorted = []</div><div class=\"line\"></div><div class=\"line\">    def book(self, start, end):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type start: int</div><div class=\"line\">        :type end: int</div><div class=\"line\">        :rtype: bool</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        if not self.calendar:</div><div class=\"line\">            self.calendar += (start, end),</div><div class=\"line\">            self._start_sorted += start,</div><div class=\"line\">            return True</div><div class=\"line\">        floor_index = bisect.bisect_left(self._start_sorted, start)</div><div class=\"line\">        if floor_index and self.calendar[floor_index - 1][1] &gt; start:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        ceiling_index = bisect.bisect_right(self._start_sorted, start)</div><div class=\"line\">        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\">        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        self.calendar.insert(floor_index, (start, end))</div><div class=\"line\">        self._start_sorted.insert(floor_index, start)</div><div class=\"line\">        return True</div></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>详细的代码和用例：<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py</a></p>\n"},{"title":"%_and_format()案例解释","date":"2018-01-29T06:11:10.000Z","_content":"## 题记\n因为对python2x和python3x都有使用经历，所以常常对**%**和**.format()**记忆混乱，索性今天在网上参考了几篇案例较多的tutorial,把这两种格式化风格的使用案例做一个归档。\n\n为了后面叙述方便，我们将%定义为旧风格，.format()定义为新风格。\n\n\n## 通用的格式化\n简单的位置格式化应该是最常用的，通常在参数顺序不变的情况下使用。\n\n```\nprint('%s %s' % (one, two)) \nprint('{} {}'.format(one, two))\ninput>>one two\n```\n\n但是对于.format()，可以使用占位符来显式定义参数顺序。\n\n```\n# 这个操作对于%s的格式化操作来说是不可用的.\nprint('{1} {0}'.format(one, two))\ninput>>two one\n```\n\n## 值的转化\n\n.format()函数，调用的是对象的__format__()方法，如果你需要输出str(...)或者repr(...)，你可以使用!s或者!r来转化标记。 \n\n在旧风格中使用%s或者%r来转化。\n\n```\nclass Data:\n    def __str__(self):\n        return 'str'\n\n    def __repr__(self):\n        return 'repr'\n\n\nprint('%s %r' % (Data(), Data()))\nprint('{!s} {!r}'.format(Data(), Data()))\ninput>>str repr\n```\n\n\n## 填充以及校准字符串\n\n默认的格式化值是用给予的值来填充的，然而有时候也需要格式化值达到一个确定的长度。\n\n关于这点，两种风格就显得截然不同了。\n\n```\nprint('%10s' % one)\nprint('{:>10}'.format(one))\n\n# 左校准\nprint('%-10s' % one)\nprint('{:10}'.format(one))\n\ninput>>       one\ninupt>>one       \n```\n\n而新风格，还提供了自定义填充字符。\n\n```\n# 自定义填充字符，下列操作在旧风格中均不可行。\nprint('{:_<10}'.format(one))\nprint('{:^10}'.format(one))  # 居中\nprint('{:^6}'.format('zip'))  # 居中操作中，遇到奇数分割的时候，会将多出来的填充位放在右边。\ninput>>one_______\ninput>>   one    \ninput>> zip  \n```\n\n## 截断长字符串\n\n相对于填充字符串达到固定长度来说，我们也可以截断字符串来达到固定长度。在格式化字符串中.后的数字是表明\u0005截断的长度。\n\n```\nstr_ = 'hello world.'\nprint('%.5s' %(str_))\nprint('{:.5}'.format(str_))\ninput>>hello\n```\n\n## 填充与截断的结合使用\n\n```\nstr_ = 'hello world.'\nprint('%10.5s' % str_)\nprint('{:>10.5}'.format(str_))\ninput>>     hello\n```\n\n## 数字\n\n格式化数字也是常见的。\n\n```\nnumber_integer = 42\nprint('%d' % (number_integer))\nprint('{:d}'.format(number_integer))\ninput>>42\n\nnumber_float = 3.141592653589793\nprint('%f' % number_float)\nprint('{:f}'.format(number_float))\ninput>>3.141593\n```\n\n## 填充数字\n\n```\nnumber_integer = 42\nprint('%4d' % number_integer)\nprint('{:4d}'.format(number_integer))\ninput>>  42\n```\n\n对于浮点数，填充值表示完整的长度。\n\n```\nnumber_float = 3.141592653589793\nprint('%06.2f' % number_float)\nprint('{:06.2f}'.format(number_float))\ninput>>003.14\n```\n\n## 有符号的整数\n\n默认来说，只有负数会有符号。当然，我们可以显式给正数也加上。\n\n```\nnumber_integer = 42\nprint('%+d' % number_integer)\nprint('{:+d}'.format(number_integer))\ninput>>+42\n```\n\n使用空格字符表示负数应该以负号作为前缀，而正数应该使用前导空格。\n\n```\nprint('% d' % (- 23))\nprint('{: d}'.format(- 23))\ninput>>-23\n```\n\n新风格也能给负整数填充。\n\n```\nprint('{:=-5d}'.format(- 23))\nprint('{:=+5d}'.format(23))\ninput>>-  23\ninput>>+  23\n```\n\n## 名称占位符\n\n介绍完了对于数字的操作，接下来介绍一些关于占位符的案例。\n\n```\ndata = {'first': 'Hodor', 'last': 'Hodor!'}\nprint('%(first)s %(last)s' % data)\nprint('{first} {last}'.format(**data))\nprint('{first} {last}'.format(first='Hodor', last='Hodor!'))  # only available with new style formatting.\ninput>>Hodor Hodor!\n```\n\n## Getitem和Getattr\n\n新风格允许对数据结构进行更灵活的操作。\n它可以操作拥有__getitem__方法的对象。\n\n```\nperson = {'first': 'Jean-Luc', 'last': 'Picard'}\nprint('{p[first]} {p[last]}'.format(p=person))\ninput>>Jean-Luc Picard\ndata = [4, 8, 15, 16, 23, 42]\nprint('{d[4]} {d[5]}'.format(d=data))\ninput>>23 42\n```\n\n它也支持操作拥有getattr()属性的对象。\n\n```\nclass Plant(object):\n    type = 'tree'\nprint('{p.type}'.format(p=Plant()))\ninput>>tree\n```\n\n它也支持二者的同时操作。\n\n```\nclass Plant(object):\n    type = 'tree'\n    kinds = [{'name': 'oak'}, {'name': 'maple'}]\nprint('{p.type}: {p.kinds[0][name]}'.format(p=Plant()))\ninput>>tree: oak\n```\n\n## 时间\n\n新风格也允许日期时间对象内联格式化。\n\n```\nfrom datetime import datetime\nprint('{:%Y-%m-%d %H:%M:%S}'.format(datetime.now()))\ninput>>2018-01-29 13:38:40\n```\n\n## 参数格式化\n\n新风格格式化允许使用参数来动态指定。参数化格式是大括号中的嵌套表达式，可以在冒号后的父级格式的任何地方出现。\n\n```\nprint('{:{align}{width}}'.format('test', align='>', width='10'))\ninput>>      test\nprint('{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3))\ninput>>Gib = 2.718\nprint('{:{width}.{prec}f}'.format(2.7182, width=5, prec=2))\ninput>> 2.72\nprint('{:{prec}} = {:{prec}}'.format('Gibberish', 2.7182, prec='.3'))\ninput>>Gib = 2.72\nfrom datetime import datetime\ndt = datetime.now()\nprint('{:{dfmt} {tfmt}}'.format(dt, dfmt='%Y-%m-%d', tfmt='%H:%M'))\ninput>>2018-01-29 13:59\n```\n\n## 参考\n[https://pyformat.info/](https://pyformat.info/)\n\n[https://github.com/ulope/pyformat.info](https://github.com/ulope/pyformat.info)\n## 最后\n\n本文代码连接： [% and .format()](https://github.com/Miksztowi/CorePython/blob/master/format_and_%25_/demo.py)\n\n\n如有纰漏之处，还请您不吝赐教。 \n\nHave fun :)\n","source":"_posts/python格式化的案例解释.md","raw":"---\ntitle: '%_and_format()案例解释'\ndate: 2018-01-29 14:11:10\ntags: Python\n\n---\n## 题记\n因为对python2x和python3x都有使用经历，所以常常对**%**和**.format()**记忆混乱，索性今天在网上参考了几篇案例较多的tutorial,把这两种格式化风格的使用案例做一个归档。\n\n为了后面叙述方便，我们将%定义为旧风格，.format()定义为新风格。\n\n\n## 通用的格式化\n简单的位置格式化应该是最常用的，通常在参数顺序不变的情况下使用。\n\n```\nprint('%s %s' % (one, two)) \nprint('{} {}'.format(one, two))\ninput>>one two\n```\n\n但是对于.format()，可以使用占位符来显式定义参数顺序。\n\n```\n# 这个操作对于%s的格式化操作来说是不可用的.\nprint('{1} {0}'.format(one, two))\ninput>>two one\n```\n\n## 值的转化\n\n.format()函数，调用的是对象的__format__()方法，如果你需要输出str(...)或者repr(...)，你可以使用!s或者!r来转化标记。 \n\n在旧风格中使用%s或者%r来转化。\n\n```\nclass Data:\n    def __str__(self):\n        return 'str'\n\n    def __repr__(self):\n        return 'repr'\n\n\nprint('%s %r' % (Data(), Data()))\nprint('{!s} {!r}'.format(Data(), Data()))\ninput>>str repr\n```\n\n\n## 填充以及校准字符串\n\n默认的格式化值是用给予的值来填充的，然而有时候也需要格式化值达到一个确定的长度。\n\n关于这点，两种风格就显得截然不同了。\n\n```\nprint('%10s' % one)\nprint('{:>10}'.format(one))\n\n# 左校准\nprint('%-10s' % one)\nprint('{:10}'.format(one))\n\ninput>>       one\ninupt>>one       \n```\n\n而新风格，还提供了自定义填充字符。\n\n```\n# 自定义填充字符，下列操作在旧风格中均不可行。\nprint('{:_<10}'.format(one))\nprint('{:^10}'.format(one))  # 居中\nprint('{:^6}'.format('zip'))  # 居中操作中，遇到奇数分割的时候，会将多出来的填充位放在右边。\ninput>>one_______\ninput>>   one    \ninput>> zip  \n```\n\n## 截断长字符串\n\n相对于填充字符串达到固定长度来说，我们也可以截断字符串来达到固定长度。在格式化字符串中.后的数字是表明\u0005截断的长度。\n\n```\nstr_ = 'hello world.'\nprint('%.5s' %(str_))\nprint('{:.5}'.format(str_))\ninput>>hello\n```\n\n## 填充与截断的结合使用\n\n```\nstr_ = 'hello world.'\nprint('%10.5s' % str_)\nprint('{:>10.5}'.format(str_))\ninput>>     hello\n```\n\n## 数字\n\n格式化数字也是常见的。\n\n```\nnumber_integer = 42\nprint('%d' % (number_integer))\nprint('{:d}'.format(number_integer))\ninput>>42\n\nnumber_float = 3.141592653589793\nprint('%f' % number_float)\nprint('{:f}'.format(number_float))\ninput>>3.141593\n```\n\n## 填充数字\n\n```\nnumber_integer = 42\nprint('%4d' % number_integer)\nprint('{:4d}'.format(number_integer))\ninput>>  42\n```\n\n对于浮点数，填充值表示完整的长度。\n\n```\nnumber_float = 3.141592653589793\nprint('%06.2f' % number_float)\nprint('{:06.2f}'.format(number_float))\ninput>>003.14\n```\n\n## 有符号的整数\n\n默认来说，只有负数会有符号。当然，我们可以显式给正数也加上。\n\n```\nnumber_integer = 42\nprint('%+d' % number_integer)\nprint('{:+d}'.format(number_integer))\ninput>>+42\n```\n\n使用空格字符表示负数应该以负号作为前缀，而正数应该使用前导空格。\n\n```\nprint('% d' % (- 23))\nprint('{: d}'.format(- 23))\ninput>>-23\n```\n\n新风格也能给负整数填充。\n\n```\nprint('{:=-5d}'.format(- 23))\nprint('{:=+5d}'.format(23))\ninput>>-  23\ninput>>+  23\n```\n\n## 名称占位符\n\n介绍完了对于数字的操作，接下来介绍一些关于占位符的案例。\n\n```\ndata = {'first': 'Hodor', 'last': 'Hodor!'}\nprint('%(first)s %(last)s' % data)\nprint('{first} {last}'.format(**data))\nprint('{first} {last}'.format(first='Hodor', last='Hodor!'))  # only available with new style formatting.\ninput>>Hodor Hodor!\n```\n\n## Getitem和Getattr\n\n新风格允许对数据结构进行更灵活的操作。\n它可以操作拥有__getitem__方法的对象。\n\n```\nperson = {'first': 'Jean-Luc', 'last': 'Picard'}\nprint('{p[first]} {p[last]}'.format(p=person))\ninput>>Jean-Luc Picard\ndata = [4, 8, 15, 16, 23, 42]\nprint('{d[4]} {d[5]}'.format(d=data))\ninput>>23 42\n```\n\n它也支持操作拥有getattr()属性的对象。\n\n```\nclass Plant(object):\n    type = 'tree'\nprint('{p.type}'.format(p=Plant()))\ninput>>tree\n```\n\n它也支持二者的同时操作。\n\n```\nclass Plant(object):\n    type = 'tree'\n    kinds = [{'name': 'oak'}, {'name': 'maple'}]\nprint('{p.type}: {p.kinds[0][name]}'.format(p=Plant()))\ninput>>tree: oak\n```\n\n## 时间\n\n新风格也允许日期时间对象内联格式化。\n\n```\nfrom datetime import datetime\nprint('{:%Y-%m-%d %H:%M:%S}'.format(datetime.now()))\ninput>>2018-01-29 13:38:40\n```\n\n## 参数格式化\n\n新风格格式化允许使用参数来动态指定。参数化格式是大括号中的嵌套表达式，可以在冒号后的父级格式的任何地方出现。\n\n```\nprint('{:{align}{width}}'.format('test', align='>', width='10'))\ninput>>      test\nprint('{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3))\ninput>>Gib = 2.718\nprint('{:{width}.{prec}f}'.format(2.7182, width=5, prec=2))\ninput>> 2.72\nprint('{:{prec}} = {:{prec}}'.format('Gibberish', 2.7182, prec='.3'))\ninput>>Gib = 2.72\nfrom datetime import datetime\ndt = datetime.now()\nprint('{:{dfmt} {tfmt}}'.format(dt, dfmt='%Y-%m-%d', tfmt='%H:%M'))\ninput>>2018-01-29 13:59\n```\n\n## 参考\n[https://pyformat.info/](https://pyformat.info/)\n\n[https://github.com/ulope/pyformat.info](https://github.com/ulope/pyformat.info)\n## 最后\n\n本文代码连接： [% and .format()](https://github.com/Miksztowi/CorePython/blob/master/format_and_%25_/demo.py)\n\n\n如有纰漏之处，还请您不吝赐教。 \n\nHave fun :)\n","slug":"python格式化的案例解释","published":1,"updated":"2018-01-29T06:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwku0025vmvvqi2vr2tt","content":"<h2 id=\"题记\"><a href=\"#题记\" class=\"headerlink\" title=\"题记\"></a>题记</h2><p>因为对python2x和python3x都有使用经历，所以常常对<strong>%</strong>和<strong>.format()</strong>记忆混乱，索性今天在网上参考了几篇案例较多的tutorial,把这两种格式化风格的使用案例做一个归档。</p>\n<p>为了后面叙述方便，我们将%定义为旧风格，.format()定义为新风格。</p>\n<h2 id=\"通用的格式化\"><a href=\"#通用的格式化\" class=\"headerlink\" title=\"通用的格式化\"></a>通用的格式化</h2><p>简单的位置格式化应该是最常用的，通常在参数顺序不变的情况下使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;%s %s&apos; % (one, two)) </div><div class=\"line\">print(&apos;&#123;&#125; &#123;&#125;&apos;.format(one, two))</div><div class=\"line\">input&gt;&gt;one two</div></pre></td></tr></table></figure>\n<p>但是对于.format()，可以使用占位符来显式定义参数顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 这个操作对于%s的格式化操作来说是不可用的.</div><div class=\"line\">print(&apos;&#123;1&#125; &#123;0&#125;&apos;.format(one, two))</div><div class=\"line\">input&gt;&gt;two one</div></pre></td></tr></table></figure>\n<h2 id=\"值的转化\"><a href=\"#值的转化\" class=\"headerlink\" title=\"值的转化\"></a>值的转化</h2><p>.format()函数，调用的是对象的<strong>format</strong>()方法，如果你需要输出str(…)或者repr(…)，你可以使用!s或者!r来转化标记。 </p>\n<p>在旧风格中使用%s或者%r来转化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Data:</div><div class=\"line\">    def __str__(self):</div><div class=\"line\">        return &apos;str&apos;</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;repr&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">print(&apos;%s %r&apos; % (Data(), Data()))</div><div class=\"line\">print(&apos;&#123;!s&#125; &#123;!r&#125;&apos;.format(Data(), Data()))</div><div class=\"line\">input&gt;&gt;str repr</div></pre></td></tr></table></figure>\n<h2 id=\"填充以及校准字符串\"><a href=\"#填充以及校准字符串\" class=\"headerlink\" title=\"填充以及校准字符串\"></a>填充以及校准字符串</h2><p>默认的格式化值是用给予的值来填充的，然而有时候也需要格式化值达到一个确定的长度。</p>\n<p>关于这点，两种风格就显得截然不同了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;%10s&apos; % one)</div><div class=\"line\">print(&apos;&#123;:&gt;10&#125;&apos;.format(one))</div><div class=\"line\"></div><div class=\"line\"># 左校准</div><div class=\"line\">print(&apos;%-10s&apos; % one)</div><div class=\"line\">print(&apos;&#123;:10&#125;&apos;.format(one))</div><div class=\"line\"></div><div class=\"line\">input&gt;&gt;       one</div><div class=\"line\">inupt&gt;&gt;one</div></pre></td></tr></table></figure>\n<p>而新风格，还提供了自定义填充字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 自定义填充字符，下列操作在旧风格中均不可行。</div><div class=\"line\">print(&apos;&#123;:_&lt;10&#125;&apos;.format(one))</div><div class=\"line\">print(&apos;&#123;:^10&#125;&apos;.format(one))  # 居中</div><div class=\"line\">print(&apos;&#123;:^6&#125;&apos;.format(&apos;zip&apos;))  # 居中操作中，遇到奇数分割的时候，会将多出来的填充位放在右边。</div><div class=\"line\">input&gt;&gt;one_______</div><div class=\"line\">input&gt;&gt;   one    </div><div class=\"line\">input&gt;&gt; zip</div></pre></td></tr></table></figure>\n<h2 id=\"截断长字符串\"><a href=\"#截断长字符串\" class=\"headerlink\" title=\"截断长字符串\"></a>截断长字符串</h2><p>相对于填充字符串达到固定长度来说，我们也可以截断字符串来达到固定长度。在格式化字符串中.后的数字是表明\u0005截断的长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str_ = &apos;hello world.&apos;</div><div class=\"line\">print(&apos;%.5s&apos; %(str_))</div><div class=\"line\">print(&apos;&#123;:.5&#125;&apos;.format(str_))</div><div class=\"line\">input&gt;&gt;hello</div></pre></td></tr></table></figure>\n<h2 id=\"填充与截断的结合使用\"><a href=\"#填充与截断的结合使用\" class=\"headerlink\" title=\"填充与截断的结合使用\"></a>填充与截断的结合使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str_ = &apos;hello world.&apos;</div><div class=\"line\">print(&apos;%10.5s&apos; % str_)</div><div class=\"line\">print(&apos;&#123;:&gt;10.5&#125;&apos;.format(str_))</div><div class=\"line\">input&gt;&gt;     hello</div></pre></td></tr></table></figure>\n<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><p>格式化数字也是常见的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%d&apos; % (number_integer))</div><div class=\"line\">print(&apos;&#123;:d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;42</div><div class=\"line\"></div><div class=\"line\">number_float = 3.141592653589793</div><div class=\"line\">print(&apos;%f&apos; % number_float)</div><div class=\"line\">print(&apos;&#123;:f&#125;&apos;.format(number_float))</div><div class=\"line\">input&gt;&gt;3.141593</div></pre></td></tr></table></figure>\n<h2 id=\"填充数字\"><a href=\"#填充数字\" class=\"headerlink\" title=\"填充数字\"></a>填充数字</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%4d&apos; % number_integer)</div><div class=\"line\">print(&apos;&#123;:4d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;  42</div></pre></td></tr></table></figure>\n<p>对于浮点数，填充值表示完整的长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_float = 3.141592653589793</div><div class=\"line\">print(&apos;%06.2f&apos; % number_float)</div><div class=\"line\">print(&apos;&#123;:06.2f&#125;&apos;.format(number_float))</div><div class=\"line\">input&gt;&gt;003.14</div></pre></td></tr></table></figure>\n<h2 id=\"有符号的整数\"><a href=\"#有符号的整数\" class=\"headerlink\" title=\"有符号的整数\"></a>有符号的整数</h2><p>默认来说，只有负数会有符号。当然，我们可以显式给正数也加上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%+d&apos; % number_integer)</div><div class=\"line\">print(&apos;&#123;:+d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;+42</div></pre></td></tr></table></figure>\n<p>使用空格字符表示负数应该以负号作为前缀，而正数应该使用前导空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;% d&apos; % (- 23))</div><div class=\"line\">print(&apos;&#123;: d&#125;&apos;.format(- 23))</div><div class=\"line\">input&gt;&gt;-23</div></pre></td></tr></table></figure>\n<p>新风格也能给负整数填充。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;&#123;:=-5d&#125;&apos;.format(- 23))</div><div class=\"line\">print(&apos;&#123;:=+5d&#125;&apos;.format(23))</div><div class=\"line\">input&gt;&gt;-  23</div><div class=\"line\">input&gt;&gt;+  23</div></pre></td></tr></table></figure>\n<h2 id=\"名称占位符\"><a href=\"#名称占位符\" class=\"headerlink\" title=\"名称占位符\"></a>名称占位符</h2><p>介绍完了对于数字的操作，接下来介绍一些关于占位符的案例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">data = &#123;&apos;first&apos;: &apos;Hodor&apos;, &apos;last&apos;: &apos;Hodor!&apos;&#125;</div><div class=\"line\">print(&apos;%(first)s %(last)s&apos; % data)</div><div class=\"line\">print(&apos;&#123;first&#125; &#123;last&#125;&apos;.format(**data))</div><div class=\"line\">print(&apos;&#123;first&#125; &#123;last&#125;&apos;.format(first=&apos;Hodor&apos;, last=&apos;Hodor!&apos;))  # only available with new style formatting.</div><div class=\"line\">input&gt;&gt;Hodor Hodor!</div></pre></td></tr></table></figure>\n<h2 id=\"Getitem和Getattr\"><a href=\"#Getitem和Getattr\" class=\"headerlink\" title=\"Getitem和Getattr\"></a>Getitem和Getattr</h2><p>新风格允许对数据结构进行更灵活的操作。<br>它可以操作拥有<strong>getitem</strong>方法的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">person = &#123;&apos;first&apos;: &apos;Jean-Luc&apos;, &apos;last&apos;: &apos;Picard&apos;&#125;</div><div class=\"line\">print(&apos;&#123;p[first]&#125; &#123;p[last]&#125;&apos;.format(p=person))</div><div class=\"line\">input&gt;&gt;Jean-Luc Picard</div><div class=\"line\">data = [4, 8, 15, 16, 23, 42]</div><div class=\"line\">print(&apos;&#123;d[4]&#125; &#123;d[5]&#125;&apos;.format(d=data))</div><div class=\"line\">input&gt;&gt;23 42</div></pre></td></tr></table></figure>\n<p>它也支持操作拥有getattr()属性的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Plant(object):</div><div class=\"line\">    type = &apos;tree&apos;</div><div class=\"line\">print(&apos;&#123;p.type&#125;&apos;.format(p=Plant()))</div><div class=\"line\">input&gt;&gt;tree</div></pre></td></tr></table></figure>\n<p>它也支持二者的同时操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Plant(object):</div><div class=\"line\">    type = &apos;tree&apos;</div><div class=\"line\">    kinds = [&#123;&apos;name&apos;: &apos;oak&apos;&#125;, &#123;&apos;name&apos;: &apos;maple&apos;&#125;]</div><div class=\"line\">print(&apos;&#123;p.type&#125;: &#123;p.kinds[0][name]&#125;&apos;.format(p=Plant()))</div><div class=\"line\">input&gt;&gt;tree: oak</div></pre></td></tr></table></figure>\n<h2 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h2><p>新风格也允许日期时间对象内联格式化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">from datetime import datetime</div><div class=\"line\">print(&apos;&#123;:%Y-%m-%d %H:%M:%S&#125;&apos;.format(datetime.now()))</div><div class=\"line\">input&gt;&gt;2018-01-29 13:38:40</div></pre></td></tr></table></figure>\n<h2 id=\"参数格式化\"><a href=\"#参数格式化\" class=\"headerlink\" title=\"参数格式化\"></a>参数格式化</h2><p>新风格格式化允许使用参数来动态指定。参数化格式是大括号中的嵌套表达式，可以在冒号后的父级格式的任何地方出现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;&#123;:&#123;align&#125;&#123;width&#125;&#125;&apos;.format(&apos;test&apos;, align=&apos;&gt;&apos;, width=&apos;10&apos;))</div><div class=\"line\">input&gt;&gt;      test</div><div class=\"line\">print(&apos;&#123;:.&#123;prec&#125;&#125; = &#123;:.&#123;prec&#125;f&#125;&apos;.format(&apos;Gibberish&apos;, 2.7182, prec=3))</div><div class=\"line\">input&gt;&gt;Gib = 2.718</div><div class=\"line\">print(&apos;&#123;:&#123;width&#125;.&#123;prec&#125;f&#125;&apos;.format(2.7182, width=5, prec=2))</div><div class=\"line\">input&gt;&gt; 2.72</div><div class=\"line\">print(&apos;&#123;:&#123;prec&#125;&#125; = &#123;:&#123;prec&#125;&#125;&apos;.format(&apos;Gibberish&apos;, 2.7182, prec=&apos;.3&apos;))</div><div class=\"line\">input&gt;&gt;Gib = 2.72</div><div class=\"line\">from datetime import datetime</div><div class=\"line\">dt = datetime.now()</div><div class=\"line\">print(&apos;&#123;:&#123;dfmt&#125; &#123;tfmt&#125;&#125;&apos;.format(dt, dfmt=&apos;%Y-%m-%d&apos;, tfmt=&apos;%H:%M&apos;))</div><div class=\"line\">input&gt;&gt;2018-01-29 13:59</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://pyformat.info/\" target=\"_blank\" rel=\"external\">https://pyformat.info/</a></p>\n<p><a href=\"https://github.com/ulope/pyformat.info\" target=\"_blank\" rel=\"external\">https://github.com/ulope/pyformat.info</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文代码连接： <a href=\"https://github.com/Miksztowi/CorePython/blob/master/format_and_%25_/demo.py\" target=\"_blank\" rel=\"external\">% and .format()</a></p>\n<p>如有纰漏之处，还请您不吝赐教。 </p>\n<p>Have fun :)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题记\"><a href=\"#题记\" class=\"headerlink\" title=\"题记\"></a>题记</h2><p>因为对python2x和python3x都有使用经历，所以常常对<strong>%</strong>和<strong>.format()</strong>记忆混乱，索性今天在网上参考了几篇案例较多的tutorial,把这两种格式化风格的使用案例做一个归档。</p>\n<p>为了后面叙述方便，我们将%定义为旧风格，.format()定义为新风格。</p>\n<h2 id=\"通用的格式化\"><a href=\"#通用的格式化\" class=\"headerlink\" title=\"通用的格式化\"></a>通用的格式化</h2><p>简单的位置格式化应该是最常用的，通常在参数顺序不变的情况下使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;%s %s&apos; % (one, two)) </div><div class=\"line\">print(&apos;&#123;&#125; &#123;&#125;&apos;.format(one, two))</div><div class=\"line\">input&gt;&gt;one two</div></pre></td></tr></table></figure>\n<p>但是对于.format()，可以使用占位符来显式定义参数顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 这个操作对于%s的格式化操作来说是不可用的.</div><div class=\"line\">print(&apos;&#123;1&#125; &#123;0&#125;&apos;.format(one, two))</div><div class=\"line\">input&gt;&gt;two one</div></pre></td></tr></table></figure>\n<h2 id=\"值的转化\"><a href=\"#值的转化\" class=\"headerlink\" title=\"值的转化\"></a>值的转化</h2><p>.format()函数，调用的是对象的<strong>format</strong>()方法，如果你需要输出str(…)或者repr(…)，你可以使用!s或者!r来转化标记。 </p>\n<p>在旧风格中使用%s或者%r来转化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Data:</div><div class=\"line\">    def __str__(self):</div><div class=\"line\">        return &apos;str&apos;</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;repr&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">print(&apos;%s %r&apos; % (Data(), Data()))</div><div class=\"line\">print(&apos;&#123;!s&#125; &#123;!r&#125;&apos;.format(Data(), Data()))</div><div class=\"line\">input&gt;&gt;str repr</div></pre></td></tr></table></figure>\n<h2 id=\"填充以及校准字符串\"><a href=\"#填充以及校准字符串\" class=\"headerlink\" title=\"填充以及校准字符串\"></a>填充以及校准字符串</h2><p>默认的格式化值是用给予的值来填充的，然而有时候也需要格式化值达到一个确定的长度。</p>\n<p>关于这点，两种风格就显得截然不同了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;%10s&apos; % one)</div><div class=\"line\">print(&apos;&#123;:&gt;10&#125;&apos;.format(one))</div><div class=\"line\"></div><div class=\"line\"># 左校准</div><div class=\"line\">print(&apos;%-10s&apos; % one)</div><div class=\"line\">print(&apos;&#123;:10&#125;&apos;.format(one))</div><div class=\"line\"></div><div class=\"line\">input&gt;&gt;       one</div><div class=\"line\">inupt&gt;&gt;one</div></pre></td></tr></table></figure>\n<p>而新风格，还提供了自定义填充字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 自定义填充字符，下列操作在旧风格中均不可行。</div><div class=\"line\">print(&apos;&#123;:_&lt;10&#125;&apos;.format(one))</div><div class=\"line\">print(&apos;&#123;:^10&#125;&apos;.format(one))  # 居中</div><div class=\"line\">print(&apos;&#123;:^6&#125;&apos;.format(&apos;zip&apos;))  # 居中操作中，遇到奇数分割的时候，会将多出来的填充位放在右边。</div><div class=\"line\">input&gt;&gt;one_______</div><div class=\"line\">input&gt;&gt;   one    </div><div class=\"line\">input&gt;&gt; zip</div></pre></td></tr></table></figure>\n<h2 id=\"截断长字符串\"><a href=\"#截断长字符串\" class=\"headerlink\" title=\"截断长字符串\"></a>截断长字符串</h2><p>相对于填充字符串达到固定长度来说，我们也可以截断字符串来达到固定长度。在格式化字符串中.后的数字是表明\u0005截断的长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str_ = &apos;hello world.&apos;</div><div class=\"line\">print(&apos;%.5s&apos; %(str_))</div><div class=\"line\">print(&apos;&#123;:.5&#125;&apos;.format(str_))</div><div class=\"line\">input&gt;&gt;hello</div></pre></td></tr></table></figure>\n<h2 id=\"填充与截断的结合使用\"><a href=\"#填充与截断的结合使用\" class=\"headerlink\" title=\"填充与截断的结合使用\"></a>填充与截断的结合使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">str_ = &apos;hello world.&apos;</div><div class=\"line\">print(&apos;%10.5s&apos; % str_)</div><div class=\"line\">print(&apos;&#123;:&gt;10.5&#125;&apos;.format(str_))</div><div class=\"line\">input&gt;&gt;     hello</div></pre></td></tr></table></figure>\n<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><p>格式化数字也是常见的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%d&apos; % (number_integer))</div><div class=\"line\">print(&apos;&#123;:d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;42</div><div class=\"line\"></div><div class=\"line\">number_float = 3.141592653589793</div><div class=\"line\">print(&apos;%f&apos; % number_float)</div><div class=\"line\">print(&apos;&#123;:f&#125;&apos;.format(number_float))</div><div class=\"line\">input&gt;&gt;3.141593</div></pre></td></tr></table></figure>\n<h2 id=\"填充数字\"><a href=\"#填充数字\" class=\"headerlink\" title=\"填充数字\"></a>填充数字</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%4d&apos; % number_integer)</div><div class=\"line\">print(&apos;&#123;:4d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;  42</div></pre></td></tr></table></figure>\n<p>对于浮点数，填充值表示完整的长度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_float = 3.141592653589793</div><div class=\"line\">print(&apos;%06.2f&apos; % number_float)</div><div class=\"line\">print(&apos;&#123;:06.2f&#125;&apos;.format(number_float))</div><div class=\"line\">input&gt;&gt;003.14</div></pre></td></tr></table></figure>\n<h2 id=\"有符号的整数\"><a href=\"#有符号的整数\" class=\"headerlink\" title=\"有符号的整数\"></a>有符号的整数</h2><p>默认来说，只有负数会有符号。当然，我们可以显式给正数也加上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">number_integer = 42</div><div class=\"line\">print(&apos;%+d&apos; % number_integer)</div><div class=\"line\">print(&apos;&#123;:+d&#125;&apos;.format(number_integer))</div><div class=\"line\">input&gt;&gt;+42</div></pre></td></tr></table></figure>\n<p>使用空格字符表示负数应该以负号作为前缀，而正数应该使用前导空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;% d&apos; % (- 23))</div><div class=\"line\">print(&apos;&#123;: d&#125;&apos;.format(- 23))</div><div class=\"line\">input&gt;&gt;-23</div></pre></td></tr></table></figure>\n<p>新风格也能给负整数填充。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;&#123;:=-5d&#125;&apos;.format(- 23))</div><div class=\"line\">print(&apos;&#123;:=+5d&#125;&apos;.format(23))</div><div class=\"line\">input&gt;&gt;-  23</div><div class=\"line\">input&gt;&gt;+  23</div></pre></td></tr></table></figure>\n<h2 id=\"名称占位符\"><a href=\"#名称占位符\" class=\"headerlink\" title=\"名称占位符\"></a>名称占位符</h2><p>介绍完了对于数字的操作，接下来介绍一些关于占位符的案例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">data = &#123;&apos;first&apos;: &apos;Hodor&apos;, &apos;last&apos;: &apos;Hodor!&apos;&#125;</div><div class=\"line\">print(&apos;%(first)s %(last)s&apos; % data)</div><div class=\"line\">print(&apos;&#123;first&#125; &#123;last&#125;&apos;.format(**data))</div><div class=\"line\">print(&apos;&#123;first&#125; &#123;last&#125;&apos;.format(first=&apos;Hodor&apos;, last=&apos;Hodor!&apos;))  # only available with new style formatting.</div><div class=\"line\">input&gt;&gt;Hodor Hodor!</div></pre></td></tr></table></figure>\n<h2 id=\"Getitem和Getattr\"><a href=\"#Getitem和Getattr\" class=\"headerlink\" title=\"Getitem和Getattr\"></a>Getitem和Getattr</h2><p>新风格允许对数据结构进行更灵活的操作。<br>它可以操作拥有<strong>getitem</strong>方法的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">person = &#123;&apos;first&apos;: &apos;Jean-Luc&apos;, &apos;last&apos;: &apos;Picard&apos;&#125;</div><div class=\"line\">print(&apos;&#123;p[first]&#125; &#123;p[last]&#125;&apos;.format(p=person))</div><div class=\"line\">input&gt;&gt;Jean-Luc Picard</div><div class=\"line\">data = [4, 8, 15, 16, 23, 42]</div><div class=\"line\">print(&apos;&#123;d[4]&#125; &#123;d[5]&#125;&apos;.format(d=data))</div><div class=\"line\">input&gt;&gt;23 42</div></pre></td></tr></table></figure>\n<p>它也支持操作拥有getattr()属性的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Plant(object):</div><div class=\"line\">    type = &apos;tree&apos;</div><div class=\"line\">print(&apos;&#123;p.type&#125;&apos;.format(p=Plant()))</div><div class=\"line\">input&gt;&gt;tree</div></pre></td></tr></table></figure>\n<p>它也支持二者的同时操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Plant(object):</div><div class=\"line\">    type = &apos;tree&apos;</div><div class=\"line\">    kinds = [&#123;&apos;name&apos;: &apos;oak&apos;&#125;, &#123;&apos;name&apos;: &apos;maple&apos;&#125;]</div><div class=\"line\">print(&apos;&#123;p.type&#125;: &#123;p.kinds[0][name]&#125;&apos;.format(p=Plant()))</div><div class=\"line\">input&gt;&gt;tree: oak</div></pre></td></tr></table></figure>\n<h2 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h2><p>新风格也允许日期时间对象内联格式化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">from datetime import datetime</div><div class=\"line\">print(&apos;&#123;:%Y-%m-%d %H:%M:%S&#125;&apos;.format(datetime.now()))</div><div class=\"line\">input&gt;&gt;2018-01-29 13:38:40</div></pre></td></tr></table></figure>\n<h2 id=\"参数格式化\"><a href=\"#参数格式化\" class=\"headerlink\" title=\"参数格式化\"></a>参数格式化</h2><p>新风格格式化允许使用参数来动态指定。参数化格式是大括号中的嵌套表达式，可以在冒号后的父级格式的任何地方出现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&apos;&#123;:&#123;align&#125;&#123;width&#125;&#125;&apos;.format(&apos;test&apos;, align=&apos;&gt;&apos;, width=&apos;10&apos;))</div><div class=\"line\">input&gt;&gt;      test</div><div class=\"line\">print(&apos;&#123;:.&#123;prec&#125;&#125; = &#123;:.&#123;prec&#125;f&#125;&apos;.format(&apos;Gibberish&apos;, 2.7182, prec=3))</div><div class=\"line\">input&gt;&gt;Gib = 2.718</div><div class=\"line\">print(&apos;&#123;:&#123;width&#125;.&#123;prec&#125;f&#125;&apos;.format(2.7182, width=5, prec=2))</div><div class=\"line\">input&gt;&gt; 2.72</div><div class=\"line\">print(&apos;&#123;:&#123;prec&#125;&#125; = &#123;:&#123;prec&#125;&#125;&apos;.format(&apos;Gibberish&apos;, 2.7182, prec=&apos;.3&apos;))</div><div class=\"line\">input&gt;&gt;Gib = 2.72</div><div class=\"line\">from datetime import datetime</div><div class=\"line\">dt = datetime.now()</div><div class=\"line\">print(&apos;&#123;:&#123;dfmt&#125; &#123;tfmt&#125;&#125;&apos;.format(dt, dfmt=&apos;%Y-%m-%d&apos;, tfmt=&apos;%H:%M&apos;))</div><div class=\"line\">input&gt;&gt;2018-01-29 13:59</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://pyformat.info/\" target=\"_blank\" rel=\"external\">https://pyformat.info/</a></p>\n<p><a href=\"https://github.com/ulope/pyformat.info\" target=\"_blank\" rel=\"external\">https://github.com/ulope/pyformat.info</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文代码连接： <a href=\"https://github.com/Miksztowi/CorePython/blob/master/format_and_%25_/demo.py\" target=\"_blank\" rel=\"external\">% and .format()</a></p>\n<p>如有纰漏之处，还请您不吝赐教。 </p>\n<p>Have fun :)</p>\n"},{"title":"Python generator 介绍","date":"2017-12-02T09:12:38.000Z","_content":"## Preface\nGenerator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：[Python Iterators and Iterables介绍](http://miks.top/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/)\n\n\n\n## How a generator function works in detail, with line by line descriptions.\n介绍相关概念前，我们先看一个Pythonic的Iterator实现。\n\n```\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for word in self.words:\n            yield word\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n对比之前实现的例子，可以看到已经简洁很多了！！ \ntip: 最简洁的是 return iter(self.words)\n```\n\n在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。\n\n```\ndef gen_123():\n    yield 1\n    yield 2\n    yield 3\n\nprint(gen_123)\nprint(gen_123())\nfor i in gen_123():\n    print(i)\ng = gen_123()\nprint(next(g))\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n<function gen_123 at 0x10a6661e0>\n<generator object gen_123 at 0x10a5d8258>\n1\n2\n3\n1\n2\n3\nTraceback (most recent call last):\n  File \"/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py\", line 45, in <module>\n    print(next(g))\nStopIteration\n当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。\n```\n调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。\n\n明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick---lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。\n\n我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for match in RE_WORD.finditer(self.text):\n            yield match.group()\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n```\n\n\n\n## How the classic Iterator can be repalced by a generator function or generator expression.\n尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！\n\ngenerator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。\n\n```\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\nif __name__ == '__main__':\n    res1 = [x*3 for x in gen_AB()]\n    for i in res1:\n        print(i)\n    res2 = (x*3 for x in gen_AB())\n    for i in res2:\n        print(i)\nstart\ncontinue\nend.\nAAA\nBBB\n\n\nstart\nAAA\ncontinue\nBBB\nend.\n\n通过打印结果，可以验证generator expression是lazy的。\n```\n\n\ngenerator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n\n    def __iter__(self):\n        return (match.group() for match in RE_WORD.finditer(self.text))\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。\n```\n尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.\n\n\n最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？\n\n```\n\nclass ArithmeticProgression(object):\n    def __init__(self, begin, step, end=None):\n        self.begin = begin\n        self.step = step\n        self.end = end\n\n    def __iter__(self):\n        result = type(self.begin + self.step)(self.begin)\n        forever = self.end is None\n        index = 0\n        while forever or result < self.end:\n            yield result\n            index += 1\n            result = self.begin + self.step * index\nap1 = ArithmeticProgression(1, 0.5, 2)\nprint(list(ap1))\nap2 = ArithmeticProgression(1, 0.5)\nfor i in ap2:\n    print(i)\n\nap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。  \n```\n\n\n## Using the new yield from statement to combine generators\n\n当我们的generator需要从另一个generator得到值时，要如何操作呢？\n\n```\ndef chain(*iterables):\n    for it in iterables:\n        for i in it:\n            yield i\ns = 'ABC'\nt = tuple(range(3))\nprint(list(chain(s, t)))\n\n['A', 'B', 'C', 0, 1, 2]\n\n要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。\ndef chain(*iterables):\n    for it in iterables:\n        yield from it \n```\nyield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。\n\n\n## Summary\n最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。\n\n本章相关代码：\n[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n\n\n\n","source":"_posts/Python-generator-介绍.md","raw":"---\ntitle: Python generator 介绍\ndate: 2017-12-02 17:12:38\ntags: Python\n\n---\n## Preface\nGenerator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：[Python Iterators and Iterables介绍](http://miks.top/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/)\n\n\n\n## How a generator function works in detail, with line by line descriptions.\n介绍相关概念前，我们先看一个Pythonic的Iterator实现。\n\n```\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for word in self.words:\n            yield word\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n对比之前实现的例子，可以看到已经简洁很多了！！ \ntip: 最简洁的是 return iter(self.words)\n```\n\n在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。\n\n```\ndef gen_123():\n    yield 1\n    yield 2\n    yield 3\n\nprint(gen_123)\nprint(gen_123())\nfor i in gen_123():\n    print(i)\ng = gen_123()\nprint(next(g))\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n<function gen_123 at 0x10a6661e0>\n<generator object gen_123 at 0x10a5d8258>\n1\n2\n3\n1\n2\n3\nTraceback (most recent call last):\n  File \"/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py\", line 45, in <module>\n    print(next(g))\nStopIteration\n当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。\n```\n调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。\n\n明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick---lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。\n\n我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for match in RE_WORD.finditer(self.text):\n            yield match.group()\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n```\n\n\n\n## How the classic Iterator can be repalced by a generator function or generator expression.\n尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！\n\ngenerator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。\n\n```\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\nif __name__ == '__main__':\n    res1 = [x*3 for x in gen_AB()]\n    for i in res1:\n        print(i)\n    res2 = (x*3 for x in gen_AB())\n    for i in res2:\n        print(i)\nstart\ncontinue\nend.\nAAA\nBBB\n\n\nstart\nAAA\ncontinue\nBBB\nend.\n\n通过打印结果，可以验证generator expression是lazy的。\n```\n\n\ngenerator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n\n    def __iter__(self):\n        return (match.group() for match in RE_WORD.finditer(self.text))\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。\n```\n尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.\n\n\n最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？\n\n```\n\nclass ArithmeticProgression(object):\n    def __init__(self, begin, step, end=None):\n        self.begin = begin\n        self.step = step\n        self.end = end\n\n    def __iter__(self):\n        result = type(self.begin + self.step)(self.begin)\n        forever = self.end is None\n        index = 0\n        while forever or result < self.end:\n            yield result\n            index += 1\n            result = self.begin + self.step * index\nap1 = ArithmeticProgression(1, 0.5, 2)\nprint(list(ap1))\nap2 = ArithmeticProgression(1, 0.5)\nfor i in ap2:\n    print(i)\n\nap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。  \n```\n\n\n## Using the new yield from statement to combine generators\n\n当我们的generator需要从另一个generator得到值时，要如何操作呢？\n\n```\ndef chain(*iterables):\n    for it in iterables:\n        for i in it:\n            yield i\ns = 'ABC'\nt = tuple(range(3))\nprint(list(chain(s, t)))\n\n['A', 'B', 'C', 0, 1, 2]\n\n要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。\ndef chain(*iterables):\n    for it in iterables:\n        yield from it \n```\nyield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。\n\n\n## Summary\n最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。\n\n本章相关代码：\n[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n\n\n\n","slug":"Python-generator-介绍","published":1,"updated":"2018-01-25T13:06:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkv0027vmvvitce17s6","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：<a href=\"http://miks.top/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/\">Python Iterators and Iterables介绍</a></p>\n<h2 id=\"How-a-generator-function-works-in-detail-with-line-by-line-descriptions\"><a href=\"#How-a-generator-function-works-in-detail-with-line-by-line-descriptions\" class=\"headerlink\" title=\"How a generator function works in detail, with line by line descriptions.\"></a>How a generator function works in detail, with line by line descriptions.</h2><p>介绍相关概念前，我们先看一个Pythonic的Iterator实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for word in self.words:</div><div class=\"line\">            yield word</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">对比之前实现的例子，可以看到已经简洁很多了！！ </div><div class=\"line\">tip: 最简洁的是 return iter(self.words)</div></pre></td></tr></table></figure>\n<p>在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_123():</div><div class=\"line\">    yield 1</div><div class=\"line\">    yield 2</div><div class=\"line\">    yield 3</div><div class=\"line\"></div><div class=\"line\">print(gen_123)</div><div class=\"line\">print(gen_123())</div><div class=\"line\">for i in gen_123():</div><div class=\"line\">    print(i)</div><div class=\"line\">g = gen_123()</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\"></div><div class=\"line\">&lt;function gen_123 at 0x10a6661e0&gt;</div><div class=\"line\">&lt;generator object gen_123 at 0x10a5d8258&gt;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py&quot;, line 45, in &lt;module&gt;</div><div class=\"line\">    print(next(g))</div><div class=\"line\">StopIteration</div><div class=\"line\">当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。</div></pre></td></tr></table></figure>\n<p>调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。</p>\n<p>明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick—lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。</p>\n<p>我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for match in RE_WORD.finditer(self.text):</div><div class=\"line\">            yield match.group()</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\"><a href=\"#How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\" class=\"headerlink\" title=\"How the classic Iterator can be repalced by a generator function or generator expression.\"></a>How the classic Iterator can be repalced by a generator function or generator expression.</h2><p>尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！</p>\n<p>generator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_AB():</div><div class=\"line\">    print(&apos;start&apos;)</div><div class=\"line\">    yield &apos;A&apos;</div><div class=\"line\">    print(&apos;continue&apos;)</div><div class=\"line\">    yield &apos;B&apos;</div><div class=\"line\">    print(&apos;end.&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    res1 = [x*3 for x in gen_AB()]</div><div class=\"line\">    for i in res1:</div><div class=\"line\">        print(i)</div><div class=\"line\">    res2 = (x*3 for x in gen_AB())</div><div class=\"line\">    for i in res2:</div><div class=\"line\">        print(i)</div><div class=\"line\">start</div><div class=\"line\">continue</div><div class=\"line\">end.</div><div class=\"line\">AAA</div><div class=\"line\">BBB</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\">AAA</div><div class=\"line\">continue</div><div class=\"line\">BBB</div><div class=\"line\">end.</div><div class=\"line\"></div><div class=\"line\">通过打印结果，可以验证generator expression是lazy的。</div></pre></td></tr></table></figure>\n<p>generator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return (match.group() for match in RE_WORD.finditer(self.text))</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\">尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。</div></pre></td></tr></table></figure>\n<p>尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.</p>\n<p>最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class ArithmeticProgression(object):</div><div class=\"line\">    def __init__(self, begin, step, end=None):</div><div class=\"line\">        self.begin = begin</div><div class=\"line\">        self.step = step</div><div class=\"line\">        self.end = end</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        result = type(self.begin + self.step)(self.begin)</div><div class=\"line\">        forever = self.end is None</div><div class=\"line\">        index = 0</div><div class=\"line\">        while forever or result &lt; self.end:</div><div class=\"line\">            yield result</div><div class=\"line\">            index += 1</div><div class=\"line\">            result = self.begin + self.step * index</div><div class=\"line\">ap1 = ArithmeticProgression(1, 0.5, 2)</div><div class=\"line\">print(list(ap1))</div><div class=\"line\">ap2 = ArithmeticProgression(1, 0.5)</div><div class=\"line\">for i in ap2:</div><div class=\"line\">    print(i)</div><div class=\"line\"></div><div class=\"line\">ap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。</div></pre></td></tr></table></figure>\n<h2 id=\"Using-the-new-yield-from-statement-to-combine-generators\"><a href=\"#Using-the-new-yield-from-statement-to-combine-generators\" class=\"headerlink\" title=\"Using the new yield from statement to combine generators\"></a>Using the new yield from statement to combine generators</h2><p>当我们的generator需要从另一个generator得到值时，要如何操作呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        for i in it:</div><div class=\"line\">            yield i</div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">t = tuple(range(3))</div><div class=\"line\">print(list(chain(s, t)))</div><div class=\"line\"></div><div class=\"line\">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 0, 1, 2]</div><div class=\"line\"></div><div class=\"line\">要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。</div><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        yield from it</div></pre></td></tr></table></figure>\n<p>yield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。</p>\n<p>本章相关代码：<br><a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：<a href=\"http://miks.top/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/\">Python Iterators and Iterables介绍</a></p>\n<h2 id=\"How-a-generator-function-works-in-detail-with-line-by-line-descriptions\"><a href=\"#How-a-generator-function-works-in-detail-with-line-by-line-descriptions\" class=\"headerlink\" title=\"How a generator function works in detail, with line by line descriptions.\"></a>How a generator function works in detail, with line by line descriptions.</h2><p>介绍相关概念前，我们先看一个Pythonic的Iterator实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for word in self.words:</div><div class=\"line\">            yield word</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">对比之前实现的例子，可以看到已经简洁很多了！！ </div><div class=\"line\">tip: 最简洁的是 return iter(self.words)</div></pre></td></tr></table></figure>\n<p>在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_123():</div><div class=\"line\">    yield 1</div><div class=\"line\">    yield 2</div><div class=\"line\">    yield 3</div><div class=\"line\"></div><div class=\"line\">print(gen_123)</div><div class=\"line\">print(gen_123())</div><div class=\"line\">for i in gen_123():</div><div class=\"line\">    print(i)</div><div class=\"line\">g = gen_123()</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\"></div><div class=\"line\">&lt;function gen_123 at 0x10a6661e0&gt;</div><div class=\"line\">&lt;generator object gen_123 at 0x10a5d8258&gt;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py&quot;, line 45, in &lt;module&gt;</div><div class=\"line\">    print(next(g))</div><div class=\"line\">StopIteration</div><div class=\"line\">当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。</div></pre></td></tr></table></figure>\n<p>调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。</p>\n<p>明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick—lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。</p>\n<p>我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for match in RE_WORD.finditer(self.text):</div><div class=\"line\">            yield match.group()</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\"><a href=\"#How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\" class=\"headerlink\" title=\"How the classic Iterator can be repalced by a generator function or generator expression.\"></a>How the classic Iterator can be repalced by a generator function or generator expression.</h2><p>尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！</p>\n<p>generator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_AB():</div><div class=\"line\">    print(&apos;start&apos;)</div><div class=\"line\">    yield &apos;A&apos;</div><div class=\"line\">    print(&apos;continue&apos;)</div><div class=\"line\">    yield &apos;B&apos;</div><div class=\"line\">    print(&apos;end.&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    res1 = [x*3 for x in gen_AB()]</div><div class=\"line\">    for i in res1:</div><div class=\"line\">        print(i)</div><div class=\"line\">    res2 = (x*3 for x in gen_AB())</div><div class=\"line\">    for i in res2:</div><div class=\"line\">        print(i)</div><div class=\"line\">start</div><div class=\"line\">continue</div><div class=\"line\">end.</div><div class=\"line\">AAA</div><div class=\"line\">BBB</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\">AAA</div><div class=\"line\">continue</div><div class=\"line\">BBB</div><div class=\"line\">end.</div><div class=\"line\"></div><div class=\"line\">通过打印结果，可以验证generator expression是lazy的。</div></pre></td></tr></table></figure>\n<p>generator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return (match.group() for match in RE_WORD.finditer(self.text))</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\">尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。</div></pre></td></tr></table></figure>\n<p>尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.</p>\n<p>最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class ArithmeticProgression(object):</div><div class=\"line\">    def __init__(self, begin, step, end=None):</div><div class=\"line\">        self.begin = begin</div><div class=\"line\">        self.step = step</div><div class=\"line\">        self.end = end</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        result = type(self.begin + self.step)(self.begin)</div><div class=\"line\">        forever = self.end is None</div><div class=\"line\">        index = 0</div><div class=\"line\">        while forever or result &lt; self.end:</div><div class=\"line\">            yield result</div><div class=\"line\">            index += 1</div><div class=\"line\">            result = self.begin + self.step * index</div><div class=\"line\">ap1 = ArithmeticProgression(1, 0.5, 2)</div><div class=\"line\">print(list(ap1))</div><div class=\"line\">ap2 = ArithmeticProgression(1, 0.5)</div><div class=\"line\">for i in ap2:</div><div class=\"line\">    print(i)</div><div class=\"line\"></div><div class=\"line\">ap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。</div></pre></td></tr></table></figure>\n<h2 id=\"Using-the-new-yield-from-statement-to-combine-generators\"><a href=\"#Using-the-new-yield-from-statement-to-combine-generators\" class=\"headerlink\" title=\"Using the new yield from statement to combine generators\"></a>Using the new yield from statement to combine generators</h2><p>当我们的generator需要从另一个generator得到值时，要如何操作呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        for i in it:</div><div class=\"line\">            yield i</div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">t = tuple(range(3))</div><div class=\"line\">print(list(chain(s, t)))</div><div class=\"line\"></div><div class=\"line\">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 0, 1, 2]</div><div class=\"line\"></div><div class=\"line\">要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。</div><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        yield from it</div></pre></td></tr></table></figure>\n<p>yield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。</p>\n<p>本章相关代码：<br><a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n"},{"title":"Python asyncio模块介绍","date":"2017-12-19T15:00:51.000Z","_content":"\n\n## Preface\n\n本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。\n\n注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。\n\n## A comparison between a simple threaded program and the asyncio equivalent\n\n我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。\n\nThread demo:\n\n```\nclass Signal:\n    go = True\n\n\ndef spin(msg, signal):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        time.sleep(.1)\n        if not signal.go:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n\ndef slow_function():\n    time.sleep(3)\n    return 42\n\n\ndef supervisor():\n    signal = Signal()\n    spinner = threading.Thread(target=spin,\n                               args=('thinkg!', signal))\n    print('spinner object:', spinner)\n    spinner.start()\n    result = slow_function()\n    signal.go = False\n    spinner.join()\n    return result\n\ndef main():\n    result = supervisor()\n    print('Answer:', result)\n因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。\n```\n注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。\n\n\n### 关于asyncio版本的代码做几点解释：\n1.  Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.\n2. 使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。\n3. 当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。\n4. aysncio.async(...)安排spin coroutine去运行，将其封装成Task对象后立即返回。\n5. Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。\n6. run_ until_ complete()会驱动coroutine运行，返回的结果是coroutine的返回值。\n\n```\n@asyncio.coroutine\ndef spin(msg):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        try:\n            yield from asyncio.sleep(.1)\n        except asyncio.CancelledError:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n@asyncio.coroutine\ndef slow_function():\n    yield from asyncio.sleep(3)\n    return 42\n\n@asyncio.coroutine\ndef supervisor():\n    spinner = asyncio.ensure_future(spin('thinking!'))\n    print('spinner object:', spinner)\n    result = yield from slow_function()\n    spinner.cancel()\n    return result\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(supervisor())\n    loop.close()\n    print('Answer:', result)\n```\n\n\n对比上面两个版本的demo,解释一下它们之间的区别：\n\n1. 一个Task驱动一个coroutine,一个线程调用一个callable.\n2. 我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(...)或者loop.create_ task(...)来获得Task对象。\n3. 当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。\n4. 在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。\n5. 没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。\n6. supervisor必须在main函数中通过loop.run_ until_ complete()调用。\n7. 在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。\n\n## How the asyncio.Future class differs from concurrent.futures.Future\n\n如果你还不清楚future的概念，你可以参考我写的另一篇文章[Python concurrency with futures](http://miks.top/2017/12/13/Python-concurrency-with-futures/)，里面有相关介绍，或者可以自行参考官方文档/wiki。\n\n请务必确认已经清楚了future的概念后再阅读下面内容 :)\n\nasyncio中的future：\n\n* asyncio中Task是Future的子类,故Task也是Future。\n* 对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。\n* 对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。\n* yield from my_ future 相当于 my_ future.add_ done_ callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。\n\n\nasyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。\n为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：\n\n1. aysncio.async(coro_or_future, *, loop=None)\n\n\t*  这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create_ task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get_ event_ loop()来的到一个loop对象。\n\n\t\n2. BaseEventLoop.create_task(coro)\n\n\t* 这个方法安排coroutine操作，并且返回一个asyncio.Task对象。\n\t\n几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数\n\n```\nimport asyncio\n\n\ndef run_sync(coro_or_future):\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(coro_or_future)\n\n\n@asyncio.coroutine\ndef coro():\n    yield from asyncio.sleep(1)\n\n\nif __name__ == '__main__':\n    a = run_sync(coro())\n```\n \t \n\n## Asynchronous programming manages high concurrency in network applications, without using threads or processes\n\n我们使用aiohttp这个第三方库来完善我们的Http Client。\n\n```\n\nimport asyncio\nimport aiohttp\nimport time\nimport os\nimport sys\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    session = aiohttp.ClientSession()\n    res = yield from session.get(url)\n    # res = yield from aiohttp.request('GET', url) will occur error with 'Unclosed client session'.\n    image = yield from res.read()\n    session.close()\n    return image\n\n\n@asyncio.coroutine\ndef download_one(cc):\n    image = yield from get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\n\n# @asyncio.coroutine\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()\n    to_do = [download_one(cc) for cc in sorted(cc_list)]\n    wait_coro = asyncio.wait(to_do)\n    res, _ = loop.run_until_complete(wait_coro)\n    loop.close()\n\n    return len(res)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\nCN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE \n19 flags download in 3.85s\n```\nasyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例\n当事件循环运行时，loop.run_ until_ complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。\n\n这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get_ flag里用yield from驱动aiohttp所以get_ flag是一个coroutine，同样在download_ one里用yield from驱动get_ flag所以它也是一个coroutine，最后在download_ many通过loop.run_ until_ complete来驱动被asyncio.wait()方法实例过的Tasks。\n\n可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：\n\n1. 每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.\n2. 链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。\n\n当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：\n驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run_ until_ complete(...) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。\n\n\n## How coroutines are a major improvement over callbacks for asynchronous programming\n\n\n通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？\n\n对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：\n1. 让阻塞操作在不同的线程中运行。\n2. 让用非阻塞的异步操作来调用阻塞操作。\n\n我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。\n\n使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。\n\n\n\n## How to avoid blocking the event loop by offloading blocking operations to a thread pool\n尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？\n在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。\n\n```\n@asyncio.coroutine\ndef download_one(cc, base_url, semaphore, verbose):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(base_url, cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.NOT_FOUND\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(None, save_flags, image, cc.lower() + '.gif') # Avoiding blocking.\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose and msg:\n        print(cc, msg)\n\n    return Result(status, cc)\n```\n\n\n## Callback Hell\n关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：\n\n```\ndef stage1(response1):\n    request2 = step1(response1)\n    api_call2(request2, stage2)\n\ndef stage2(response2):\n    request3 = step2(response2)\n    api_call3(request3, stage3)\n\ndef stage3(response3):\n    step(response3)\n\napi_call(request1, stage1)\n```\n\n分析一下这种风格的代码：\n读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。\n接下来我们再用coroutine来完成上述逻辑。\n\n```\n@asyncio.coroutine\ndef three_stages(request1):\n    response1 = yield from api_call1(request1)\n\n    request2 = step1(response1)\n    response2 = yield from api_call2(request2)\n    \n    request3 = step2(response2)\n    response3 = yield from api_call3(request3)\n    \n    step3(request3)\n```\n不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。\n\n尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。\n\n\n\n## Writing asyncio servers, and how to rethink Web applications for high concurrency \n接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。\n\n```\nimport sys\nimport asyncio\n\nfrom Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?>'\nindex = UnicodeNameIndex()\n\n@asyncio.coroutine\ndef handle_queries(reader, writer):\n    while True:\n        writer.write(PROMPT)\n        yield from writer.drain()\n        data = yield from reader.readline()\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            query = '\\x00'\n        client = writer.get_extra_info('peername')\n        print('Received from {}: {!r}'.format(client, query))\n        if query:\n            if ord(query[:1]) < 32:\n                break\n            lines = list(index.find_description_strs(query))\n            if lines:\n                writer.writelines(line.encode() + CRLF for line in lines)\n            writer.write(index.status(query, len(lines)).encode() + CRLF)\n\n            yield from writer.drain()\n            print('Sent {} results'.format(len(lines)))\n    print('Close the client socket')\n    writer.close()\n\ndef main(address='127.0.0.1', port=2323):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)\n    server = loop.run_until_complete(server_coro)\n\n    host = server.sockets[0].getsockname()\n    print('Serving on {} Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    loop.run_until_complete(server.wait_closed())\n    loop.close()\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n```\n希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。\n\nTips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).\n\n\n接下来再看一下http版本的：\n\n\n```\n@asyncio.coroutine\ndef init(loop, address, port):\n    app = web.Application(loop=loop)\n    app.router.add_route('GET', '/', home)\n    handler = app.make_handler()\n    server = yield from loop.create_server(handler, address, port)\n\n    return server.sockets[0].getsockname()\n\n\ndef main(address='127.0.0.1', port=8888):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    host = loop.run_until_complete(init(loop, address, port))\n    print('Servering on {}. Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n    print('Server shutting down.')\n    loop.close()\n\n\ndef home(request):\n    query = request.GET.get('query', '').strip()\n    print('Query: {!r}'.format(query))\n    if query:\n        descriptions = list(index.find_descriptions(query))\n        res = '\\n'.join(ROW_TPL.format(**vars(descr))\n                        for descr in descriptions)\n        msg = index.status(query, len(descriptions))\n\n    else:\n        descriptions = []\n        res = ''\n        msg = 'Enter words describing characters.'\n\n    html = template.format(query, res, msg)\n\n    print('Sending {} results'.format(len(descriptions)))\n    return web.Response(content_type=CONTENT_TYPE, text=html)\n```\n\n对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。\n\n\n## Parallelism and Concurrency\n给大家分享《Fluent Python》中的一则quote.\n\n*Concurrency is about dealing with lots of things at once.*\n\n*Parallelism is about doing lots of things at once.*\n\n*Not the same, but related.*\n\n*One is about structure, one is about execution.*\n\n*Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.*  \n\n\t\t\t\t\t\t\t\t\t-----Rob Pike\n\t\t\t\t\t\t\t\t\t\n这段quote揭示了中文里的**并行**和**并发**的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。\n\n对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).\n\n## Summary\n最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)\n\n本文代码地址：[asycnio_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo)\n\n","source":"_posts/Python-asyncio模块介绍.md","raw":"---\ntitle: Python asyncio模块介绍\ndate: 2017-12-19 23:00:51\ntags: Python\n\n---\n\n\n## Preface\n\n本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。\n\n注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。\n\n## A comparison between a simple threaded program and the asyncio equivalent\n\n我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。\n\nThread demo:\n\n```\nclass Signal:\n    go = True\n\n\ndef spin(msg, signal):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        time.sleep(.1)\n        if not signal.go:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n\ndef slow_function():\n    time.sleep(3)\n    return 42\n\n\ndef supervisor():\n    signal = Signal()\n    spinner = threading.Thread(target=spin,\n                               args=('thinkg!', signal))\n    print('spinner object:', spinner)\n    spinner.start()\n    result = slow_function()\n    signal.go = False\n    spinner.join()\n    return result\n\ndef main():\n    result = supervisor()\n    print('Answer:', result)\n因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。\n```\n注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。\n\n\n### 关于asyncio版本的代码做几点解释：\n1.  Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.\n2. 使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。\n3. 当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。\n4. aysncio.async(...)安排spin coroutine去运行，将其封装成Task对象后立即返回。\n5. Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。\n6. run_ until_ complete()会驱动coroutine运行，返回的结果是coroutine的返回值。\n\n```\n@asyncio.coroutine\ndef spin(msg):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        try:\n            yield from asyncio.sleep(.1)\n        except asyncio.CancelledError:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n@asyncio.coroutine\ndef slow_function():\n    yield from asyncio.sleep(3)\n    return 42\n\n@asyncio.coroutine\ndef supervisor():\n    spinner = asyncio.ensure_future(spin('thinking!'))\n    print('spinner object:', spinner)\n    result = yield from slow_function()\n    spinner.cancel()\n    return result\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(supervisor())\n    loop.close()\n    print('Answer:', result)\n```\n\n\n对比上面两个版本的demo,解释一下它们之间的区别：\n\n1. 一个Task驱动一个coroutine,一个线程调用一个callable.\n2. 我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(...)或者loop.create_ task(...)来获得Task对象。\n3. 当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。\n4. 在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。\n5. 没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。\n6. supervisor必须在main函数中通过loop.run_ until_ complete()调用。\n7. 在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。\n\n## How the asyncio.Future class differs from concurrent.futures.Future\n\n如果你还不清楚future的概念，你可以参考我写的另一篇文章[Python concurrency with futures](http://miks.top/2017/12/13/Python-concurrency-with-futures/)，里面有相关介绍，或者可以自行参考官方文档/wiki。\n\n请务必确认已经清楚了future的概念后再阅读下面内容 :)\n\nasyncio中的future：\n\n* asyncio中Task是Future的子类,故Task也是Future。\n* 对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。\n* 对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。\n* yield from my_ future 相当于 my_ future.add_ done_ callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。\n\n\nasyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。\n为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：\n\n1. aysncio.async(coro_or_future, *, loop=None)\n\n\t*  这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create_ task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get_ event_ loop()来的到一个loop对象。\n\n\t\n2. BaseEventLoop.create_task(coro)\n\n\t* 这个方法安排coroutine操作，并且返回一个asyncio.Task对象。\n\t\n几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数\n\n```\nimport asyncio\n\n\ndef run_sync(coro_or_future):\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(coro_or_future)\n\n\n@asyncio.coroutine\ndef coro():\n    yield from asyncio.sleep(1)\n\n\nif __name__ == '__main__':\n    a = run_sync(coro())\n```\n \t \n\n## Asynchronous programming manages high concurrency in network applications, without using threads or processes\n\n我们使用aiohttp这个第三方库来完善我们的Http Client。\n\n```\n\nimport asyncio\nimport aiohttp\nimport time\nimport os\nimport sys\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    session = aiohttp.ClientSession()\n    res = yield from session.get(url)\n    # res = yield from aiohttp.request('GET', url) will occur error with 'Unclosed client session'.\n    image = yield from res.read()\n    session.close()\n    return image\n\n\n@asyncio.coroutine\ndef download_one(cc):\n    image = yield from get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\n\n# @asyncio.coroutine\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()\n    to_do = [download_one(cc) for cc in sorted(cc_list)]\n    wait_coro = asyncio.wait(to_do)\n    res, _ = loop.run_until_complete(wait_coro)\n    loop.close()\n\n    return len(res)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\nCN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE \n19 flags download in 3.85s\n```\nasyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例\n当事件循环运行时，loop.run_ until_ complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。\n\n这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get_ flag里用yield from驱动aiohttp所以get_ flag是一个coroutine，同样在download_ one里用yield from驱动get_ flag所以它也是一个coroutine，最后在download_ many通过loop.run_ until_ complete来驱动被asyncio.wait()方法实例过的Tasks。\n\n可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：\n\n1. 每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.\n2. 链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。\n\n当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：\n驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run_ until_ complete(...) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。\n\n\n## How coroutines are a major improvement over callbacks for asynchronous programming\n\n\n通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？\n\n对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：\n1. 让阻塞操作在不同的线程中运行。\n2. 让用非阻塞的异步操作来调用阻塞操作。\n\n我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。\n\n使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。\n\n\n\n## How to avoid blocking the event loop by offloading blocking operations to a thread pool\n尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？\n在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。\n\n```\n@asyncio.coroutine\ndef download_one(cc, base_url, semaphore, verbose):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(base_url, cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.NOT_FOUND\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(None, save_flags, image, cc.lower() + '.gif') # Avoiding blocking.\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose and msg:\n        print(cc, msg)\n\n    return Result(status, cc)\n```\n\n\n## Callback Hell\n关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：\n\n```\ndef stage1(response1):\n    request2 = step1(response1)\n    api_call2(request2, stage2)\n\ndef stage2(response2):\n    request3 = step2(response2)\n    api_call3(request3, stage3)\n\ndef stage3(response3):\n    step(response3)\n\napi_call(request1, stage1)\n```\n\n分析一下这种风格的代码：\n读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。\n接下来我们再用coroutine来完成上述逻辑。\n\n```\n@asyncio.coroutine\ndef three_stages(request1):\n    response1 = yield from api_call1(request1)\n\n    request2 = step1(response1)\n    response2 = yield from api_call2(request2)\n    \n    request3 = step2(response2)\n    response3 = yield from api_call3(request3)\n    \n    step3(request3)\n```\n不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。\n\n尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。\n\n\n\n## Writing asyncio servers, and how to rethink Web applications for high concurrency \n接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。\n\n```\nimport sys\nimport asyncio\n\nfrom Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?>'\nindex = UnicodeNameIndex()\n\n@asyncio.coroutine\ndef handle_queries(reader, writer):\n    while True:\n        writer.write(PROMPT)\n        yield from writer.drain()\n        data = yield from reader.readline()\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            query = '\\x00'\n        client = writer.get_extra_info('peername')\n        print('Received from {}: {!r}'.format(client, query))\n        if query:\n            if ord(query[:1]) < 32:\n                break\n            lines = list(index.find_description_strs(query))\n            if lines:\n                writer.writelines(line.encode() + CRLF for line in lines)\n            writer.write(index.status(query, len(lines)).encode() + CRLF)\n\n            yield from writer.drain()\n            print('Sent {} results'.format(len(lines)))\n    print('Close the client socket')\n    writer.close()\n\ndef main(address='127.0.0.1', port=2323):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)\n    server = loop.run_until_complete(server_coro)\n\n    host = server.sockets[0].getsockname()\n    print('Serving on {} Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    loop.run_until_complete(server.wait_closed())\n    loop.close()\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n```\n希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。\n\nTips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).\n\n\n接下来再看一下http版本的：\n\n\n```\n@asyncio.coroutine\ndef init(loop, address, port):\n    app = web.Application(loop=loop)\n    app.router.add_route('GET', '/', home)\n    handler = app.make_handler()\n    server = yield from loop.create_server(handler, address, port)\n\n    return server.sockets[0].getsockname()\n\n\ndef main(address='127.0.0.1', port=8888):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    host = loop.run_until_complete(init(loop, address, port))\n    print('Servering on {}. Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n    print('Server shutting down.')\n    loop.close()\n\n\ndef home(request):\n    query = request.GET.get('query', '').strip()\n    print('Query: {!r}'.format(query))\n    if query:\n        descriptions = list(index.find_descriptions(query))\n        res = '\\n'.join(ROW_TPL.format(**vars(descr))\n                        for descr in descriptions)\n        msg = index.status(query, len(descriptions))\n\n    else:\n        descriptions = []\n        res = ''\n        msg = 'Enter words describing characters.'\n\n    html = template.format(query, res, msg)\n\n    print('Sending {} results'.format(len(descriptions)))\n    return web.Response(content_type=CONTENT_TYPE, text=html)\n```\n\n对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。\n\n\n## Parallelism and Concurrency\n给大家分享《Fluent Python》中的一则quote.\n\n*Concurrency is about dealing with lots of things at once.*\n\n*Parallelism is about doing lots of things at once.*\n\n*Not the same, but related.*\n\n*One is about structure, one is about execution.*\n\n*Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.*  \n\n\t\t\t\t\t\t\t\t\t-----Rob Pike\n\t\t\t\t\t\t\t\t\t\n这段quote揭示了中文里的**并行**和**并发**的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。\n\n对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).\n\n## Summary\n最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)\n\n本文代码地址：[asycnio_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo)\n\n","slug":"Python-asyncio模块介绍","published":1,"updated":"2018-01-25T13:04:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkx002cvmvv7hfrrnh2","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。</p>\n<p>注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。</p>\n<h2 id=\"A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\"><a href=\"#A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\" class=\"headerlink\" title=\"A comparison between a simple threaded program and the asyncio equivalent\"></a>A comparison between a simple threaded program and the asyncio equivalent</h2><p>我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。</p>\n<p>Thread demo:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Signal:</div><div class=\"line\">    go = True</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def spin(msg, signal):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        time.sleep(.1)</div><div class=\"line\">        if not signal.go:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def slow_function():</div><div class=\"line\">    time.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def supervisor():</div><div class=\"line\">    signal = Signal()</div><div class=\"line\">    spinner = threading.Thread(target=spin,</div><div class=\"line\">                               args=(&apos;thinkg!&apos;, signal))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    spinner.start()</div><div class=\"line\">    result = slow_function()</div><div class=\"line\">    signal.go = False</div><div class=\"line\">    spinner.join()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    result = supervisor()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div><div class=\"line\">因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。</div></pre></td></tr></table></figure>\n<p>注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。</p>\n<h3 id=\"关于asyncio版本的代码做几点解释：\"><a href=\"#关于asyncio版本的代码做几点解释：\" class=\"headerlink\" title=\"关于asyncio版本的代码做几点解释：\"></a>关于asyncio版本的代码做几点解释：</h3><ol>\n<li>Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.</li>\n<li>使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。</li>\n<li>当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。</li>\n<li>aysncio.async(…)安排spin coroutine去运行，将其封装成Task对象后立即返回。</li>\n<li>Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。</li>\n<li>run<em> until</em> complete()会驱动coroutine运行，返回的结果是coroutine的返回值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def spin(msg):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        try:</div><div class=\"line\">            yield from asyncio.sleep(.1)</div><div class=\"line\">        except asyncio.CancelledError:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def slow_function():</div><div class=\"line\">    yield from asyncio.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def supervisor():</div><div class=\"line\">    spinner = asyncio.ensure_future(spin(&apos;thinking!&apos;))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    result = yield from slow_function()</div><div class=\"line\">    spinner.cancel()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    result = loop.run_until_complete(supervisor())</div><div class=\"line\">    loop.close()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div></pre></td></tr></table></figure>\n<p>对比上面两个版本的demo,解释一下它们之间的区别：</p>\n<ol>\n<li>一个Task驱动一个coroutine,一个线程调用一个callable.</li>\n<li>我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(…)或者loop.create_ task(…)来获得Task对象。</li>\n<li>当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。</li>\n<li>在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。</li>\n<li>没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。</li>\n<li>supervisor必须在main函数中通过loop.run<em> until</em> complete()调用。</li>\n<li>在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。</li>\n</ol>\n<h2 id=\"How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\"><a href=\"#How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\" class=\"headerlink\" title=\"How the asyncio.Future class differs from concurrent.futures.Future\"></a>How the asyncio.Future class differs from concurrent.futures.Future</h2><p>如果你还不清楚future的概念，你可以参考我写的另一篇文章<a href=\"http://miks.top/2017/12/13/Python-concurrency-with-futures/\">Python concurrency with futures</a>，里面有相关介绍，或者可以自行参考官方文档/wiki。</p>\n<p>请务必确认已经清楚了future的概念后再阅读下面内容 :)</p>\n<p>asyncio中的future：</p>\n<ul>\n<li>asyncio中Task是Future的子类,故Task也是Future。</li>\n<li>对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。</li>\n<li>对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。</li>\n<li>yield from my<em> future 相当于 my</em> future.add<em> done</em> callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。</li>\n</ul>\n<p>asyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。<br>为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：</p>\n<ol>\n<li><p>aysncio.async(coro_or_future, *, loop=None)</p>\n<ul>\n<li>这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create<em> task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get</em> event_ loop()来的到一个loop对象。</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>BaseEventLoop.create_task(coro)</p>\n<ul>\n<li>这个方法安排coroutine操作，并且返回一个asyncio.Task对象。</li>\n</ul>\n</li>\n</ol>\n<p>几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run_sync(coro_or_future):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    return loop.run_until_complete(coro_or_future)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def coro():</div><div class=\"line\">    yield from asyncio.sleep(1)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    a = run_sync(coro())</div></pre></td></tr></table></figure>\n<h2 id=\"Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\"><a href=\"#Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\" class=\"headerlink\" title=\"Asynchronous programming manages high concurrency in network applications, without using threads or processes\"></a>Asynchronous programming manages high concurrency in network applications, without using threads or processes</h2><p>我们使用aiohttp这个第三方库来完善我们的Http Client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import asyncio</div><div class=\"line\">import aiohttp</div><div class=\"line\">import time</div><div class=\"line\">import os</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    session = aiohttp.ClientSession()</div><div class=\"line\">    res = yield from session.get(url)</div><div class=\"line\">    # res = yield from aiohttp.request(&apos;GET&apos;, url) will occur error with &apos;Unclosed client session&apos;.</div><div class=\"line\">    image = yield from res.read()</div><div class=\"line\">    session.close()</div><div class=\"line\">    return image</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = yield from get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># @asyncio.coroutine</div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    to_do = [download_one(cc) for cc in sorted(cc_list)]</div><div class=\"line\">    wait_coro = asyncio.wait(to_do)</div><div class=\"line\">    res, _ = loop.run_until_complete(wait_coro)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\">    return len(res)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\">CN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE </div><div class=\"line\">19 flags download in 3.85s</div></pre></td></tr></table></figure>\n<p>asyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例<br>当事件循环运行时，loop.run<em> until</em> complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。</p>\n<p>这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get<em> flag里用yield from驱动aiohttp所以get</em> flag是一个coroutine，同样在download<em> one里用yield from驱动get</em> flag所以它也是一个coroutine，最后在download<em> many通过loop.run</em> until_ complete来驱动被asyncio.wait()方法实例过的Tasks。</p>\n<p>可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：</p>\n<ol>\n<li>每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.</li>\n<li>链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。</li>\n</ol>\n<p>当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：<br>驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run<em> until</em> complete(…) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。</p>\n<h2 id=\"How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\"><a href=\"#How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\" class=\"headerlink\" title=\"How coroutines are a major improvement over callbacks for asynchronous programming\"></a>How coroutines are a major improvement over callbacks for asynchronous programming</h2><p>通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？</p>\n<p>对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：</p>\n<ol>\n<li>让阻塞操作在不同的线程中运行。</li>\n<li>让用非阻塞的异步操作来调用阻塞操作。</li>\n</ol>\n<p>我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。</p>\n<p>使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。</p>\n<h2 id=\"How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool\"><a href=\"#How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool\" class=\"headerlink\" title=\"How to avoid blocking the event loop by offloading blocking operations to a thread pool\"></a>How to avoid blocking the event loop by offloading blocking operations to a thread pool</h2><p>尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？<br>在asyncio中，有一个thread pool executor，我们可以将callable通过run <em>in </em> executor()传递。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc, base_url, semaphore, verbose):</div><div class=\"line\">    try:</div><div class=\"line\">        with (yield from semaphore):</div><div class=\"line\">            image = yield from get_flag(base_url, cc)</div><div class=\"line\">    except web.HTTPNotFound:</div><div class=\"line\">        status = HTTPStatus.NOT_FOUND</div><div class=\"line\">        msg = &apos;not found&apos;</div><div class=\"line\">    except Exception as exc:</div><div class=\"line\">        raise FetchError(cc) from exc</div><div class=\"line\">    else:</div><div class=\"line\">        loop = asyncio.get_event_loop()</div><div class=\"line\">        loop.run_in_executor(None, save_flags, image, cc.lower() + &apos;.gif&apos;) # Avoiding blocking.</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose and msg:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div></pre></td></tr></table></figure>\n<h2 id=\"Callback-Hell\"><a href=\"#Callback-Hell\" class=\"headerlink\" title=\"Callback Hell\"></a>Callback Hell</h2><p>关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def stage1(response1):</div><div class=\"line\">    request2 = step1(response1)</div><div class=\"line\">    api_call2(request2, stage2)</div><div class=\"line\"></div><div class=\"line\">def stage2(response2):</div><div class=\"line\">    request3 = step2(response2)</div><div class=\"line\">    api_call3(request3, stage3)</div><div class=\"line\"></div><div class=\"line\">def stage3(response3):</div><div class=\"line\">    step(response3)</div><div class=\"line\"></div><div class=\"line\">api_call(request1, stage1)</div></pre></td></tr></table></figure>\n<p>分析一下这种风格的代码：<br>读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。<br>接下来我们再用coroutine来完成上述逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def three_stages(request1):</div><div class=\"line\">    response1 = yield from api_call1(request1)</div><div class=\"line\"></div><div class=\"line\">    request2 = step1(response1)</div><div class=\"line\">    response2 = yield from api_call2(request2)</div><div class=\"line\">    </div><div class=\"line\">    request3 = step2(response2)</div><div class=\"line\">    response3 = yield from api_call3(request3)</div><div class=\"line\">    </div><div class=\"line\">    step3(request3)</div></pre></td></tr></table></figure>\n<p>不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</p>\n<p>尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create<em> task(three</em> stages(request1))来调用。</p>\n<h2 id=\"Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency\"><a href=\"#Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency\" class=\"headerlink\" title=\"Writing asyncio servers, and how to rethink Web applications for high concurrency\"></a>Writing asyncio servers, and how to rethink Web applications for high concurrency</h2><p>接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">import sys</div><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</div><div class=\"line\"></div><div class=\"line\">CRLF = b&apos;\\r\\n&apos;</div><div class=\"line\">PROMPT = b&apos;?&gt;&apos;</div><div class=\"line\">index = UnicodeNameIndex()</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def handle_queries(reader, writer):</div><div class=\"line\">    while True:</div><div class=\"line\">        writer.write(PROMPT)</div><div class=\"line\">        yield from writer.drain()</div><div class=\"line\">        data = yield from reader.readline()</div><div class=\"line\">        try:</div><div class=\"line\">            query = data.decode().strip()</div><div class=\"line\">        except UnicodeDecodeError:</div><div class=\"line\">            query = &apos;\\x00&apos;</div><div class=\"line\">        client = writer.get_extra_info(&apos;peername&apos;)</div><div class=\"line\">        print(&apos;Received from &#123;&#125;: &#123;!r&#125;&apos;.format(client, query))</div><div class=\"line\">        if query:</div><div class=\"line\">            if ord(query[:1]) &lt; 32:</div><div class=\"line\">                break</div><div class=\"line\">            lines = list(index.find_description_strs(query))</div><div class=\"line\">            if lines:</div><div class=\"line\">                writer.writelines(line.encode() + CRLF for line in lines)</div><div class=\"line\">            writer.write(index.status(query, len(lines)).encode() + CRLF)</div><div class=\"line\"></div><div class=\"line\">            yield from writer.drain()</div><div class=\"line\">            print(&apos;Sent &#123;&#125; results&apos;.format(len(lines)))</div><div class=\"line\">    print(&apos;Close the client socket&apos;)</div><div class=\"line\">    writer.close()</div><div class=\"line\"></div><div class=\"line\">def main(address=&apos;127.0.0.1&apos;, port=2323):</div><div class=\"line\">    port = int(port)</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)</div><div class=\"line\">    server = loop.run_until_complete(server_coro)</div><div class=\"line\"></div><div class=\"line\">    host = server.sockets[0].getsockname()</div><div class=\"line\">    print(&apos;Serving on &#123;&#125; Hit CTRL-C to stop.&apos;.format(host))</div><div class=\"line\">    try:</div><div class=\"line\">        loop.run_forever()</div><div class=\"line\">    except KeyboardInterrupt:</div><div class=\"line\">        pass</div><div class=\"line\"></div><div class=\"line\">    print(&apos;Server shutting down.&apos;)</div><div class=\"line\">    server.close()</div><div class=\"line\">    loop.run_until_complete(server.wait_closed())</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(*sys.argv[1:])</div></pre></td></tr></table></figure>\n<p>希望你尝试运行上面的代码后再继续阅读，用loop.run<em> forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle</em> queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</p>\n<p>Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</p>\n<p>接下来再看一下http版本的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def init(loop, address, port):</div><div class=\"line\">    app = web.Application(loop=loop)</div><div class=\"line\">    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, home)</div><div class=\"line\">    handler = app.make_handler()</div><div class=\"line\">    server = yield from loop.create_server(handler, address, port)</div><div class=\"line\"></div><div class=\"line\">    return server.sockets[0].getsockname()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(address=&apos;127.0.0.1&apos;, port=8888):</div><div class=\"line\">    port = int(port)</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    host = loop.run_until_complete(init(loop, address, port))</div><div class=\"line\">    print(&apos;Servering on &#123;&#125;. Hit CTRL-C to stop.&apos;.format(host))</div><div class=\"line\">    try:</div><div class=\"line\">        loop.run_forever()</div><div class=\"line\">    except KeyboardInterrupt:</div><div class=\"line\">        pass</div><div class=\"line\">    print(&apos;Server shutting down.&apos;)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def home(request):</div><div class=\"line\">    query = request.GET.get(&apos;query&apos;, &apos;&apos;).strip()</div><div class=\"line\">    print(&apos;Query: &#123;!r&#125;&apos;.format(query))</div><div class=\"line\">    if query:</div><div class=\"line\">        descriptions = list(index.find_descriptions(query))</div><div class=\"line\">        res = &apos;\\n&apos;.join(ROW_TPL.format(**vars(descr))</div><div class=\"line\">                        for descr in descriptions)</div><div class=\"line\">        msg = index.status(query, len(descriptions))</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        descriptions = []</div><div class=\"line\">        res = &apos;&apos;</div><div class=\"line\">        msg = &apos;Enter words describing characters.&apos;</div><div class=\"line\"></div><div class=\"line\">    html = template.format(query, res, msg)</div><div class=\"line\"></div><div class=\"line\">    print(&apos;Sending &#123;&#125; results&apos;.format(len(descriptions)))</div><div class=\"line\">    return web.Response(content_type=CONTENT_TYPE, text=html)</div></pre></td></tr></table></figure>\n<p>对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。</p>\n<h2 id=\"Parallelism-and-Concurrency\"><a href=\"#Parallelism-and-Concurrency\" class=\"headerlink\" title=\"Parallelism and Concurrency\"></a>Parallelism and Concurrency</h2><p>给大家分享《Fluent Python》中的一则quote.</p>\n<p><em>Concurrency is about dealing with lots of things at once.</em></p>\n<p><em>Parallelism is about doing lots of things at once.</em></p>\n<p><em>Not the same, but related.</em></p>\n<p><em>One is about structure, one is about execution.</em></p>\n<p><em>Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.</em>  </p>\n<pre><code>-----Rob Pike\n</code></pre><p>这段quote揭示了中文里的<strong>并行</strong>和<strong>并发</strong>的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。</p>\n<p>对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo\" target=\"_blank\" rel=\"external\">asycnio_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。</p>\n<p>注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。</p>\n<h2 id=\"A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\"><a href=\"#A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\" class=\"headerlink\" title=\"A comparison between a simple threaded program and the asyncio equivalent\"></a>A comparison between a simple threaded program and the asyncio equivalent</h2><p>我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。</p>\n<p>Thread demo:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Signal:</div><div class=\"line\">    go = True</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def spin(msg, signal):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        time.sleep(.1)</div><div class=\"line\">        if not signal.go:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def slow_function():</div><div class=\"line\">    time.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def supervisor():</div><div class=\"line\">    signal = Signal()</div><div class=\"line\">    spinner = threading.Thread(target=spin,</div><div class=\"line\">                               args=(&apos;thinkg!&apos;, signal))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    spinner.start()</div><div class=\"line\">    result = slow_function()</div><div class=\"line\">    signal.go = False</div><div class=\"line\">    spinner.join()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    result = supervisor()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div><div class=\"line\">因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。</div></pre></td></tr></table></figure>\n<p>注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。</p>\n<h3 id=\"关于asyncio版本的代码做几点解释：\"><a href=\"#关于asyncio版本的代码做几点解释：\" class=\"headerlink\" title=\"关于asyncio版本的代码做几点解释：\"></a>关于asyncio版本的代码做几点解释：</h3><ol>\n<li>Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.</li>\n<li>使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。</li>\n<li>当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。</li>\n<li>aysncio.async(…)安排spin coroutine去运行，将其封装成Task对象后立即返回。</li>\n<li>Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。</li>\n<li>run<em> until</em> complete()会驱动coroutine运行，返回的结果是coroutine的返回值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def spin(msg):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        try:</div><div class=\"line\">            yield from asyncio.sleep(.1)</div><div class=\"line\">        except asyncio.CancelledError:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def slow_function():</div><div class=\"line\">    yield from asyncio.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def supervisor():</div><div class=\"line\">    spinner = asyncio.ensure_future(spin(&apos;thinking!&apos;))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    result = yield from slow_function()</div><div class=\"line\">    spinner.cancel()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    result = loop.run_until_complete(supervisor())</div><div class=\"line\">    loop.close()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div></pre></td></tr></table></figure>\n<p>对比上面两个版本的demo,解释一下它们之间的区别：</p>\n<ol>\n<li>一个Task驱动一个coroutine,一个线程调用一个callable.</li>\n<li>我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(…)或者loop.create_ task(…)来获得Task对象。</li>\n<li>当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。</li>\n<li>在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。</li>\n<li>没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。</li>\n<li>supervisor必须在main函数中通过loop.run<em> until</em> complete()调用。</li>\n<li>在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。</li>\n</ol>\n<h2 id=\"How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\"><a href=\"#How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\" class=\"headerlink\" title=\"How the asyncio.Future class differs from concurrent.futures.Future\"></a>How the asyncio.Future class differs from concurrent.futures.Future</h2><p>如果你还不清楚future的概念，你可以参考我写的另一篇文章<a href=\"http://miks.top/2017/12/13/Python-concurrency-with-futures/\">Python concurrency with futures</a>，里面有相关介绍，或者可以自行参考官方文档/wiki。</p>\n<p>请务必确认已经清楚了future的概念后再阅读下面内容 :)</p>\n<p>asyncio中的future：</p>\n<ul>\n<li>asyncio中Task是Future的子类,故Task也是Future。</li>\n<li>对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。</li>\n<li>对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。</li>\n<li>yield from my<em> future 相当于 my</em> future.add<em> done</em> callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。</li>\n</ul>\n<p>asyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。<br>为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：</p>\n<ol>\n<li><p>aysncio.async(coro_or_future, *, loop=None)</p>\n<ul>\n<li>这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create<em> task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get</em> event_ loop()来的到一个loop对象。</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>BaseEventLoop.create_task(coro)</p>\n<ul>\n<li>这个方法安排coroutine操作，并且返回一个asyncio.Task对象。</li>\n</ul>\n</li>\n</ol>\n<p>几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run_sync(coro_or_future):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    return loop.run_until_complete(coro_or_future)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def coro():</div><div class=\"line\">    yield from asyncio.sleep(1)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    a = run_sync(coro())</div></pre></td></tr></table></figure>\n<h2 id=\"Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\"><a href=\"#Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\" class=\"headerlink\" title=\"Asynchronous programming manages high concurrency in network applications, without using threads or processes\"></a>Asynchronous programming manages high concurrency in network applications, without using threads or processes</h2><p>我们使用aiohttp这个第三方库来完善我们的Http Client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import asyncio</div><div class=\"line\">import aiohttp</div><div class=\"line\">import time</div><div class=\"line\">import os</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    session = aiohttp.ClientSession()</div><div class=\"line\">    res = yield from session.get(url)</div><div class=\"line\">    # res = yield from aiohttp.request(&apos;GET&apos;, url) will occur error with &apos;Unclosed client session&apos;.</div><div class=\"line\">    image = yield from res.read()</div><div class=\"line\">    session.close()</div><div class=\"line\">    return image</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = yield from get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># @asyncio.coroutine</div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    to_do = [download_one(cc) for cc in sorted(cc_list)]</div><div class=\"line\">    wait_coro = asyncio.wait(to_do)</div><div class=\"line\">    res, _ = loop.run_until_complete(wait_coro)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\">    return len(res)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\">CN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE </div><div class=\"line\">19 flags download in 3.85s</div></pre></td></tr></table></figure>\n<p>asyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例<br>当事件循环运行时，loop.run<em> until</em> complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。</p>\n<p>这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get<em> flag里用yield from驱动aiohttp所以get</em> flag是一个coroutine，同样在download<em> one里用yield from驱动get</em> flag所以它也是一个coroutine，最后在download<em> many通过loop.run</em> until_ complete来驱动被asyncio.wait()方法实例过的Tasks。</p>\n<p>可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：</p>\n<ol>\n<li>每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.</li>\n<li>链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。</li>\n</ol>\n<p>当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：<br>驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run<em> until</em> complete(…) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。</p>\n<h2 id=\"How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\"><a href=\"#How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\" class=\"headerlink\" title=\"How coroutines are a major improvement over callbacks for asynchronous programming\"></a>How coroutines are a major improvement over callbacks for asynchronous programming</h2><p>通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？</p>\n<p>对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：</p>\n<ol>\n<li>让阻塞操作在不同的线程中运行。</li>\n<li>让用非阻塞的异步操作来调用阻塞操作。</li>\n</ol>\n<p>我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。</p>\n<p>使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。</p>\n<h2 id=\"How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool\"><a href=\"#How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool\" class=\"headerlink\" title=\"How to avoid blocking the event loop by offloading blocking operations to a thread pool\"></a>How to avoid blocking the event loop by offloading blocking operations to a thread pool</h2><p>尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？<br>在asyncio中，有一个thread pool executor，我们可以将callable通过run <em>in </em> executor()传递。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc, base_url, semaphore, verbose):</div><div class=\"line\">    try:</div><div class=\"line\">        with (yield from semaphore):</div><div class=\"line\">            image = yield from get_flag(base_url, cc)</div><div class=\"line\">    except web.HTTPNotFound:</div><div class=\"line\">        status = HTTPStatus.NOT_FOUND</div><div class=\"line\">        msg = &apos;not found&apos;</div><div class=\"line\">    except Exception as exc:</div><div class=\"line\">        raise FetchError(cc) from exc</div><div class=\"line\">    else:</div><div class=\"line\">        loop = asyncio.get_event_loop()</div><div class=\"line\">        loop.run_in_executor(None, save_flags, image, cc.lower() + &apos;.gif&apos;) # Avoiding blocking.</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose and msg:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div></pre></td></tr></table></figure>\n<h2 id=\"Callback-Hell\"><a href=\"#Callback-Hell\" class=\"headerlink\" title=\"Callback Hell\"></a>Callback Hell</h2><p>关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def stage1(response1):</div><div class=\"line\">    request2 = step1(response1)</div><div class=\"line\">    api_call2(request2, stage2)</div><div class=\"line\"></div><div class=\"line\">def stage2(response2):</div><div class=\"line\">    request3 = step2(response2)</div><div class=\"line\">    api_call3(request3, stage3)</div><div class=\"line\"></div><div class=\"line\">def stage3(response3):</div><div class=\"line\">    step(response3)</div><div class=\"line\"></div><div class=\"line\">api_call(request1, stage1)</div></pre></td></tr></table></figure>\n<p>分析一下这种风格的代码：<br>读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。<br>接下来我们再用coroutine来完成上述逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def three_stages(request1):</div><div class=\"line\">    response1 = yield from api_call1(request1)</div><div class=\"line\"></div><div class=\"line\">    request2 = step1(response1)</div><div class=\"line\">    response2 = yield from api_call2(request2)</div><div class=\"line\">    </div><div class=\"line\">    request3 = step2(response2)</div><div class=\"line\">    response3 = yield from api_call3(request3)</div><div class=\"line\">    </div><div class=\"line\">    step3(request3)</div></pre></td></tr></table></figure>\n<p>不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</p>\n<p>尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create<em> task(three</em> stages(request1))来调用。</p>\n<h2 id=\"Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency\"><a href=\"#Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency\" class=\"headerlink\" title=\"Writing asyncio servers, and how to rethink Web applications for high concurrency\"></a>Writing asyncio servers, and how to rethink Web applications for high concurrency</h2><p>接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">import sys</div><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</div><div class=\"line\"></div><div class=\"line\">CRLF = b&apos;\\r\\n&apos;</div><div class=\"line\">PROMPT = b&apos;?&gt;&apos;</div><div class=\"line\">index = UnicodeNameIndex()</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def handle_queries(reader, writer):</div><div class=\"line\">    while True:</div><div class=\"line\">        writer.write(PROMPT)</div><div class=\"line\">        yield from writer.drain()</div><div class=\"line\">        data = yield from reader.readline()</div><div class=\"line\">        try:</div><div class=\"line\">            query = data.decode().strip()</div><div class=\"line\">        except UnicodeDecodeError:</div><div class=\"line\">            query = &apos;\\x00&apos;</div><div class=\"line\">        client = writer.get_extra_info(&apos;peername&apos;)</div><div class=\"line\">        print(&apos;Received from &#123;&#125;: &#123;!r&#125;&apos;.format(client, query))</div><div class=\"line\">        if query:</div><div class=\"line\">            if ord(query[:1]) &lt; 32:</div><div class=\"line\">                break</div><div class=\"line\">            lines = list(index.find_description_strs(query))</div><div class=\"line\">            if lines:</div><div class=\"line\">                writer.writelines(line.encode() + CRLF for line in lines)</div><div class=\"line\">            writer.write(index.status(query, len(lines)).encode() + CRLF)</div><div class=\"line\"></div><div class=\"line\">            yield from writer.drain()</div><div class=\"line\">            print(&apos;Sent &#123;&#125; results&apos;.format(len(lines)))</div><div class=\"line\">    print(&apos;Close the client socket&apos;)</div><div class=\"line\">    writer.close()</div><div class=\"line\"></div><div class=\"line\">def main(address=&apos;127.0.0.1&apos;, port=2323):</div><div class=\"line\">    port = int(port)</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)</div><div class=\"line\">    server = loop.run_until_complete(server_coro)</div><div class=\"line\"></div><div class=\"line\">    host = server.sockets[0].getsockname()</div><div class=\"line\">    print(&apos;Serving on &#123;&#125; Hit CTRL-C to stop.&apos;.format(host))</div><div class=\"line\">    try:</div><div class=\"line\">        loop.run_forever()</div><div class=\"line\">    except KeyboardInterrupt:</div><div class=\"line\">        pass</div><div class=\"line\"></div><div class=\"line\">    print(&apos;Server shutting down.&apos;)</div><div class=\"line\">    server.close()</div><div class=\"line\">    loop.run_until_complete(server.wait_closed())</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(*sys.argv[1:])</div></pre></td></tr></table></figure>\n<p>希望你尝试运行上面的代码后再继续阅读，用loop.run<em> forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle</em> queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</p>\n<p>Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</p>\n<p>接下来再看一下http版本的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def init(loop, address, port):</div><div class=\"line\">    app = web.Application(loop=loop)</div><div class=\"line\">    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, home)</div><div class=\"line\">    handler = app.make_handler()</div><div class=\"line\">    server = yield from loop.create_server(handler, address, port)</div><div class=\"line\"></div><div class=\"line\">    return server.sockets[0].getsockname()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(address=&apos;127.0.0.1&apos;, port=8888):</div><div class=\"line\">    port = int(port)</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    host = loop.run_until_complete(init(loop, address, port))</div><div class=\"line\">    print(&apos;Servering on &#123;&#125;. Hit CTRL-C to stop.&apos;.format(host))</div><div class=\"line\">    try:</div><div class=\"line\">        loop.run_forever()</div><div class=\"line\">    except KeyboardInterrupt:</div><div class=\"line\">        pass</div><div class=\"line\">    print(&apos;Server shutting down.&apos;)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def home(request):</div><div class=\"line\">    query = request.GET.get(&apos;query&apos;, &apos;&apos;).strip()</div><div class=\"line\">    print(&apos;Query: &#123;!r&#125;&apos;.format(query))</div><div class=\"line\">    if query:</div><div class=\"line\">        descriptions = list(index.find_descriptions(query))</div><div class=\"line\">        res = &apos;\\n&apos;.join(ROW_TPL.format(**vars(descr))</div><div class=\"line\">                        for descr in descriptions)</div><div class=\"line\">        msg = index.status(query, len(descriptions))</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        descriptions = []</div><div class=\"line\">        res = &apos;&apos;</div><div class=\"line\">        msg = &apos;Enter words describing characters.&apos;</div><div class=\"line\"></div><div class=\"line\">    html = template.format(query, res, msg)</div><div class=\"line\"></div><div class=\"line\">    print(&apos;Sending &#123;&#125; results&apos;.format(len(descriptions)))</div><div class=\"line\">    return web.Response(content_type=CONTENT_TYPE, text=html)</div></pre></td></tr></table></figure>\n<p>对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。</p>\n<h2 id=\"Parallelism-and-Concurrency\"><a href=\"#Parallelism-and-Concurrency\" class=\"headerlink\" title=\"Parallelism and Concurrency\"></a>Parallelism and Concurrency</h2><p>给大家分享《Fluent Python》中的一则quote.</p>\n<p><em>Concurrency is about dealing with lots of things at once.</em></p>\n<p><em>Parallelism is about doing lots of things at once.</em></p>\n<p><em>Not the same, but related.</em></p>\n<p><em>One is about structure, one is about execution.</em></p>\n<p><em>Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.</em>  </p>\n<pre><code>-----Rob Pike\n</code></pre><p>这段quote揭示了中文里的<strong>并行</strong>和<strong>并发</strong>的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。</p>\n<p>对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo\" target=\"_blank\" rel=\"external\">asycnio_demo</a></p>\n"},{"title":"python实现计算机网络rip协议 Report","date":"2017-06-01T07:27:45.000Z","_content":"一、实验目的\n\n\n了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。\n\n\n二、打印结果\n\n\n输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 \n\n\n\n\n输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。\n\n\n\n\n输入第二个路由器的路由表。\n\n\n\n\n遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。\n\n\n三、程序代码\n\n\ngithub:\nhttps://github.com/Miksztowi/CorePython/blob/master/rip.py\n\n","source":"_posts/python实现计算机网络rip协议.md","raw":"---\ntitle: python实现计算机网络rip协议 Report\ndate: 2017-06-01 15:27:45\ntags: daily report\n---\n一、实验目的\n\n\n了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。\n\n\n二、打印结果\n\n\n输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 \n\n\n\n\n输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。\n\n\n\n\n输入第二个路由器的路由表。\n\n\n\n\n遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。\n\n\n三、程序代码\n\n\ngithub:\nhttps://github.com/Miksztowi/CorePython/blob/master/rip.py\n\n","slug":"python实现计算机网络rip协议","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwkx002fvmvvp757scvl","content":"<p>一、实验目的</p>\n<p>了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。</p>\n<p>二、打印结果</p>\n<p>输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 </p>\n<p>输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。</p>\n<p>输入第二个路由器的路由表。</p>\n<p>遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。</p>\n<p>三、程序代码</p>\n<p>github:<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/rip.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/rip.py</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、实验目的</p>\n<p>了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。</p>\n<p>二、打印结果</p>\n<p>输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 </p>\n<p>输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。</p>\n<p>输入第二个路由器的路由表。</p>\n<p>遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。</p>\n<p>三、程序代码</p>\n<p>github:<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/rip.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/rip.py</a></p>\n"},{"title":"检查清单 Report","date":"2017-11-04T07:27:45.000Z","_content":"写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，并集|，交集&，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n用assert 来确定数据是可用的(assert A,B = if not A do B)\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n\n\n团队沟通\n\n\n换位思考，从对方的思路开始思考，先明白对方问题的原因。\n\n\n不仅要有自己的想法，还要对于想法有可行的方案。\n\n\n前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！\n\n\nHTML操作\n\n\nw3lib.html.remove_tags()可以过滤Html标签。\n\n","source":"_posts/检查清单.md","raw":"---\ntitle: 检查清单 Report\ndate: 2017-11-04 15:27:45\ntags: 清单\n---\n写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，并集|，交集&，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n用assert 来确定数据是可用的(assert A,B = if not A do B)\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n\n\n团队沟通\n\n\n换位思考，从对方的思路开始思考，先明白对方问题的原因。\n\n\n不仅要有自己的想法，还要对于想法有可行的方案。\n\n\n前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！\n\n\nHTML操作\n\n\nw3lib.html.remove_tags()可以过滤Html标签。\n\n","slug":"检查清单","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwl2002nvmvv3g5spgij","content":"<p>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，并集|，交集&amp;，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>用assert 来确定数据是可用的(assert A,B = if not A do B)</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 </p>\n<p>团队沟通</p>\n<p>换位思考，从对方的思路开始思考，先明白对方问题的原因。</p>\n<p>不仅要有自己的想法，还要对于想法有可行的方案。</p>\n<p>前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！</p>\n<p>HTML操作</p>\n<p>w3lib.html.remove_tags()可以过滤Html标签。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，并集|，交集&amp;，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>用assert 来确定数据是可用的(assert A,B = if not A do B)</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 </p>\n<p>团队沟通</p>\n<p>换位思考，从对方的思路开始思考，先明白对方问题的原因。</p>\n<p>不仅要有自己的想法，还要对于想法有可行的方案。</p>\n<p>前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！</p>\n<p>HTML操作</p>\n<p>w3lib.html.remove_tags()可以过滤Html标签。</p>\n"},{"title":"联合-查找算法","date":"2017-11-06T05:26:47.000Z","_content":"介绍这个算法前，先梳理一些相关词组的概念：\n\n**并查集**： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.\n\n**Find(node)函数**： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.\n\n**Union(node_a, node_b)函数**： 将两个子集合并成同一个集合.\n\n**并查集森林**： 并查集森林中每个节点保存的都是其父节点的引用。\n\n**下面从基础版本分析，再到两种优化来讲解这个算法。**\n\n* 基础版本的联合-查找算法：\n\n```\n\tdef find(node):\n\t\tif parent[node] == node:\n\t\t\treturn node\n\t\telse:\n\t\t\treturn find(parent[node])\n\t\t\t\n\tdef union(node_a, node_b):\n\t\troot_a = find(node_a)\n\t\troot_b = find(nond_b)\n\t\tparent[root_a] = roo_b\n\n```\n这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。\n\n* 按秩合并\n\n```\n    def union(node_a, node_b):\n        root_a = get_parent(node_a)\n        root_b = get_parent(node_b)\n\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        elif rank[root_a] < rank[root_b]:\n            parent[root_a] = root_b\n        else:\n        \t  parent[root_a] = root_b\n            rank[root_b] += 1\n```\n这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).\n\n* 路径压缩\n\n```\n    def get_parent(node):\n        if parent[node] == node:\n            return node\n        parent[node] = get_parent(parent[node])\n        return parent[node]\n```\n在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。\n\n\n### 扩展\n**我们用一道题目来梳理一下这个算法。**\n\nLeet Code Weekly Contest 57 里有一道题目：\n\nGiven a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n题目的**大意**是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。\n\n```\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n\n        def get_parent(node):\n            if parent[node] == node:\n                return node\n            parent[node] = get_parent(parent[node])\n            return parent[node]\n\n        def union(node_a, node_b):\n            root_a = get_parent(node_a)\n            root_b = get_parent(node_b)\n\n            if rank[root_a] < rank[root_b]:\n                parent[root_a] = root_b\n            else:\n                parent[root_b] = root_a\n                rank[root_a] += 1\n\n        rank = collections.defaultdict(int)\n        parent = {}\n        owner = {}\n        result = collections.defaultdict(list)\n        emails_set = set()\n\n        for i, account in enumerate(accounts):\n            name, emails = account[0], account[1:]\n            for email in emails:\n                emails_set.add(email)\n                owner[email] = name\n                if email not in parent:  # 生成并查集森林\n                    parent[email] = email\n\n            for email in emails[1:]:  \n                union(emails[0], email)\n\n        for email in emails_set:\n            result[get_parent(email)].append(email)\n        return [[owner[email]] + sorted(result[email]) for email in result]\n```\n\n\n","source":"_posts/联合-查找算法.md","raw":"---\ntitle: 联合-查找算法\ndate: 2017-11-06 13:26:47\ntags: 算法\n---\n介绍这个算法前，先梳理一些相关词组的概念：\n\n**并查集**： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.\n\n**Find(node)函数**： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.\n\n**Union(node_a, node_b)函数**： 将两个子集合并成同一个集合.\n\n**并查集森林**： 并查集森林中每个节点保存的都是其父节点的引用。\n\n**下面从基础版本分析，再到两种优化来讲解这个算法。**\n\n* 基础版本的联合-查找算法：\n\n```\n\tdef find(node):\n\t\tif parent[node] == node:\n\t\t\treturn node\n\t\telse:\n\t\t\treturn find(parent[node])\n\t\t\t\n\tdef union(node_a, node_b):\n\t\troot_a = find(node_a)\n\t\troot_b = find(nond_b)\n\t\tparent[root_a] = roo_b\n\n```\n这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。\n\n* 按秩合并\n\n```\n    def union(node_a, node_b):\n        root_a = get_parent(node_a)\n        root_b = get_parent(node_b)\n\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        elif rank[root_a] < rank[root_b]:\n            parent[root_a] = root_b\n        else:\n        \t  parent[root_a] = root_b\n            rank[root_b] += 1\n```\n这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).\n\n* 路径压缩\n\n```\n    def get_parent(node):\n        if parent[node] == node:\n            return node\n        parent[node] = get_parent(parent[node])\n        return parent[node]\n```\n在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。\n\n\n### 扩展\n**我们用一道题目来梳理一下这个算法。**\n\nLeet Code Weekly Contest 57 里有一道题目：\n\nGiven a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n题目的**大意**是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。\n\n```\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n\n        def get_parent(node):\n            if parent[node] == node:\n                return node\n            parent[node] = get_parent(parent[node])\n            return parent[node]\n\n        def union(node_a, node_b):\n            root_a = get_parent(node_a)\n            root_b = get_parent(node_b)\n\n            if rank[root_a] < rank[root_b]:\n                parent[root_a] = root_b\n            else:\n                parent[root_b] = root_a\n                rank[root_a] += 1\n\n        rank = collections.defaultdict(int)\n        parent = {}\n        owner = {}\n        result = collections.defaultdict(list)\n        emails_set = set()\n\n        for i, account in enumerate(accounts):\n            name, emails = account[0], account[1:]\n            for email in emails:\n                emails_set.add(email)\n                owner[email] = name\n                if email not in parent:  # 生成并查集森林\n                    parent[email] = email\n\n            for email in emails[1:]:  \n                union(emails[0], email)\n\n        for email in emails_set:\n            result[get_parent(email)].append(email)\n        return [[owner[email]] + sorted(result[email]) for email in result]\n```\n\n\n","slug":"联合-查找算法","published":1,"updated":"2018-01-24T16:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwl4002qvmvv4ttav9u6","content":"<p>介绍这个算法前，先梳理一些相关词组的概念：</p>\n<p><strong>并查集</strong>： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.</p>\n<p><strong>Find(node)函数</strong>： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.</p>\n<p><strong>Union(node_a, node_b)函数</strong>： 将两个子集合并成同一个集合.</p>\n<p><strong>并查集森林</strong>： 并查集森林中每个节点保存的都是其父节点的引用。</p>\n<p><strong>下面从基础版本分析，再到两种优化来讲解这个算法。</strong></p>\n<ul>\n<li>基础版本的联合-查找算法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def find(node):</div><div class=\"line\">\tif parent[node] == node:</div><div class=\"line\">\t\treturn node</div><div class=\"line\">\telse:</div><div class=\"line\">\t\treturn find(parent[node])</div><div class=\"line\">\t\t</div><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">\troot_a = find(node_a)</div><div class=\"line\">\troot_b = find(nond_b)</div><div class=\"line\">\tparent[root_a] = roo_b</div></pre></td></tr></table></figure>\n<p>这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。</p>\n<ul>\n<li>按秩合并</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">    root_a = get_parent(node_a)</div><div class=\"line\">    root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">    if rank[root_a] &gt; rank[root_b]:</div><div class=\"line\">        parent[root_b] = root_a</div><div class=\"line\">    elif rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">        parent[root_a] = root_b</div><div class=\"line\">    else:</div><div class=\"line\">    \t  parent[root_a] = root_b</div><div class=\"line\">        rank[root_b] += 1</div></pre></td></tr></table></figure>\n<p>这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).</p>\n<ul>\n<li>路径压缩</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def get_parent(node):</div><div class=\"line\">    if parent[node] == node:</div><div class=\"line\">        return node</div><div class=\"line\">    parent[node] = get_parent(parent[node])</div><div class=\"line\">    return parent[node]</div></pre></td></tr></table></figure>\n<p>在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><strong>我们用一道题目来梳理一下这个算法。</strong></p>\n<p>Leet Code Weekly Contest 57 里有一道题目：</p>\n<p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.</p>\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n<p>After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>\n<p>题目的<strong>大意</strong>是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    def accountsMerge(self, accounts):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type accounts: List[List[str]]</div><div class=\"line\">        :rtype: List[List[str]]</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">        def get_parent(node):</div><div class=\"line\">            if parent[node] == node:</div><div class=\"line\">                return node</div><div class=\"line\">            parent[node] = get_parent(parent[node])</div><div class=\"line\">            return parent[node]</div><div class=\"line\"></div><div class=\"line\">        def union(node_a, node_b):</div><div class=\"line\">            root_a = get_parent(node_a)</div><div class=\"line\">            root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">            if rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">                parent[root_a] = root_b</div><div class=\"line\">            else:</div><div class=\"line\">                parent[root_b] = root_a</div><div class=\"line\">                rank[root_a] += 1</div><div class=\"line\"></div><div class=\"line\">        rank = collections.defaultdict(int)</div><div class=\"line\">        parent = &#123;&#125;</div><div class=\"line\">        owner = &#123;&#125;</div><div class=\"line\">        result = collections.defaultdict(list)</div><div class=\"line\">        emails_set = set()</div><div class=\"line\"></div><div class=\"line\">        for i, account in enumerate(accounts):</div><div class=\"line\">            name, emails = account[0], account[1:]</div><div class=\"line\">            for email in emails:</div><div class=\"line\">                emails_set.add(email)</div><div class=\"line\">                owner[email] = name</div><div class=\"line\">                if email not in parent:  # 生成并查集森林</div><div class=\"line\">                    parent[email] = email</div><div class=\"line\"></div><div class=\"line\">            for email in emails[1:]:  </div><div class=\"line\">                union(emails[0], email)</div><div class=\"line\"></div><div class=\"line\">        for email in emails_set:</div><div class=\"line\">            result[get_parent(email)].append(email)</div><div class=\"line\">        return [[owner[email]] + sorted(result[email]) for email in result]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍这个算法前，先梳理一些相关词组的概念：</p>\n<p><strong>并查集</strong>： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.</p>\n<p><strong>Find(node)函数</strong>： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.</p>\n<p><strong>Union(node_a, node_b)函数</strong>： 将两个子集合并成同一个集合.</p>\n<p><strong>并查集森林</strong>： 并查集森林中每个节点保存的都是其父节点的引用。</p>\n<p><strong>下面从基础版本分析，再到两种优化来讲解这个算法。</strong></p>\n<ul>\n<li>基础版本的联合-查找算法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def find(node):</div><div class=\"line\">\tif parent[node] == node:</div><div class=\"line\">\t\treturn node</div><div class=\"line\">\telse:</div><div class=\"line\">\t\treturn find(parent[node])</div><div class=\"line\">\t\t</div><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">\troot_a = find(node_a)</div><div class=\"line\">\troot_b = find(nond_b)</div><div class=\"line\">\tparent[root_a] = roo_b</div></pre></td></tr></table></figure>\n<p>这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。</p>\n<ul>\n<li>按秩合并</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">    root_a = get_parent(node_a)</div><div class=\"line\">    root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">    if rank[root_a] &gt; rank[root_b]:</div><div class=\"line\">        parent[root_b] = root_a</div><div class=\"line\">    elif rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">        parent[root_a] = root_b</div><div class=\"line\">    else:</div><div class=\"line\">    \t  parent[root_a] = root_b</div><div class=\"line\">        rank[root_b] += 1</div></pre></td></tr></table></figure>\n<p>这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).</p>\n<ul>\n<li>路径压缩</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def get_parent(node):</div><div class=\"line\">    if parent[node] == node:</div><div class=\"line\">        return node</div><div class=\"line\">    parent[node] = get_parent(parent[node])</div><div class=\"line\">    return parent[node]</div></pre></td></tr></table></figure>\n<p>在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><strong>我们用一道题目来梳理一下这个算法。</strong></p>\n<p>Leet Code Weekly Contest 57 里有一道题目：</p>\n<p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.</p>\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n<p>After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>\n<p>题目的<strong>大意</strong>是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    def accountsMerge(self, accounts):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type accounts: List[List[str]]</div><div class=\"line\">        :rtype: List[List[str]]</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">        def get_parent(node):</div><div class=\"line\">            if parent[node] == node:</div><div class=\"line\">                return node</div><div class=\"line\">            parent[node] = get_parent(parent[node])</div><div class=\"line\">            return parent[node]</div><div class=\"line\"></div><div class=\"line\">        def union(node_a, node_b):</div><div class=\"line\">            root_a = get_parent(node_a)</div><div class=\"line\">            root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">            if rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">                parent[root_a] = root_b</div><div class=\"line\">            else:</div><div class=\"line\">                parent[root_b] = root_a</div><div class=\"line\">                rank[root_a] += 1</div><div class=\"line\"></div><div class=\"line\">        rank = collections.defaultdict(int)</div><div class=\"line\">        parent = &#123;&#125;</div><div class=\"line\">        owner = &#123;&#125;</div><div class=\"line\">        result = collections.defaultdict(list)</div><div class=\"line\">        emails_set = set()</div><div class=\"line\"></div><div class=\"line\">        for i, account in enumerate(accounts):</div><div class=\"line\">            name, emails = account[0], account[1:]</div><div class=\"line\">            for email in emails:</div><div class=\"line\">                emails_set.add(email)</div><div class=\"line\">                owner[email] = name</div><div class=\"line\">                if email not in parent:  # 生成并查集森林</div><div class=\"line\">                    parent[email] = email</div><div class=\"line\"></div><div class=\"line\">            for email in emails[1:]:  </div><div class=\"line\">                union(emails[0], email)</div><div class=\"line\"></div><div class=\"line\">        for email in emails_set:</div><div class=\"line\">            result[get_parent(email)].append(email)</div><div class=\"line\">        return [[owner[email]] + sorted(result[email]) for email in result]</div></pre></td></tr></table></figure>\n"},{"title":"系统级I/O及Linux-I/O模式解释","date":"2018-01-24T16:03:41.000Z","_content":"`*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*`\n\n## UNIX I/O\n\nLinux中，所有的输入和输出都被当作对相应的文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O：\n\n*  **打开文件**：当应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做**描述符**(后面用fd代替)，它在后续对此文件的所有操作中标识这个文件。\n*  Linux shell创建每个进程开始时都有三个打开的文件，标准输入（fd为0），标准输出（fd为1），标准错误（fd为2）。\n*  **改变当前的文件位置**：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行**seek**操作，显式地设置文件的当前位置k。\n*  **读写文件**：一个读操作就是从文件复制n > 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k >= m时执行读操作会触发一个称为end-of-file(EOF)的条件。类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。\n* **关闭文件**: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。\n\n## 共享文件\n可以用许多不同的方式来共享Linux文件，但是内核用三个相关的数据结构来表示打开的文件。\n\n* **描述符表**：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。\n* **文件表**：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。内核会在引用计数为零时，删除对应表项。\n* **v-node表**：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息（文件的元数据，比如大小，创建时间）。\n\n## 标准 I/O\nC语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数（fread和fwrite）、读和写字符串的函数(fgets和fputs)，以及复杂的格式化的I/O函数（scanf和printf）。标准的I/O库将一个打开的文件模型化为一个流。对程序员而言，一个流就是一个指向FILE类型的结构的指针。\n\n类型为FILE的流是对文件描述符和**流缓冲区**的抽象。流缓冲区的目的是：使开销较高的Linux I/O系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下个字符。当第一次调用getc时，库通过调用一次read函数来填满流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。\n\n虽然以上是通过C语言的标准I/O函数来讲解的，但是从概念上理解，与别的编程语言也是相通的。\n\n\n## I/O的模式\n\n理解了I/O的基本概念后，接下来我们来谈论关于I/O不同模式的概念，优缺点以及它们彼此间的相同与不同点。\n\n1. 阻塞I/O(Blocking I/O)：![](images/阻塞io.png)默认情况下，所有Linux中套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：（1）等待数据准备好；\n（2）从内核向进程复制数据。当用户进程调用了recvfrom操作时，kernel就开始准备数据了。这是需要等待的，也就是说数据被拷贝到操作系统内的**流缓冲区**是需要一个过程的，而此时在用户进程的角度，就是被阻塞了。等到数据被准备好时，将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程此时解除阻塞状态。\n2. 非阻塞I/O(Non-blocking I/O)：![](images/非阻塞io.png)：当用户发起非阻塞I/O操作时，如果数据还没有从kernel拷贝到用户内存中，那么kernel会立即返回一个error的信号，而用户进程得到这个信号后，就理解了此时数据还在等待中，之后会立即重新发送一个recvfrom的请求，直到数据被拷贝到用户内存中并且得到一个正确的返回。\n3. I/O多路复用(I/O multiplexing)：![](images/io复用.png)I/O多路复用也是并发的一种手段，基本思想就是使用select函数，要求内核挂起进程，只有在一个或者多个I/O时间发生后，才将控制返回给应用程序，比如：当集合{0，5}中任意描述符准备好读时返回。要注意使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）\n在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。\n\n4. 异步I/O(asynchronous I/O)：![](images/异步io.png) 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\n\n\n## 阻塞和非阻塞的区别\n调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞I/O在kernel还准备数据的情况下会立刻返回。\n\n## 同步I/O和异步I/O的区别\n同步I/O:导致请求进程阻塞，直到I/O操作完成。\n\n异步I/O:不导致请求进程阻塞。\n![](images/同步io.png)\n可能有人看完上图后，会很疑惑为啥非阻塞I/O也属于同步I/O了呢，它不是请求后直接返回了吗，尽管数据未准备好时它得到的error返回，那么也没有被阻塞啊。这里就是概念没有理解透彻导致的思想啦，其实不仅是kernel数据等待会阻塞进程，把kernel中的数据拷贝到用户内存中，也同样是阻塞用户进程的，你可以再仔细看一下上面I/O模式的介绍图，它是在两个过程结束后才返回OK的。所以非阻塞I/O也定义为同步I/O.\n\n而异步I／O则不一样，当进程发起I／O操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说I/O完成。在这整个过程中，进程完全没有被阻塞。而这个过程就如同Python中的async/await一样。\n\n\n## 各个I/O模式的对比\n![](images/io区别.png)\n通过上面图片，可以发现非阻塞I/O和异步I/O的区别还是很明显的。在非阻塞I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步I/O则完全不同。它就像是用户进程将整个I/O操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。\n\n## 参考\n《深入理解计算机系统》第三版，第十章。\n\n[Linux I/O模式](https://segmentfault.com/a/1190000003063859)\n\n[怎样理解阻塞非阻塞与同步异步的区别](https://www.zhihu.com/question/19732473)\n## 最后\n\n本文没有用任何代码，希望先用文字将这些概念梳理清楚。对于I/O复用，以及系统级别的并发，会在后面用实际的代码来提供完整的参考与理解。\n\n如有纰漏之处，希望大家不吝赐教。Have fun :)\n\n","source":"_posts/系统级I-O及Linux-I-O模式解释.md","raw":"---\ntitle: 系统级I/O及Linux-I/O模式解释\ndate: 2018-01-25 00:03:41\ntags: 计算机系统\n\n---\n`*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*`\n\n## UNIX I/O\n\nLinux中，所有的输入和输出都被当作对相应的文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O：\n\n*  **打开文件**：当应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做**描述符**(后面用fd代替)，它在后续对此文件的所有操作中标识这个文件。\n*  Linux shell创建每个进程开始时都有三个打开的文件，标准输入（fd为0），标准输出（fd为1），标准错误（fd为2）。\n*  **改变当前的文件位置**：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行**seek**操作，显式地设置文件的当前位置k。\n*  **读写文件**：一个读操作就是从文件复制n > 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k >= m时执行读操作会触发一个称为end-of-file(EOF)的条件。类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。\n* **关闭文件**: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。\n\n## 共享文件\n可以用许多不同的方式来共享Linux文件，但是内核用三个相关的数据结构来表示打开的文件。\n\n* **描述符表**：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。\n* **文件表**：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。内核会在引用计数为零时，删除对应表项。\n* **v-node表**：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息（文件的元数据，比如大小，创建时间）。\n\n## 标准 I/O\nC语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数（fread和fwrite）、读和写字符串的函数(fgets和fputs)，以及复杂的格式化的I/O函数（scanf和printf）。标准的I/O库将一个打开的文件模型化为一个流。对程序员而言，一个流就是一个指向FILE类型的结构的指针。\n\n类型为FILE的流是对文件描述符和**流缓冲区**的抽象。流缓冲区的目的是：使开销较高的Linux I/O系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下个字符。当第一次调用getc时，库通过调用一次read函数来填满流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。\n\n虽然以上是通过C语言的标准I/O函数来讲解的，但是从概念上理解，与别的编程语言也是相通的。\n\n\n## I/O的模式\n\n理解了I/O的基本概念后，接下来我们来谈论关于I/O不同模式的概念，优缺点以及它们彼此间的相同与不同点。\n\n1. 阻塞I/O(Blocking I/O)：![](images/阻塞io.png)默认情况下，所有Linux中套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：（1）等待数据准备好；\n（2）从内核向进程复制数据。当用户进程调用了recvfrom操作时，kernel就开始准备数据了。这是需要等待的，也就是说数据被拷贝到操作系统内的**流缓冲区**是需要一个过程的，而此时在用户进程的角度，就是被阻塞了。等到数据被准备好时，将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程此时解除阻塞状态。\n2. 非阻塞I/O(Non-blocking I/O)：![](images/非阻塞io.png)：当用户发起非阻塞I/O操作时，如果数据还没有从kernel拷贝到用户内存中，那么kernel会立即返回一个error的信号，而用户进程得到这个信号后，就理解了此时数据还在等待中，之后会立即重新发送一个recvfrom的请求，直到数据被拷贝到用户内存中并且得到一个正确的返回。\n3. I/O多路复用(I/O multiplexing)：![](images/io复用.png)I/O多路复用也是并发的一种手段，基本思想就是使用select函数，要求内核挂起进程，只有在一个或者多个I/O时间发生后，才将控制返回给应用程序，比如：当集合{0，5}中任意描述符准备好读时返回。要注意使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）\n在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。\n\n4. 异步I/O(asynchronous I/O)：![](images/异步io.png) 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\n\n\n## 阻塞和非阻塞的区别\n调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞I/O在kernel还准备数据的情况下会立刻返回。\n\n## 同步I/O和异步I/O的区别\n同步I/O:导致请求进程阻塞，直到I/O操作完成。\n\n异步I/O:不导致请求进程阻塞。\n![](images/同步io.png)\n可能有人看完上图后，会很疑惑为啥非阻塞I/O也属于同步I/O了呢，它不是请求后直接返回了吗，尽管数据未准备好时它得到的error返回，那么也没有被阻塞啊。这里就是概念没有理解透彻导致的思想啦，其实不仅是kernel数据等待会阻塞进程，把kernel中的数据拷贝到用户内存中，也同样是阻塞用户进程的，你可以再仔细看一下上面I/O模式的介绍图，它是在两个过程结束后才返回OK的。所以非阻塞I/O也定义为同步I/O.\n\n而异步I／O则不一样，当进程发起I／O操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说I/O完成。在这整个过程中，进程完全没有被阻塞。而这个过程就如同Python中的async/await一样。\n\n\n## 各个I/O模式的对比\n![](images/io区别.png)\n通过上面图片，可以发现非阻塞I/O和异步I/O的区别还是很明显的。在非阻塞I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步I/O则完全不同。它就像是用户进程将整个I/O操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。\n\n## 参考\n《深入理解计算机系统》第三版，第十章。\n\n[Linux I/O模式](https://segmentfault.com/a/1190000003063859)\n\n[怎样理解阻塞非阻塞与同步异步的区别](https://www.zhihu.com/question/19732473)\n## 最后\n\n本文没有用任何代码，希望先用文字将这些概念梳理清楚。对于I/O复用，以及系统级别的并发，会在后面用实际的代码来提供完整的参考与理解。\n\n如有纰漏之处，希望大家不吝赐教。Have fun :)\n\n","slug":"系统级I-O及Linux-I-O模式解释","published":1,"updated":"2018-01-25T13:42:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcztkwl6002uvmvv0lafnad8","content":"<p><code>*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*</code></p>\n<h2 id=\"UNIX-I-O\"><a href=\"#UNIX-I-O\" class=\"headerlink\" title=\"UNIX I/O\"></a>UNIX I/O</h2><p>Linux中，所有的输入和输出都被当作对相应的文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O：</p>\n<ul>\n<li><strong>打开文件</strong>：当应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做<strong>描述符</strong>(后面用fd代替)，它在后续对此文件的所有操作中标识这个文件。</li>\n<li>Linux shell创建每个进程开始时都有三个打开的文件，标准输入（fd为0），标准输出（fd为1），标准错误（fd为2）。</li>\n<li><strong>改变当前的文件位置</strong>：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行<strong>seek</strong>操作，显式地设置文件的当前位置k。</li>\n<li><strong>读写文件</strong>：一个读操作就是从文件复制n &gt; 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k &gt;= m时执行读操作会触发一个称为end-of-file(EOF)的条件。类似的，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li>\n<li><strong>关闭文件</strong>: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。</li>\n</ul>\n<h2 id=\"共享文件\"><a href=\"#共享文件\" class=\"headerlink\" title=\"共享文件\"></a>共享文件</h2><p>可以用许多不同的方式来共享Linux文件，但是内核用三个相关的数据结构来表示打开的文件。</p>\n<ul>\n<li><strong>描述符表</strong>：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li>\n<li><strong>文件表</strong>：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。内核会在引用计数为零时，删除对应表项。</li>\n<li><strong>v-node表</strong>：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息（文件的元数据，比如大小，创建时间）。</li>\n</ul>\n<h2 id=\"标准-I-O\"><a href=\"#标准-I-O\" class=\"headerlink\" title=\"标准 I/O\"></a>标准 I/O</h2><p>C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数（fread和fwrite）、读和写字符串的函数(fgets和fputs)，以及复杂的格式化的I/O函数（scanf和printf）。标准的I/O库将一个打开的文件模型化为一个流。对程序员而言，一个流就是一个指向FILE类型的结构的指针。</p>\n<p>类型为FILE的流是对文件描述符和<strong>流缓冲区</strong>的抽象。流缓冲区的目的是：使开销较高的Linux I/O系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下个字符。当第一次调用getc时，库通过调用一次read函数来填满流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。</p>\n<p>虽然以上是通过C语言的标准I/O函数来讲解的，但是从概念上理解，与别的编程语言也是相通的。</p>\n<h2 id=\"I-O的模式\"><a href=\"#I-O的模式\" class=\"headerlink\" title=\"I/O的模式\"></a>I/O的模式</h2><p>理解了I/O的基本概念后，接下来我们来谈论关于I/O不同模式的概念，优缺点以及它们彼此间的相同与不同点。</p>\n<ol>\n<li>阻塞I/O(Blocking I/O)：<img src=\"images/阻塞io.png\" alt=\"\">默认情况下，所有Linux中套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：（1）等待数据准备好；<br>（2）从内核向进程复制数据。当用户进程调用了recvfrom操作时，kernel就开始准备数据了。这是需要等待的，也就是说数据被拷贝到操作系统内的<strong>流缓冲区</strong>是需要一个过程的，而此时在用户进程的角度，就是被阻塞了。等到数据被准备好时，将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程此时解除阻塞状态。</li>\n<li>非阻塞I/O(Non-blocking I/O)：<img src=\"images/非阻塞io.png\" alt=\"\">：当用户发起非阻塞I/O操作时，如果数据还没有从kernel拷贝到用户内存中，那么kernel会立即返回一个error的信号，而用户进程得到这个信号后，就理解了此时数据还在等待中，之后会立即重新发送一个recvfrom的请求，直到数据被拷贝到用户内存中并且得到一个正确的返回。</li>\n<li><p>I/O多路复用(I/O multiplexing)：<img src=\"images/io复用.png\" alt=\"\">I/O多路复用也是并发的一种手段，基本思想就是使用select函数，要求内核挂起进程，只有在一个或者多个I/O时间发生后，才将控制返回给应用程序，比如：当集合{0，5}中任意描述符准备好读时返回。要注意使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>\n</li>\n<li><p>异步I/O(asynchronous I/O)：<img src=\"images/异步io.png\" alt=\"\"> 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>\n</li>\n</ol>\n<h2 id=\"阻塞和非阻塞的区别\"><a href=\"#阻塞和非阻塞的区别\" class=\"headerlink\" title=\"阻塞和非阻塞的区别\"></a>阻塞和非阻塞的区别</h2><p>调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞I/O在kernel还准备数据的情况下会立刻返回。</p>\n<h2 id=\"同步I-O和异步I-O的区别\"><a href=\"#同步I-O和异步I-O的区别\" class=\"headerlink\" title=\"同步I/O和异步I/O的区别\"></a>同步I/O和异步I/O的区别</h2><p>同步I/O:导致请求进程阻塞，直到I/O操作完成。</p>\n<p>异步I/O:不导致请求进程阻塞。<br><img src=\"images/同步io.png\" alt=\"\"><br>可能有人看完上图后，会很疑惑为啥非阻塞I/O也属于同步I/O了呢，它不是请求后直接返回了吗，尽管数据未准备好时它得到的error返回，那么也没有被阻塞啊。这里就是概念没有理解透彻导致的思想啦，其实不仅是kernel数据等待会阻塞进程，把kernel中的数据拷贝到用户内存中，也同样是阻塞用户进程的，你可以再仔细看一下上面I/O模式的介绍图，它是在两个过程结束后才返回OK的。所以非阻塞I/O也定义为同步I/O.</p>\n<p>而异步I／O则不一样，当进程发起I／O操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说I/O完成。在这整个过程中，进程完全没有被阻塞。而这个过程就如同Python中的async/await一样。</p>\n<h2 id=\"各个I-O模式的对比\"><a href=\"#各个I-O模式的对比\" class=\"headerlink\" title=\"各个I/O模式的对比\"></a>各个I/O模式的对比</h2><p><img src=\"images/io区别.png\" alt=\"\"><br>通过上面图片，可以发现非阻塞I/O和异步I/O的区别还是很明显的。在非阻塞I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步I/O则完全不同。它就像是用户进程将整个I/O操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《深入理解计算机系统》第三版，第十章。</p>\n<p><a href=\"https://segmentfault.com/a/1190000003063859\" target=\"_blank\" rel=\"external\">Linux I/O模式</a></p>\n<p><a href=\"https://www.zhihu.com/question/19732473\" target=\"_blank\" rel=\"external\">怎样理解阻塞非阻塞与同步异步的区别</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文没有用任何代码，希望先用文字将这些概念梳理清楚。对于I/O复用，以及系统级别的并发，会在后面用实际的代码来提供完整的参考与理解。</p>\n<p>如有纰漏之处，希望大家不吝赐教。Have fun :)</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*</code></p>\n<h2 id=\"UNIX-I-O\"><a href=\"#UNIX-I-O\" class=\"headerlink\" title=\"UNIX I/O\"></a>UNIX I/O</h2><p>Linux中，所有的输入和输出都被当作对相应的文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O：</p>\n<ul>\n<li><strong>打开文件</strong>：当应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做<strong>描述符</strong>(后面用fd代替)，它在后续对此文件的所有操作中标识这个文件。</li>\n<li>Linux shell创建每个进程开始时都有三个打开的文件，标准输入（fd为0），标准输出（fd为1），标准错误（fd为2）。</li>\n<li><strong>改变当前的文件位置</strong>：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行<strong>seek</strong>操作，显式地设置文件的当前位置k。</li>\n<li><strong>读写文件</strong>：一个读操作就是从文件复制n &gt; 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k &gt;= m时执行读操作会触发一个称为end-of-file(EOF)的条件。类似的，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li>\n<li><strong>关闭文件</strong>: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。</li>\n</ul>\n<h2 id=\"共享文件\"><a href=\"#共享文件\" class=\"headerlink\" title=\"共享文件\"></a>共享文件</h2><p>可以用许多不同的方式来共享Linux文件，但是内核用三个相关的数据结构来表示打开的文件。</p>\n<ul>\n<li><strong>描述符表</strong>：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li>\n<li><strong>文件表</strong>：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。内核会在引用计数为零时，删除对应表项。</li>\n<li><strong>v-node表</strong>：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息（文件的元数据，比如大小，创建时间）。</li>\n</ul>\n<h2 id=\"标准-I-O\"><a href=\"#标准-I-O\" class=\"headerlink\" title=\"标准 I/O\"></a>标准 I/O</h2><p>C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数（fread和fwrite）、读和写字符串的函数(fgets和fputs)，以及复杂的格式化的I/O函数（scanf和printf）。标准的I/O库将一个打开的文件模型化为一个流。对程序员而言，一个流就是一个指向FILE类型的结构的指针。</p>\n<p>类型为FILE的流是对文件描述符和<strong>流缓冲区</strong>的抽象。流缓冲区的目的是：使开销较高的Linux I/O系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下个字符。当第一次调用getc时，库通过调用一次read函数来填满流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。</p>\n<p>虽然以上是通过C语言的标准I/O函数来讲解的，但是从概念上理解，与别的编程语言也是相通的。</p>\n<h2 id=\"I-O的模式\"><a href=\"#I-O的模式\" class=\"headerlink\" title=\"I/O的模式\"></a>I/O的模式</h2><p>理解了I/O的基本概念后，接下来我们来谈论关于I/O不同模式的概念，优缺点以及它们彼此间的相同与不同点。</p>\n<ol>\n<li>阻塞I/O(Blocking I/O)：<img src=\"images/阻塞io.png\" alt=\"\">默认情况下，所有Linux中套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：（1）等待数据准备好；<br>（2）从内核向进程复制数据。当用户进程调用了recvfrom操作时，kernel就开始准备数据了。这是需要等待的，也就是说数据被拷贝到操作系统内的<strong>流缓冲区</strong>是需要一个过程的，而此时在用户进程的角度，就是被阻塞了。等到数据被准备好时，将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程此时解除阻塞状态。</li>\n<li>非阻塞I/O(Non-blocking I/O)：<img src=\"images/非阻塞io.png\" alt=\"\">：当用户发起非阻塞I/O操作时，如果数据还没有从kernel拷贝到用户内存中，那么kernel会立即返回一个error的信号，而用户进程得到这个信号后，就理解了此时数据还在等待中，之后会立即重新发送一个recvfrom的请求，直到数据被拷贝到用户内存中并且得到一个正确的返回。</li>\n<li><p>I/O多路复用(I/O multiplexing)：<img src=\"images/io复用.png\" alt=\"\">I/O多路复用也是并发的一种手段，基本思想就是使用select函数，要求内核挂起进程，只有在一个或者多个I/O时间发生后，才将控制返回给应用程序，比如：当集合{0，5}中任意描述符准备好读时返回。要注意使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>\n</li>\n<li><p>异步I/O(asynchronous I/O)：<img src=\"images/异步io.png\" alt=\"\"> 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>\n</li>\n</ol>\n<h2 id=\"阻塞和非阻塞的区别\"><a href=\"#阻塞和非阻塞的区别\" class=\"headerlink\" title=\"阻塞和非阻塞的区别\"></a>阻塞和非阻塞的区别</h2><p>调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞I/O在kernel还准备数据的情况下会立刻返回。</p>\n<h2 id=\"同步I-O和异步I-O的区别\"><a href=\"#同步I-O和异步I-O的区别\" class=\"headerlink\" title=\"同步I/O和异步I/O的区别\"></a>同步I/O和异步I/O的区别</h2><p>同步I/O:导致请求进程阻塞，直到I/O操作完成。</p>\n<p>异步I/O:不导致请求进程阻塞。<br><img src=\"images/同步io.png\" alt=\"\"><br>可能有人看完上图后，会很疑惑为啥非阻塞I/O也属于同步I/O了呢，它不是请求后直接返回了吗，尽管数据未准备好时它得到的error返回，那么也没有被阻塞啊。这里就是概念没有理解透彻导致的思想啦，其实不仅是kernel数据等待会阻塞进程，把kernel中的数据拷贝到用户内存中，也同样是阻塞用户进程的，你可以再仔细看一下上面I/O模式的介绍图，它是在两个过程结束后才返回OK的。所以非阻塞I/O也定义为同步I/O.</p>\n<p>而异步I／O则不一样，当进程发起I／O操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说I/O完成。在这整个过程中，进程完全没有被阻塞。而这个过程就如同Python中的async/await一样。</p>\n<h2 id=\"各个I-O模式的对比\"><a href=\"#各个I-O模式的对比\" class=\"headerlink\" title=\"各个I/O模式的对比\"></a>各个I/O模式的对比</h2><p><img src=\"images/io区别.png\" alt=\"\"><br>通过上面图片，可以发现非阻塞I/O和异步I/O的区别还是很明显的。在非阻塞I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步I/O则完全不同。它就像是用户进程将整个I/O操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《深入理解计算机系统》第三版，第十章。</p>\n<p><a href=\"https://segmentfault.com/a/1190000003063859\" target=\"_blank\" rel=\"external\">Linux I/O模式</a></p>\n<p><a href=\"https://www.zhihu.com/question/19732473\" target=\"_blank\" rel=\"external\">怎样理解阻塞非阻塞与同步异步的区别</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文没有用任何代码，希望先用文字将这些概念梳理清楚。对于I/O复用，以及系统级别的并发，会在后面用实际的代码来提供完整的参考与理解。</p>\n<p>如有纰漏之处，希望大家不吝赐教。Have fun :)</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjcztkwks0020vmvvhf1l60to","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwku0024vmvv6w68rmr5"},{"post_id":"cjcztkwkp001tvmvvokoq1exd","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwkv0026vmvv69rrxiie"},{"post_id":"cjcztkwkt0022vmvvrtfexemn","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwkw0029vmvvck5gofuh"},{"post_id":"cjcztkwku0025vmvvqi2vr2tt","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwkw002bvmvvq0fyj0el"},{"post_id":"cjcztkwkr001vvmvvme7aohkv","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwkx002evmvvwgjvqanw"},{"post_id":"cjcztkwkv0027vmvvitce17s6","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwky002gvmvv4y7l5fse"},{"post_id":"cjcztkwkr001yvmvvbpbk9bs4","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwkz002ivmvvln90owp8"},{"post_id":"cjcztkwkx002cvmvv7hfrrnh2","tag_id":"cjcztkwkr001wvmvv32avxqlg","_id":"cjcztkwl0002kvmvvi4jdty7y"},{"post_id":"cjcztkwkx002fvmvvp757scvl","tag_id":"cjcztkwjl0004vmvvitjsnnb7","_id":"cjcztkwl2002mvmvvct1io07q"},{"post_id":"cjcztkwl2002nvmvv3g5spgij","tag_id":"cjcztkwl7002vvmvvq5fal01w","_id":"cjcztkwl7002yvmvvcisauri0"},{"post_id":"cjcztkwl4002qvmvv4ttav9u6","tag_id":"cjcztkwl7002xvmvvccccm93t","_id":"cjcztkwl80030vmvvl757h15b"},{"post_id":"cjcztkwl6002uvmvv0lafnad8","tag_id":"cjcztkwl80031vmvvl7p0t21w","_id":"cjcztkwl80033vmvvzjbnd9ul"}],"Tag":[{"name":"daily report","_id":"cjcztkwjl0004vmvvitjsnnb7"},{"name":"Python","_id":"cjcztkwkr001wvmvv32avxqlg"},{"name":"函数式","_id":"cjcztkwkx002dvmvv3za7v6b7"},{"name":"实习面试","_id":"cjcztkwl3002ovmvv87xf8inf"},{"name":"清单","_id":"cjcztkwl7002vvmvvq5fal01w"},{"name":"算法","_id":"cjcztkwl7002xvmvvccccm93t"},{"name":"计算机系统","_id":"cjcztkwl80031vmvvl7p0t21w"}]}}
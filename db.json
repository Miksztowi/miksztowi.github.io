{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"4fced88b3eac4bae63cf3f3475dbf0f3097e2250","modified":1516812172000},{"_id":"source/.DS_Store","hash":"18bc404250d941b4f475c07e0e639b9c4d72c1de","modified":1516812298000},{"_id":"source/baidu_verify_BT2qrx56qZ.html","hash":"1c08d9cab9c9f127a584eedc192957534636e7dc","modified":1509948677000},{"_id":"source/google4e36bdd00638b2e4.html","hash":"d42782bd087c8bd8363455e50689937774560e8f","modified":1509948699000},{"_id":"themes/yilia/.DS_Store","hash":"753dcab7738f7705d4c5ba8e8013ad3352198182","modified":1509788941000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1509778925000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1509778925000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1509778925000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1509778925000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1509778925000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1509778925000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1509778925000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1509778925000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1509778925000},{"_id":"themes/yilia/_config.yml","hash":"5a64fb1c4053bb2dddd88a1654e7c73913fce2ee","modified":1511944020000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1511930181000},{"_id":"source/_posts/2017-07-03.md","hash":"fc57b56f785ddf577db0414fc741504658d8da9e","modified":1509789060000},{"_id":"source/_posts/2017-07-04.md","hash":"b337dc36b52a33fa1fdfe36435d895ad7927f245","modified":1509787157000},{"_id":"source/_posts/2017-07-05.md","hash":"2503492ff7b18bb550beaf086bb99a0f45dcaff6","modified":1509787157000},{"_id":"source/_posts/2017-07-10.md","hash":"9362d3abbba31fa2f0869f029f76b205c00bae9d","modified":1509787157000},{"_id":"source/_posts/2017-07-11.md","hash":"3963fa22d4712d3df4c1951fd0d4343776bb61ee","modified":1509787157000},{"_id":"source/_posts/2017-07-06.md","hash":"4d9e9fe86102c00961049504a1bebcb8fc9d9cf3","modified":1509787157000},{"_id":"source/_posts/2017-07-07.md","hash":"db76a9ee02888bf9ab60c0e848676656c1de9be5","modified":1509787157000},{"_id":"source/_posts/2017-07-14.md","hash":"f40e2053d3ee6a0e6526712965978caaaa720576","modified":1509787157000},{"_id":"source/_posts/2017-07-13.md","hash":"c5ef118b4bf7b1e505ad746a72860524043a59a5","modified":1509787157000},{"_id":"source/_posts/2017-07-18.md","hash":"8ab9a4ccaa9fe0207316f0663c5311cde37d01fd","modified":1509787157000},{"_id":"source/_posts/2017-07-12.md","hash":"08b38b842c9151d149293ea3d580bfc9608471d9","modified":1509787157000},{"_id":"source/_posts/2017-07-19.md","hash":"3405f46c2b4757ca55e5dc5d7f67838a195438f1","modified":1509787157000},{"_id":"source/_posts/2017-07-20.md","hash":"272d67be82e4b66c466fe1256622441786364f2c","modified":1509787157000},{"_id":"source/_posts/2017-07-17.md","hash":"9ff2301f87722833fe3d10e3ad3c910de2f19621","modified":1509787157000},{"_id":"source/_posts/2017-07-21.md","hash":"77fd0e78a24bbc5b20f329951ebca79313b58032","modified":1509787157000},{"_id":"source/_posts/2017-07-24.md","hash":"fb1716c6180e377ccce369c15283cc491b2a14da","modified":1509787157000},{"_id":"source/_posts/2017-07-26.md","hash":"43ea5bb852c78a94fed3fbb14138b5af17b1951b","modified":1509787157000},{"_id":"source/_posts/2017-07-25.md","hash":"ab421de2c02c8814a7386d70f6c3707b4dfd6a35","modified":1509787157000},{"_id":"source/_posts/2017-08-02.md","hash":"8ce468a4626ec138e4633327ce0ece92a635dacd","modified":1509787157000},{"_id":"source/_posts/2017-07-31.md","hash":"6a2b60ea87a5f9e96fd8a30106d21826c3cfbea4","modified":1509787157000},{"_id":"source/_posts/2017-08-03.md","hash":"d9333c1c2ab4ecbd48198809e906e6b3aff38c75","modified":1509787157000},{"_id":"source/_posts/2017-07-28.md","hash":"de1993d74aa4f92efc7606b168b96ef30d54e823","modified":1509787157000},{"_id":"source/_posts/2017-08-01.md","hash":"ee2528ff39f45a7dd862018b9c0751dcc20b3d13","modified":1509787157000},{"_id":"source/_posts/2017-08-07.md","hash":"711cae88677e2dd5e4d43a3d309c8899e0d19d46","modified":1509787157000},{"_id":"source/_posts/2017-08-04.md","hash":"c8ea8135d4d6936588903f93798de2e32e172701","modified":1509789111000},{"_id":"source/_posts/2017-08-05.md","hash":"8f50a7ca6cf258dcf91ee7e7e0d5301efa7937dc","modified":1509789086000},{"_id":"source/_posts/2017-08-06.md","hash":"6fb59d7396987e93e0b986f3b6b35016dfea21d9","modified":1509789099000},{"_id":"source/_posts/2017-08-09.md","hash":"34cde762f93e5de7e82864c6ac59cbefd4f3a855","modified":1509787157000},{"_id":"source/_posts/2017-08-16.md","hash":"abb072342b34ee836bd8680065b537d871489c72","modified":1509787157000},{"_id":"source/_posts/2017-08-10.md","hash":"a0825d0b871aaad16c920f0ea5ba0269fb87a2eb","modified":1509787157000},{"_id":"source/_posts/2017-08-08.md","hash":"8d2eb36a52a3613080742258269a0767ed4551e4","modified":1509787157000},{"_id":"source/_posts/2017-08-14.md","hash":"a1b0e32774eacf68628c8929a6f5670fe54271a9","modified":1509787157000},{"_id":"source/_posts/2017-08-20.md","hash":"d484f75c53cbc901f70b3d852a1e61e0e4cd0289","modified":1509787157000},{"_id":"source/_posts/2017-08-18.md","hash":"047c358a1d6b37f00fb72fb1896e1bab4a0b5952","modified":1509787157000},{"_id":"source/_posts/Python-concurrency-with-futures.md","hash":"ea6fea68fed2c5fc3de2506ce4dbc7436308f4b0","modified":1513137897000},{"_id":"source/_posts/Python-Iterators-and-Iterables介绍.md","hash":"328143f55131091546183d2c0e553cee07c5df22","modified":1512198256000},{"_id":"source/_posts/Python-generator-介绍.md","hash":"2d153c333e0fcd06fc1bcd5d74469734f435d257","modified":1512205985000},{"_id":"source/_posts/Python-Function-Decorators-and-Closures介绍.md","hash":"4222bb5c5aa486018ec0e433cec70e3886250960","modified":1511943770000},{"_id":"source/_posts/Python-Coroutine介绍.md","hash":"0409c4e102f242af78dd3ed823ca99d86b7fae96","modified":1512975656000},{"_id":"source/_posts/python实现计算机网络rip协议.md","hash":"a526b6e982e7a64791aa1df170b7fbdaf633a4ad","modified":1509787953000},{"_id":"source/_posts/python暑期实习面试.md","hash":"0b4677c8531ad58500e82df3f7ec1b373e64434d","modified":1509787942000},{"_id":"source/_posts/《教父》摘录.md","hash":"a42000eeb334815c30ff9acedc5a7e9bb3f79f42","modified":1509787849000},{"_id":"source/_posts/Python内置模块bisect介绍.md","hash":"38f0f3726e653f6ab01416c0628f8554608c539c","modified":1511159669000},{"_id":"source/_posts/检查清单.md","hash":"a06f1fae06fb5a0bf8b0c6d01326896610a124b4","modified":1509787905000},{"_id":"source/_posts/函数式编程.md","hash":"69da9143df2a80b85948999ee86d33ae00b30c22","modified":1509787929000},{"_id":"source/_posts/问题清单.md","hash":"3c2552cdd71cdbc11653da33ac6228f85163ff3d","modified":1509787919000},{"_id":"source/_posts/联合-查找算法.md","hash":"a27f7f3b85b4f07d82f2462a4485d88b9dcd7ded","modified":1511930244000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1509778925000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1509778925000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1509778919000},{"_id":"themes/yilia/.git/packed-refs","hash":"bedf7f90d58d21e413c3898f5a97bf2aa606f6d1","modified":1509778925000},{"_id":"themes/yilia/.git/index","hash":"f8fda9b6f6180b599eb0db4eee80e1dd7e2a7ab1","modified":1511944239000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1509778925000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1509778925000},{"_id":"themes/yilia/layout/.DS_Store","hash":"9e99dd71aee0c54f2c18283eb97e1adf7e7786cc","modified":1509780128000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1509778925000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1509778925000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1509778925000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1509778925000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1509778925000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1509778925000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1509778925000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1509778925000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1509778925000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1509778925000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1509778925000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1509778925000},{"_id":"themes/yilia/source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1509784245000},{"_id":"themes/yilia/source/main.507b3a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1509778925000},{"_id":"themes/yilia/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1509784494000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1509778925000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1509778925000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1509778925000},{"_id":"themes/yilia/source/main.507b3a.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1509778925000},{"_id":"themes/yilia/source/mobile.fdc4b7.js","hash":"6bfff9bfe4d7e067b6289e851a4c424ac815af5e","modified":1509778925000},{"_id":"source/_posts/.idea/_posts.iml","hash":"48dc199a103922efac02e6f577f4a3e7a7d73dda","modified":1509784702000},{"_id":"source/_posts/.idea/modules.xml","hash":"6abd6dcb985048745c9214d67295bdf1597307ee","modified":1509784647000},{"_id":"source/_posts/.idea/workspace.xml","hash":"1d3eb55ecc29e6a1de0b57476d23a9a30fb829fd","modified":1509789416000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1509778919000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1509778919000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1509778919000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"5d70ee6a629c3c2cf0ba6cde250e036e5733c7fe","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/.DS_Store","hash":"939f356dbf6f237beac97ddeee3f1a45ebba51ef","modified":1509780128000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"b011d92be321ebe09fa2b3179c08aa435b9d051c","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1509778925000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1509778925000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1509778925000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1509778925000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1509778925000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1509778925000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1509778925000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1509778925000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1509778925000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1509778925000},{"_id":"themes/yilia/images/avatar.jpg","hash":"9805cb443cf3927f27dbc9fb21f51f09f2ac438c","modified":1507563665000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1509778925000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1509778925000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1509778925000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1509778925000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1509778925000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1509778925000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1509778925000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1509778925000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1509778925000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1509778925000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1509778925000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1509778925000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1509778925000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1509778925000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1509778925000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1509778925000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1509778925000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1509778925000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1509778925000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1509778925000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1509778925000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1509778925000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1509778925000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1509778925000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1509778925000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1509778925000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1509778925000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1509778925000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1509778925000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1509778925000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1509778925000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"7f9599ffd5c5551538e90b97023e7d6c599d1ee6","modified":1509778925000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1509778925000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1509778925000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1509778925000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1509778925000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"e8a35d4497fe1e0f119662ae08bd8404e5dab2a4","modified":1509778925000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1509778925000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"439f2afa6c3515a7edd67d512aae6eba5b1b0d0b","modified":1509778925000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"d53be7839d02167197dd0413db038f26fa1380b3","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"ec71ffc2023cebd933c96bd35a7a23d44a30a422","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1509778925000},{"_id":"themes/yilia/.git/objects/pack/pack-d4389efc6377253f805e9d2af6215b0bf9f7756f.idx","hash":"5bc8b08330b8cd90245e790fdb0c706f7f24d291","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1509778925000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1509778925000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1509778925000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1509778925000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1509778925000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1509778925000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1509778925000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1509778925000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1509778925000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1509778925000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1509778925000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1509778925000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1509778925000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1509778925000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"5d70ee6a629c3c2cf0ba6cde250e036e5733c7fe","modified":1509778925000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1509778925000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"5d70ee6a629c3c2cf0ba6cde250e036e5733c7fe","modified":1509778925000},{"_id":"themes/yilia/.git/objects/pack/pack-d4389efc6377253f805e9d2af6215b0bf9f7756f.pack","hash":"1509c6c075605b22dc283bd0d927dd0a0e3f8178","modified":1509778925000},{"_id":"public/baidu_verify_BT2qrx56qZ.html","hash":"fffa73f922a1d3a2885f77f843f32695c7ef4348","modified":1513137907382},{"_id":"public/google4e36bdd00638b2e4.html","hash":"338d3bd7abf221ba6b17d98eaef49f56a1f626f2","modified":1513137907830},{"_id":"public/baidusitemap.xml","hash":"74e79d54e223889e319c7a9aa809a07e35755fa3","modified":1516812311054},{"_id":"public/atom.xml","hash":"d777ffff0c23037bd96a667fae12e04445e7e982","modified":1516812311054},{"_id":"public/content.json","hash":"978837e14aed0f078a87917394fd223ef7c1a38f","modified":1516812311055},{"_id":"public/sitemap.xml","hash":"613dd8bc79c1e17a4e6e730691d266d1f3fddcb6","modified":1516812311055},{"_id":"public/2017/11/29/Python-Function-Decorators-and-Closures介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/12/11/Python-Coroutine介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/12/02/Python-generator-介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/11/20/Python内置模块bisect介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/11/06/联合-查找算法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/11/04/检查清单/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/11/04/问题清单/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/11/04/函数式编程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/12/02/Python-Iterators-and-Iterables介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/20/2017-08-20/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/18/2017-08-18/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/16/2017-08-16/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/14/2017-08-14/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/10/2017-08-10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/2017/08/09/2017-08-09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/08/2017-08-08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/07/2017-08-07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/06/2017-08-06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/05/2017-08-05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/04/2017-08-04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311064},{"_id":"public/2017/08/03/2017-08-03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/08/02/2017-08-02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/08/01/2017-08-01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/31/2017-07-31/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/28/2017-07-28/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/26/2017-07-26/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/25/2017-07-25/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/24/2017-07-24/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/21/2017-07-21/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/20/2017-07-20/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/19/2017-07-19/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/18/2017-07-18/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/17/2017-07-17/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/14/2017-07-14/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/13/2017-07-13/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/12/2017-07-12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/11/2017-07-11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/10/2017-07-10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311065},{"_id":"public/2017/07/07/2017-07-07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/07/06/2017-07-06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/07/05/2017-07-05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/07/04/2017-07-04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/07/03/2017-07-03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/06/16/python暑期实习面试/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/2017/06/06/《教父》摘录/index.html","hash":"e0b8b776b6099bab7471260530cb8e759537abff","modified":1513137907946},{"_id":"public/2017/06/01/python实现计算机网络rip协议/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311066},{"_id":"public/archives/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/07/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/07/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/07/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/archives/2017/08/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/archives/2017/08/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/archives/2017/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/archives/2017/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311067},{"_id":"public/archives/2017/11/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/archives/2017/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311069},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311070},{"_id":"public/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311070},{"_id":"public/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311070},{"_id":"public/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311070},{"_id":"public/tags/daily-report/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/daily-report/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/daily-report/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/page/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311070},{"_id":"public/tags/daily-report/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/daily-report/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/daily-report/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/daily-report/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/Python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/实习面试/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/读书笔记/index.html","hash":"97818a415f17e6589e88a9141e3fec7a30d6ac00","modified":1513137907953},{"_id":"public/tags/清单/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/函数式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/tags/算法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/2017/12/13/Python-concurrency-with-futures/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311063},{"_id":"public/tags/Python/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311068},{"_id":"public/CNAME","hash":"4fced88b3eac4bae63cf3f3475dbf0f3097e2250","modified":1516812311075},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1513137907963},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1513137907963},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1513137907963},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1513137907963},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1513137907963},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1513137907963},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1513137907963},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1513137907963},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1513137907963},{"_id":"public/main.507b3a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1513137907974},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1513137907974},{"_id":"public/main.507b3a.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1513137907974},{"_id":"public/mobile.fdc4b7.js","hash":"6bfff9bfe4d7e067b6289e851a4c424ac815af5e","modified":1513137907974},{"_id":"source/_posts/Python-asyncio模块介绍.md","hash":"d2195be563cd5086881893ab671b51731ac080a8","modified":1516811723000},{"_id":"public/2017/12/19/Python-asyncio模块介绍/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1516812311073}],"Category":[],"Data":[],"Page":[{"layout":"false","sitemap":false,"_content":"BT2qrx56qZ","source":"baidu_verify_BT2qrx56qZ.html","raw":"layout: false\nsitemap: false\n---\nBT2qrx56qZ","date":"2017-11-06T06:11:17.000Z","updated":"2017-11-06T06:11:17.000Z","path":"baidu_verify_BT2qrx56qZ.html","title":"","comments":1,"_id":"cjb4j8oor0000lvtlotafptey","content":"BT2qrx56qZ","site":{"data":{}},"excerpt":"","more":"BT2qrx56qZ"},{"layout":"false","sitemap":false,"_content":"google-site-verification: google4e36bdd00638b2e4.html","source":"google4e36bdd00638b2e4.html","raw":"layout: false\nsitemap: false\n---\ngoogle-site-verification: google4e36bdd00638b2e4.html","date":"2017-11-06T06:11:39.000Z","updated":"2017-11-06T06:11:39.000Z","path":"google4e36bdd00638b2e4.html","title":"","comments":1,"_id":"cjb4j8oos0001lvtla2qop7es","content":"google-site-verification: google4e36bdd00638b2e4.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google4e36bdd00638b2e4.html"}],"Post":[{"title":"2017-07-03 Report","date":"2017-07-03T07:27:45.000Z","_content":"今天做了什么\n\n\n写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。\n\n\n今天学到了什么\n\n\n今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我\n想当然\n的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行\nDouble check\n也使得问题迟迟没有被发现。所以，以后写代码\n不能想当然\n，只有\n通过Double check\n的逻辑，才是可以开始实现的逻辑。\n\n\nmac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。\n\n\n同样的错误不要犯两次。\n\n\n明天的计划\n1.继续找车型数据库。\n2.利用休息时间把mac上工作环境配置完善。\n3.尽力完成好mentor的每一个要求。","source":"_posts/2017-07-03.md","raw":"---\ntitle: 2017-07-03 Report\ndate: 2017-07-03 15:27:45\ntags: daily report\n---\n今天做了什么\n\n\n写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。\n\n\n今天学到了什么\n\n\n今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我\n想当然\n的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行\nDouble check\n也使得问题迟迟没有被发现。所以，以后写代码\n不能想当然\n，只有\n通过Double check\n的逻辑，才是可以开始实现的逻辑。\n\n\nmac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。\n\n\n同样的错误不要犯两次。\n\n\n明天的计划\n1.继续找车型数据库。\n2.利用休息时间把mac上工作环境配置完善。\n3.尽力完成好mentor的每一个要求。","slug":"2017-07-03","published":1,"updated":"2017-11-04T09:51:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opf0002lvtlssnrk5o3","content":"<p>今天做了什么</p>\n<p>写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。</p>\n<p>今天学到了什么</p>\n<p>今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我<br>想当然<br>的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行<br>Double check<br>也使得问题迟迟没有被发现。所以，以后写代码<br>不能想当然<br>，只有<br>通过Double check<br>的逻辑，才是可以开始实现的逻辑。</p>\n<p>mac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。</p>\n<p>同样的错误不要犯两次。</p>\n<p>明天的计划<br>1.继续找车型数据库。<br>2.利用休息时间把mac上工作环境配置完善。<br>3.尽力完成好mentor的每一个要求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天做了什么</p>\n<p>写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。</p>\n<p>今天学到了什么</p>\n<p>今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我<br>想当然<br>的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行<br>Double check<br>也使得问题迟迟没有被发现。所以，以后写代码<br>不能想当然<br>，只有<br>通过Double check<br>的逻辑，才是可以开始实现的逻辑。</p>\n<p>mac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。</p>\n<p>同样的错误不要犯两次。</p>\n<p>明天的计划<br>1.继续找车型数据库。<br>2.利用休息时间把mac上工作环境配置完善。<br>3.尽力完成好mentor的每一个要求。</p>\n"},{"title":"2017-07-04 Report","date":"2017-07-04T07:27:45.000Z","_content":"##当天完成的工作内容\n1.昨天写好的amazon’s API的脚本不能满足需求，xxxxxxxxx\n##当天的收获\n1.今天解决目标问题的时候，找到了几种解决办法，分别是用爬虫获取，手工逐个获取，使用API逐个获取。从方法上看写爬虫，涉及到的技术细节会是更广阔一些，但是最后实现目标的方法却是使用API手工获取。伟哥告诉我公司跟学校不一样，公司只看结果，最高效的办法就是最好的办法。但是学习跟办公同样也是不矛盾的，可以先解决问题，之后再利用业余时间去深究问题，做到对自我的提升。\n2.在伟哥的介绍下，了解了公司的部门分类.xxxxxxxxxxxxx\n##明天的计划\n1.明天要继续搭配Avatar的环境，现在伟哥给我提供的解决方案是看一遍Pyspider的代码后Build镜像（希望明天尽快解决环境问题）\n2.在1完成后，继续做amazon’s API的脚本。\n3.赵赵给我分配的xxxx\n##提出疑问或寻求帮助\n1.我挺好奇公司为什么在此时此刻（我理解的是产品迭代较快的时期）还会招实习生？","source":"_posts/2017-07-04.md","raw":"---\ntitle: 2017-07-04 Report\ndate: 2017-07-04 15:27:45\ntags: daily report\n---\n##当天完成的工作内容\n1.昨天写好的amazon’s API的脚本不能满足需求，xxxxxxxxx\n##当天的收获\n1.今天解决目标问题的时候，找到了几种解决办法，分别是用爬虫获取，手工逐个获取，使用API逐个获取。从方法上看写爬虫，涉及到的技术细节会是更广阔一些，但是最后实现目标的方法却是使用API手工获取。伟哥告诉我公司跟学校不一样，公司只看结果，最高效的办法就是最好的办法。但是学习跟办公同样也是不矛盾的，可以先解决问题，之后再利用业余时间去深究问题，做到对自我的提升。\n2.在伟哥的介绍下，了解了公司的部门分类.xxxxxxxxxxxxx\n##明天的计划\n1.明天要继续搭配Avatar的环境，现在伟哥给我提供的解决方案是看一遍Pyspider的代码后Build镜像（希望明天尽快解决环境问题）\n2.在1完成后，继续做amazon’s API的脚本。\n3.赵赵给我分配的xxxx\n##提出疑问或寻求帮助\n1.我挺好奇公司为什么在此时此刻（我理解的是产品迭代较快的时期）还会招实习生？","slug":"2017-07-04","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opi0003lvtltmbypsog","content":"<p>##当天完成的工作内容<br>1.昨天写好的amazon’s API的脚本不能满足需求，xxxxxxxxx</p>\n<p>##当天的收获<br>1.今天解决目标问题的时候，找到了几种解决办法，分别是用爬虫获取，手工逐个获取，使用API逐个获取。从方法上看写爬虫，涉及到的技术细节会是更广阔一些，但是最后实现目标的方法却是使用API手工获取。伟哥告诉我公司跟学校不一样，公司只看结果，最高效的办法就是最好的办法。但是学习跟办公同样也是不矛盾的，可以先解决问题，之后再利用业余时间去深究问题，做到对自我的提升。<br>2.在伟哥的介绍下，了解了公司的部门分类.xxxxxxxxxxxxx</p>\n<p>##明天的计划<br>1.明天要继续搭配Avatar的环境，现在伟哥给我提供的解决方案是看一遍Pyspider的代码后Build镜像（希望明天尽快解决环境问题）<br>2.在1完成后，继续做amazon’s API的脚本。<br>3.赵赵给我分配的xxxx</p>\n<p>##提出疑问或寻求帮助<br>1.我挺好奇公司为什么在此时此刻（我理解的是产品迭代较快的时期）还会招实习生？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##当天完成的工作内容<br>1.昨天写好的amazon’s API的脚本不能满足需求，xxxxxxxxx</p>\n<p>##当天的收获<br>1.今天解决目标问题的时候，找到了几种解决办法，分别是用爬虫获取，手工逐个获取，使用API逐个获取。从方法上看写爬虫，涉及到的技术细节会是更广阔一些，但是最后实现目标的方法却是使用API手工获取。伟哥告诉我公司跟学校不一样，公司只看结果，最高效的办法就是最好的办法。但是学习跟办公同样也是不矛盾的，可以先解决问题，之后再利用业余时间去深究问题，做到对自我的提升。<br>2.在伟哥的介绍下，了解了公司的部门分类.xxxxxxxxxxxxx</p>\n<p>##明天的计划<br>1.明天要继续搭配Avatar的环境，现在伟哥给我提供的解决方案是看一遍Pyspider的代码后Build镜像（希望明天尽快解决环境问题）<br>2.在1完成后，继续做amazon’s API的脚本。<br>3.赵赵给我分配的xxxx</p>\n<p>##提出疑问或寻求帮助<br>1.我挺好奇公司为什么在此时此刻（我理解的是产品迭代较快的时期）还会招实习生？</p>\n"},{"title":"2017-07-05 Report","date":"2017-07-05T07:27:45.000Z","_content":"##当天完成的工作内容\n1.今天写完了调用Amazon’s API根据xxxxxx的脚本\n##当天的收获\n1.今天配置Avatar的环境的时候，按照伟哥昨天给我提供的解决方案，Build完镜像后，我开始run镜像发现问题仍然存在，我又开始了【想当然】认为问题出在了镜像本身，但其实run镜像是无法解决问题的。所以在之后的过程中，我开始了对于工作来说无意义的思考。等到我把Google上和我能思考到的一切解决办法都尝试了之后，我没有思路了，我去问伟哥。伟哥先问我，遇到解决方向的选择时为什么不先问一下他，而是开始自己的【想当然】，因为我的想当然，又耗费了一个小时的代价。当时我心里很难受，也很内疚犯了一样的错误。（我时刻记得Nonda里同样的错误不要犯第二次的文化，真的很抱歉），等环境Ok后，下午的脚本编写中，关于方向和思路的选择上，我都先跟伟哥沟通一遍再开始进行（这样的效率的确提升了很多），最后脚本完成后，对数据进行了double check（调试的方法就是肉眼把50条数据过一遍，最快速有效的方法就是最合适的方法）。\n2.中午吃饭的时候，伟哥边吃饭边给我讲解了pyenv在生产环境的重要性，也教会了我使用Postman。我了解到了沙盒环境对于工作项目的必要性，Avatar环境的成功配置也是建立在这个基础上的。\n3.赵赵在交流中，时常给我一个暗示———节约自己和他人的时间。这个暗示在很多方面，大到租房的地段考虑，小到文本的颜色标注，这些都是提高个人的工作效率和同他人合作的工作效率的注意点，我觉得很有必要，也很值得学习，只是很遗憾每次都要让赵赵指正出来才能注意和学习到。\n##明天的计划\n1.工作计划我目前还不知道，不过我打算开始读Avatar的源码，尽快了解Avatar，希望自己早日为Avatar的开发也出一份力量。\n##提出疑问或寻求帮助\n无。","source":"_posts/2017-07-05.md","raw":"---\ntitle: 2017-07-05 Report\ndate: 2017-07-05 15:27:45\ntags: daily report\n---\n##当天完成的工作内容\n1.今天写完了调用Amazon’s API根据xxxxxx的脚本\n##当天的收获\n1.今天配置Avatar的环境的时候，按照伟哥昨天给我提供的解决方案，Build完镜像后，我开始run镜像发现问题仍然存在，我又开始了【想当然】认为问题出在了镜像本身，但其实run镜像是无法解决问题的。所以在之后的过程中，我开始了对于工作来说无意义的思考。等到我把Google上和我能思考到的一切解决办法都尝试了之后，我没有思路了，我去问伟哥。伟哥先问我，遇到解决方向的选择时为什么不先问一下他，而是开始自己的【想当然】，因为我的想当然，又耗费了一个小时的代价。当时我心里很难受，也很内疚犯了一样的错误。（我时刻记得Nonda里同样的错误不要犯第二次的文化，真的很抱歉），等环境Ok后，下午的脚本编写中，关于方向和思路的选择上，我都先跟伟哥沟通一遍再开始进行（这样的效率的确提升了很多），最后脚本完成后，对数据进行了double check（调试的方法就是肉眼把50条数据过一遍，最快速有效的方法就是最合适的方法）。\n2.中午吃饭的时候，伟哥边吃饭边给我讲解了pyenv在生产环境的重要性，也教会了我使用Postman。我了解到了沙盒环境对于工作项目的必要性，Avatar环境的成功配置也是建立在这个基础上的。\n3.赵赵在交流中，时常给我一个暗示———节约自己和他人的时间。这个暗示在很多方面，大到租房的地段考虑，小到文本的颜色标注，这些都是提高个人的工作效率和同他人合作的工作效率的注意点，我觉得很有必要，也很值得学习，只是很遗憾每次都要让赵赵指正出来才能注意和学习到。\n##明天的计划\n1.工作计划我目前还不知道，不过我打算开始读Avatar的源码，尽快了解Avatar，希望自己早日为Avatar的开发也出一份力量。\n##提出疑问或寻求帮助\n无。","slug":"2017-07-05","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opk0005lvtlziunbbum","content":"<p>##当天完成的工作内容<br>1.今天写完了调用Amazon’s API根据xxxxxx的脚本</p>\n<p>##当天的收获<br>1.今天配置Avatar的环境的时候，按照伟哥昨天给我提供的解决方案，Build完镜像后，我开始run镜像发现问题仍然存在，我又开始了【想当然】认为问题出在了镜像本身，但其实run镜像是无法解决问题的。所以在之后的过程中，我开始了对于工作来说无意义的思考。等到我把Google上和我能思考到的一切解决办法都尝试了之后，我没有思路了，我去问伟哥。伟哥先问我，遇到解决方向的选择时为什么不先问一下他，而是开始自己的【想当然】，因为我的想当然，又耗费了一个小时的代价。当时我心里很难受，也很内疚犯了一样的错误。（我时刻记得Nonda里同样的错误不要犯第二次的文化，真的很抱歉），等环境Ok后，下午的脚本编写中，关于方向和思路的选择上，我都先跟伟哥沟通一遍再开始进行（这样的效率的确提升了很多），最后脚本完成后，对数据进行了double check（调试的方法就是肉眼把50条数据过一遍，最快速有效的方法就是最合适的方法）。<br>2.中午吃饭的时候，伟哥边吃饭边给我讲解了pyenv在生产环境的重要性，也教会了我使用Postman。我了解到了沙盒环境对于工作项目的必要性，Avatar环境的成功配置也是建立在这个基础上的。<br>3.赵赵在交流中，时常给我一个暗示———节约自己和他人的时间。这个暗示在很多方面，大到租房的地段考虑，小到文本的颜色标注，这些都是提高个人的工作效率和同他人合作的工作效率的注意点，我觉得很有必要，也很值得学习，只是很遗憾每次都要让赵赵指正出来才能注意和学习到。</p>\n<p>##明天的计划<br>1.工作计划我目前还不知道，不过我打算开始读Avatar的源码，尽快了解Avatar，希望自己早日为Avatar的开发也出一份力量。</p>\n<p>##提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##当天完成的工作内容<br>1.今天写完了调用Amazon’s API根据xxxxxx的脚本</p>\n<p>##当天的收获<br>1.今天配置Avatar的环境的时候，按照伟哥昨天给我提供的解决方案，Build完镜像后，我开始run镜像发现问题仍然存在，我又开始了【想当然】认为问题出在了镜像本身，但其实run镜像是无法解决问题的。所以在之后的过程中，我开始了对于工作来说无意义的思考。等到我把Google上和我能思考到的一切解决办法都尝试了之后，我没有思路了，我去问伟哥。伟哥先问我，遇到解决方向的选择时为什么不先问一下他，而是开始自己的【想当然】，因为我的想当然，又耗费了一个小时的代价。当时我心里很难受，也很内疚犯了一样的错误。（我时刻记得Nonda里同样的错误不要犯第二次的文化，真的很抱歉），等环境Ok后，下午的脚本编写中，关于方向和思路的选择上，我都先跟伟哥沟通一遍再开始进行（这样的效率的确提升了很多），最后脚本完成后，对数据进行了double check（调试的方法就是肉眼把50条数据过一遍，最快速有效的方法就是最合适的方法）。<br>2.中午吃饭的时候，伟哥边吃饭边给我讲解了pyenv在生产环境的重要性，也教会了我使用Postman。我了解到了沙盒环境对于工作项目的必要性，Avatar环境的成功配置也是建立在这个基础上的。<br>3.赵赵在交流中，时常给我一个暗示———节约自己和他人的时间。这个暗示在很多方面，大到租房的地段考虑，小到文本的颜色标注，这些都是提高个人的工作效率和同他人合作的工作效率的注意点，我觉得很有必要，也很值得学习，只是很遗憾每次都要让赵赵指正出来才能注意和学习到。</p>\n<p>##明天的计划<br>1.工作计划我目前还不知道，不过我打算开始读Avatar的源码，尽快了解Avatar，希望自己早日为Avatar的开发也出一份力量。</p>\n<p>##提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-10 Report","date":"2017-07-10T07:27:45.000Z","_content":"今天感觉好疲惫，daily report没有用心写了QAQ\n\n当天完成的工作内容\n1.修复了xxxx前端和后端的几个小bug。\n当天的收获\n1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。\n明天的计划\n1.继续熟悉avatar数据处理部分的逻辑。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-10.md","raw":"---\ntitle: 2017-07-10 Report\ndate: 2017-07-10 15:27:45\ntags: daily report\n---\n今天感觉好疲惫，daily report没有用心写了QAQ\n\n当天完成的工作内容\n1.修复了xxxx前端和后端的几个小bug。\n当天的收获\n1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。\n明天的计划\n1.继续熟悉avatar数据处理部分的逻辑。\n提出疑问或寻求帮助\n无。","slug":"2017-07-10","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opl0006lvtlgj1i5r7e","content":"<p>今天感觉好疲惫，daily report没有用心写了QAQ</p>\n<p>当天完成的工作内容<br>1.修复了xxxx前端和后端的几个小bug。<br>当天的收获<br>1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。<br>明天的计划<br>1.继续熟悉avatar数据处理部分的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天感觉好疲惫，daily report没有用心写了QAQ</p>\n<p>当天完成的工作内容<br>1.修复了xxxx前端和后端的几个小bug。<br>当天的收获<br>1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。<br>明天的计划<br>1.继续熟悉avatar数据处理部分的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-11 Report","date":"2017-07-11T07:27:45.000Z","_content":"当天完成的工作内容\n1.写了一个xxxxxapi。\n当天的收获\n1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。\n2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。\n明天的计划\n1.继续熟悉avatar的架构。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-11.md","raw":"---\ntitle: 2017-07-11 Report\ndate: 2017-07-11 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.写了一个xxxxxapi。\n当天的收获\n1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。\n2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。\n明天的计划\n1.继续熟悉avatar的架构。\n提出疑问或寻求帮助\n无。","slug":"2017-07-11","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opl0007lvtlvq5y13cc","content":"<p>当天完成的工作内容<br>1.写了一个xxxxxapi。<br>当天的收获<br>1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。<br>2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。<br>明天的计划<br>1.继续熟悉avatar的架构。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.写了一个xxxxxapi。<br>当天的收获<br>1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。<br>2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。<br>明天的计划<br>1.继续熟悉avatar的架构。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-06 Report","date":"2017-07-06T07:27:45.000Z","_content":"##当天完成的工作内容\n1.看了Avatar中XXX的代码。\n2.在1的基础上，写了调用Aamzon’s API输入xxxx，输出XXXXX到数据库中的脚本。\n##当天的收获\n1.今天晚上完善API的时候，发现下班前跟伟哥关于XXX的输入这点没有沟通到，但是按照伟哥要求的功能来说，这部分的功能是需要实现的。这是方向上的选择，这种问题不能【想当然】，所以我跟伟哥进行沟通，沟通后对于实现目标有了更清晰的理解。（如果再按照想当然来很可能白花晚上的时间，第二天还需要耗费尽力去补漏洞），希望自己尽可能的提高工作效率。\n2.今天看代码的时候，有两处看了很久，也调试了很久，不过还是没有理解逻辑。第一处被卡住的原因是由于自己多想了别的逻辑，增加了理解代码的难度，但其实代码的意思很明确也很简单。伟哥给的建议是，提问题或者思考的时候就应该反应最开始的思路，不要增加自己和别人理解意思的难度。\n##明天的计划\n1.明天要保证伟哥要求的实现的两个API可以正常的运行处结果。\n2.在1的基础上，对第二个API进行内部的封装，使得不用输入xxx这个参数，减小调试API的复杂度。\n##提出疑问或寻求帮助\n今天有听到赵赵说platform要节奏感，咱们要的是什么节奏感？ ","source":"_posts/2017-07-06.md","raw":"---\ntitle: 2017-07-06 Report\ndate: 2017-07-06 15:27:45\ntags: daily report\n---\n##当天完成的工作内容\n1.看了Avatar中XXX的代码。\n2.在1的基础上，写了调用Aamzon’s API输入xxxx，输出XXXXX到数据库中的脚本。\n##当天的收获\n1.今天晚上完善API的时候，发现下班前跟伟哥关于XXX的输入这点没有沟通到，但是按照伟哥要求的功能来说，这部分的功能是需要实现的。这是方向上的选择，这种问题不能【想当然】，所以我跟伟哥进行沟通，沟通后对于实现目标有了更清晰的理解。（如果再按照想当然来很可能白花晚上的时间，第二天还需要耗费尽力去补漏洞），希望自己尽可能的提高工作效率。\n2.今天看代码的时候，有两处看了很久，也调试了很久，不过还是没有理解逻辑。第一处被卡住的原因是由于自己多想了别的逻辑，增加了理解代码的难度，但其实代码的意思很明确也很简单。伟哥给的建议是，提问题或者思考的时候就应该反应最开始的思路，不要增加自己和别人理解意思的难度。\n##明天的计划\n1.明天要保证伟哥要求的实现的两个API可以正常的运行处结果。\n2.在1的基础上，对第二个API进行内部的封装，使得不用输入xxx这个参数，减小调试API的复杂度。\n##提出疑问或寻求帮助\n今天有听到赵赵说platform要节奏感，咱们要的是什么节奏感？ ","slug":"2017-07-06","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opn000alvtl49om4z64","content":"<p>##当天完成的工作内容<br>1.看了Avatar中XXX的代码。<br>2.在1的基础上，写了调用Aamzon’s API输入xxxx，输出XXXXX到数据库中的脚本。</p>\n<p>##当天的收获<br>1.今天晚上完善API的时候，发现下班前跟伟哥关于XXX的输入这点没有沟通到，但是按照伟哥要求的功能来说，这部分的功能是需要实现的。这是方向上的选择，这种问题不能【想当然】，所以我跟伟哥进行沟通，沟通后对于实现目标有了更清晰的理解。（如果再按照想当然来很可能白花晚上的时间，第二天还需要耗费尽力去补漏洞），希望自己尽可能的提高工作效率。<br>2.今天看代码的时候，有两处看了很久，也调试了很久，不过还是没有理解逻辑。第一处被卡住的原因是由于自己多想了别的逻辑，增加了理解代码的难度，但其实代码的意思很明确也很简单。伟哥给的建议是，提问题或者思考的时候就应该反应最开始的思路，不要增加自己和别人理解意思的难度。</p>\n<p>##明天的计划<br>1.明天要保证伟哥要求的实现的两个API可以正常的运行处结果。<br>2.在1的基础上，对第二个API进行内部的封装，使得不用输入xxx这个参数，减小调试API的复杂度。</p>\n<p>##提出疑问或寻求帮助<br>今天有听到赵赵说platform要节奏感，咱们要的是什么节奏感？ </p>\n","site":{"data":{}},"excerpt":"","more":"<p>##当天完成的工作内容<br>1.看了Avatar中XXX的代码。<br>2.在1的基础上，写了调用Aamzon’s API输入xxxx，输出XXXXX到数据库中的脚本。</p>\n<p>##当天的收获<br>1.今天晚上完善API的时候，发现下班前跟伟哥关于XXX的输入这点没有沟通到，但是按照伟哥要求的功能来说，这部分的功能是需要实现的。这是方向上的选择，这种问题不能【想当然】，所以我跟伟哥进行沟通，沟通后对于实现目标有了更清晰的理解。（如果再按照想当然来很可能白花晚上的时间，第二天还需要耗费尽力去补漏洞），希望自己尽可能的提高工作效率。<br>2.今天看代码的时候，有两处看了很久，也调试了很久，不过还是没有理解逻辑。第一处被卡住的原因是由于自己多想了别的逻辑，增加了理解代码的难度，但其实代码的意思很明确也很简单。伟哥给的建议是，提问题或者思考的时候就应该反应最开始的思路，不要增加自己和别人理解意思的难度。</p>\n<p>##明天的计划<br>1.明天要保证伟哥要求的实现的两个API可以正常的运行处结果。<br>2.在1的基础上，对第二个API进行内部的封装，使得不用输入xxx这个参数，减小调试API的复杂度。</p>\n<p>##提出疑问或寻求帮助<br>今天有听到赵赵说platform要节奏感，咱们要的是什么节奏感？ </p>\n"},{"title":"2017-07-07 Report","date":"2017-07-07T07:27:45.000Z","_content":"当天完成的工作内容\n写了两个API，xxxxxxxxxxx\n当天的收获\n用一个例子来总结一下关于遇到问题时的方法论。\n遇到的问题：某段数据被重复的打印出来\n1.我当时的思路和推导过程：\n看到数据被重复打印—>我在函数内部写了一条Print语句—>程序将Print语句重复执行了—>我将其判定错误的原因是死循环—>我开始在函数的内部debug寻找导致死循环的代码—>不断的修改变量—>观察debug结果—>始终没有在内部找到原因—>问题得不到解决。\n2.伟哥的思路和推导过程：\n伟哥看到我一直对数据debug—>伟哥问我凭什么判定是内部死循环了—>伟哥的意思是1.凭什么认为是死循环2.就算是死循环凭什么发生在内部而不是外部逻辑出错—>对这两个假设进行验证—>假设1，在我当时的思路中已经在用在内部增加Print语句将其验证成立—>假设2，如果问题发生在了内部，那么Avatar中使用这部分代码的其他模块应该也会出错—>其他模块功能正常—>假设2不成立，则表明目前问题不是出现在内部—>那么假设死循环发生在外部的逻辑调用上—>在外部debug调试—>发现问题出在将函数调用的语句写在了while循环内—>循环的退出条件存在问题，导致了死循环的调用—>假设成立，目前定位到问题是外部逻辑上发生了死循环—>重写while循环的退出条件—>运行程序，打印结果正常—>问题解决。\n3.重新推导这个过程：\n看到数据重复打印—>先思考如果是死循环的话会发生什么现象—>两点现象1.输出的语句被重复打印2.程序除非手动终止，否则会一直运行—>开始验证问题是否会发生这两点现象—>在程序内部写一条print语句—>程序运行后将print语句重复执行，并且在一直循环没有退出—>符合发生死循环的现象—>假设目前的问题是死循环成立—>假设1，死循环发生在函数内部。假设2，死循环发生在函数外部—>验证假设1，观察Avatar中同样调用这部分代码的模块—>观察功能运行是否正常—>功能正常，则代表函数内部没有问题—>假设1不成立。—>验证假设2，死循环发生在函数外部—>对外部逻辑进行debug—>发现将函数在没有控制好退出条件的while循环中进行了调用—>假设2成立，死循环发生在了函数外部—>重写while循环的退出条件—>再次运行模块—>打印结果正常，模块功能正常实现—>问题得到解决。\n遇到问题思考出可执行的Action plan的方法：\n遇到问题—>先假设出问题的发生情况—>缩小问题的范围—>开始对假设逐个进行逻辑验证和思考可执行的测试方法—>得出可执行的action plan—>对假设进行实践验证—>假设如果不成立，再次对其余假设进行思考总结出可执行的action plan后实际验证—>假设成立，代表问题发生与假设相同—>按照之前思考出来的action plan进行实际操作与修复—>修复结束后—>在相同的环境下，再次运行程序—>观察程序结果，确保程序功能正常—>问题得到解决。\n记住 “解决问题应该追求高效的方法，而不是凭借混出来的’经验’”\n明天的计划\n周末看Avatar的xxx和xxx部分的源码，理解Avatar后端的逻辑。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-07.md","raw":"---\ntitle: 2017-07-07 Report\ndate: 2017-07-07 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n写了两个API，xxxxxxxxxxx\n当天的收获\n用一个例子来总结一下关于遇到问题时的方法论。\n遇到的问题：某段数据被重复的打印出来\n1.我当时的思路和推导过程：\n看到数据被重复打印—>我在函数内部写了一条Print语句—>程序将Print语句重复执行了—>我将其判定错误的原因是死循环—>我开始在函数的内部debug寻找导致死循环的代码—>不断的修改变量—>观察debug结果—>始终没有在内部找到原因—>问题得不到解决。\n2.伟哥的思路和推导过程：\n伟哥看到我一直对数据debug—>伟哥问我凭什么判定是内部死循环了—>伟哥的意思是1.凭什么认为是死循环2.就算是死循环凭什么发生在内部而不是外部逻辑出错—>对这两个假设进行验证—>假设1，在我当时的思路中已经在用在内部增加Print语句将其验证成立—>假设2，如果问题发生在了内部，那么Avatar中使用这部分代码的其他模块应该也会出错—>其他模块功能正常—>假设2不成立，则表明目前问题不是出现在内部—>那么假设死循环发生在外部的逻辑调用上—>在外部debug调试—>发现问题出在将函数调用的语句写在了while循环内—>循环的退出条件存在问题，导致了死循环的调用—>假设成立，目前定位到问题是外部逻辑上发生了死循环—>重写while循环的退出条件—>运行程序，打印结果正常—>问题解决。\n3.重新推导这个过程：\n看到数据重复打印—>先思考如果是死循环的话会发生什么现象—>两点现象1.输出的语句被重复打印2.程序除非手动终止，否则会一直运行—>开始验证问题是否会发生这两点现象—>在程序内部写一条print语句—>程序运行后将print语句重复执行，并且在一直循环没有退出—>符合发生死循环的现象—>假设目前的问题是死循环成立—>假设1，死循环发生在函数内部。假设2，死循环发生在函数外部—>验证假设1，观察Avatar中同样调用这部分代码的模块—>观察功能运行是否正常—>功能正常，则代表函数内部没有问题—>假设1不成立。—>验证假设2，死循环发生在函数外部—>对外部逻辑进行debug—>发现将函数在没有控制好退出条件的while循环中进行了调用—>假设2成立，死循环发生在了函数外部—>重写while循环的退出条件—>再次运行模块—>打印结果正常，模块功能正常实现—>问题得到解决。\n遇到问题思考出可执行的Action plan的方法：\n遇到问题—>先假设出问题的发生情况—>缩小问题的范围—>开始对假设逐个进行逻辑验证和思考可执行的测试方法—>得出可执行的action plan—>对假设进行实践验证—>假设如果不成立，再次对其余假设进行思考总结出可执行的action plan后实际验证—>假设成立，代表问题发生与假设相同—>按照之前思考出来的action plan进行实际操作与修复—>修复结束后—>在相同的环境下，再次运行程序—>观察程序结果，确保程序功能正常—>问题得到解决。\n记住 “解决问题应该追求高效的方法，而不是凭借混出来的’经验’”\n明天的计划\n周末看Avatar的xxx和xxx部分的源码，理解Avatar后端的逻辑。\n提出疑问或寻求帮助\n无。","slug":"2017-07-07","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opo000clvtlsn92mifa","content":"<p>当天完成的工作内容<br>写了两个API，xxxxxxxxxxx<br>当天的收获<br>用一个例子来总结一下关于遇到问题时的方法论。<br>遇到的问题：某段数据被重复的打印出来<br>1.我当时的思路和推导过程：<br>看到数据被重复打印—&gt;我在函数内部写了一条Print语句—&gt;程序将Print语句重复执行了—&gt;我将其判定错误的原因是死循环—&gt;我开始在函数的内部debug寻找导致死循环的代码—&gt;不断的修改变量—&gt;观察debug结果—&gt;始终没有在内部找到原因—&gt;问题得不到解决。<br>2.伟哥的思路和推导过程：<br>伟哥看到我一直对数据debug—&gt;伟哥问我凭什么判定是内部死循环了—&gt;伟哥的意思是1.凭什么认为是死循环2.就算是死循环凭什么发生在内部而不是外部逻辑出错—&gt;对这两个假设进行验证—&gt;假设1，在我当时的思路中已经在用在内部增加Print语句将其验证成立—&gt;假设2，如果问题发生在了内部，那么Avatar中使用这部分代码的其他模块应该也会出错—&gt;其他模块功能正常—&gt;假设2不成立，则表明目前问题不是出现在内部—&gt;那么假设死循环发生在外部的逻辑调用上—&gt;在外部debug调试—&gt;发现问题出在将函数调用的语句写在了while循环内—&gt;循环的退出条件存在问题，导致了死循环的调用—&gt;假设成立，目前定位到问题是外部逻辑上发生了死循环—&gt;重写while循环的退出条件—&gt;运行程序，打印结果正常—&gt;问题解决。<br>3.重新推导这个过程：<br>看到数据重复打印—&gt;先思考如果是死循环的话会发生什么现象—&gt;两点现象1.输出的语句被重复打印2.程序除非手动终止，否则会一直运行—&gt;开始验证问题是否会发生这两点现象—&gt;在程序内部写一条print语句—&gt;程序运行后将print语句重复执行，并且在一直循环没有退出—&gt;符合发生死循环的现象—&gt;假设目前的问题是死循环成立—&gt;假设1，死循环发生在函数内部。假设2，死循环发生在函数外部—&gt;验证假设1，观察Avatar中同样调用这部分代码的模块—&gt;观察功能运行是否正常—&gt;功能正常，则代表函数内部没有问题—&gt;假设1不成立。—&gt;验证假设2，死循环发生在函数外部—&gt;对外部逻辑进行debug—&gt;发现将函数在没有控制好退出条件的while循环中进行了调用—&gt;假设2成立，死循环发生在了函数外部—&gt;重写while循环的退出条件—&gt;再次运行模块—&gt;打印结果正常，模块功能正常实现—&gt;问题得到解决。<br>遇到问题思考出可执行的Action plan的方法：<br>遇到问题—&gt;先假设出问题的发生情况—&gt;缩小问题的范围—&gt;开始对假设逐个进行逻辑验证和思考可执行的测试方法—&gt;得出可执行的action plan—&gt;对假设进行实践验证—&gt;假设如果不成立，再次对其余假设进行思考总结出可执行的action plan后实际验证—&gt;假设成立，代表问题发生与假设相同—&gt;按照之前思考出来的action plan进行实际操作与修复—&gt;修复结束后—&gt;在相同的环境下，再次运行程序—&gt;观察程序结果，确保程序功能正常—&gt;问题得到解决。<br>记住 “解决问题应该追求高效的方法，而不是凭借混出来的’经验’”<br>明天的计划<br>周末看Avatar的xxx和xxx部分的源码，理解Avatar后端的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>写了两个API，xxxxxxxxxxx<br>当天的收获<br>用一个例子来总结一下关于遇到问题时的方法论。<br>遇到的问题：某段数据被重复的打印出来<br>1.我当时的思路和推导过程：<br>看到数据被重复打印—&gt;我在函数内部写了一条Print语句—&gt;程序将Print语句重复执行了—&gt;我将其判定错误的原因是死循环—&gt;我开始在函数的内部debug寻找导致死循环的代码—&gt;不断的修改变量—&gt;观察debug结果—&gt;始终没有在内部找到原因—&gt;问题得不到解决。<br>2.伟哥的思路和推导过程：<br>伟哥看到我一直对数据debug—&gt;伟哥问我凭什么判定是内部死循环了—&gt;伟哥的意思是1.凭什么认为是死循环2.就算是死循环凭什么发生在内部而不是外部逻辑出错—&gt;对这两个假设进行验证—&gt;假设1，在我当时的思路中已经在用在内部增加Print语句将其验证成立—&gt;假设2，如果问题发生在了内部，那么Avatar中使用这部分代码的其他模块应该也会出错—&gt;其他模块功能正常—&gt;假设2不成立，则表明目前问题不是出现在内部—&gt;那么假设死循环发生在外部的逻辑调用上—&gt;在外部debug调试—&gt;发现问题出在将函数调用的语句写在了while循环内—&gt;循环的退出条件存在问题，导致了死循环的调用—&gt;假设成立，目前定位到问题是外部逻辑上发生了死循环—&gt;重写while循环的退出条件—&gt;运行程序，打印结果正常—&gt;问题解决。<br>3.重新推导这个过程：<br>看到数据重复打印—&gt;先思考如果是死循环的话会发生什么现象—&gt;两点现象1.输出的语句被重复打印2.程序除非手动终止，否则会一直运行—&gt;开始验证问题是否会发生这两点现象—&gt;在程序内部写一条print语句—&gt;程序运行后将print语句重复执行，并且在一直循环没有退出—&gt;符合发生死循环的现象—&gt;假设目前的问题是死循环成立—&gt;假设1，死循环发生在函数内部。假设2，死循环发生在函数外部—&gt;验证假设1，观察Avatar中同样调用这部分代码的模块—&gt;观察功能运行是否正常—&gt;功能正常，则代表函数内部没有问题—&gt;假设1不成立。—&gt;验证假设2，死循环发生在函数外部—&gt;对外部逻辑进行debug—&gt;发现将函数在没有控制好退出条件的while循环中进行了调用—&gt;假设2成立，死循环发生在了函数外部—&gt;重写while循环的退出条件—&gt;再次运行模块—&gt;打印结果正常，模块功能正常实现—&gt;问题得到解决。<br>遇到问题思考出可执行的Action plan的方法：<br>遇到问题—&gt;先假设出问题的发生情况—&gt;缩小问题的范围—&gt;开始对假设逐个进行逻辑验证和思考可执行的测试方法—&gt;得出可执行的action plan—&gt;对假设进行实践验证—&gt;假设如果不成立，再次对其余假设进行思考总结出可执行的action plan后实际验证—&gt;假设成立，代表问题发生与假设相同—&gt;按照之前思考出来的action plan进行实际操作与修复—&gt;修复结束后—&gt;在相同的环境下，再次运行程序—&gt;观察程序结果，确保程序功能正常—&gt;问题得到解决。<br>记住 “解决问题应该追求高效的方法，而不是凭借混出来的’经验’”<br>明天的计划<br>周末看Avatar的xxx和xxx部分的源码，理解Avatar后端的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-14 Report","date":"2017-07-14T07:27:45.000Z","_content":"当天完成的工作内容\n1.给伟哥提供了几种解决【xxxx】的解决方案。\n当天的收获\n1.以下内容是当时整个问题的解决流程：\n在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。\n以下是反思部分：\n遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。\n以下是总结部分：\n遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。\n明天的计划\n1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-14.md","raw":"---\ntitle: 2017-07-14 Report\ndate: 2017-07-14 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.给伟哥提供了几种解决【xxxx】的解决方案。\n当天的收获\n1.以下内容是当时整个问题的解决流程：\n在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。\n以下是反思部分：\n遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。\n以下是总结部分：\n遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。\n明天的计划\n1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。\n提出疑问或寻求帮助\n无。","slug":"2017-07-14","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opp000flvtl02oiywh6","content":"<p>当天完成的工作内容<br>1.给伟哥提供了几种解决【xxxx】的解决方案。<br>当天的收获<br>1.以下内容是当时整个问题的解决流程：<br>在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。<br>以下是反思部分：<br>遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。<br>以下是总结部分：<br>遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。<br>明天的计划<br>1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.给伟哥提供了几种解决【xxxx】的解决方案。<br>当天的收获<br>1.以下内容是当时整个问题的解决流程：<br>在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。<br>以下是反思部分：<br>遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。<br>以下是总结部分：<br>遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。<br>明天的计划<br>1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-13 Report","date":"2017-07-13T07:27:45.000Z","_content":"当天完成的工作内容\n1.将基于xxxxx的xxx功能剥离出来单独实现。\n2.思考了两种实现【xxxxxxx】这个功能的方案。\n当天的收获\n1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！\n先来梳理一下scrum的四个核心理念：\n\n\n以团队为核心\n\n\n循环迭代交付\n\n\n定期复盘调整\n\n\n透明，暴露问题\n明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。\n\n\n通过今天的培训，我有几点感悟：\n\n\n我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。\n\n\n制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。\n\n\n及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。\n\n\n最后一点是我认为导致今天发生的几个问题的最主要的原因，\nPO职责的履行不到位\n，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。\n\n\n明天的计划\n1.思考【xxxx】的其余实现思路。\n2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-13.md","raw":"---\ntitle: 2017-07-13 Report\ndate: 2017-07-13 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.将基于xxxxx的xxx功能剥离出来单独实现。\n2.思考了两种实现【xxxxxxx】这个功能的方案。\n当天的收获\n1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！\n先来梳理一下scrum的四个核心理念：\n\n\n以团队为核心\n\n\n循环迭代交付\n\n\n定期复盘调整\n\n\n透明，暴露问题\n明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。\n\n\n通过今天的培训，我有几点感悟：\n\n\n我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。\n\n\n制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。\n\n\n及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。\n\n\n最后一点是我认为导致今天发生的几个问题的最主要的原因，\nPO职责的履行不到位\n，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。\n\n\n明天的计划\n1.思考【xxxx】的其余实现思路。\n2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。\n提出疑问或寻求帮助\n无。","slug":"2017-07-13","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opp000hlvtlulvj8pnf","content":"<p>当天完成的工作内容<br>1.将基于xxxxx的xxx功能剥离出来单独实现。<br>2.思考了两种实现【xxxxxxx】这个功能的方案。<br>当天的收获<br>1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！<br>先来梳理一下scrum的四个核心理念：</p>\n<p>以团队为核心</p>\n<p>循环迭代交付</p>\n<p>定期复盘调整</p>\n<p>透明，暴露问题<br>明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。</p>\n<p>通过今天的培训，我有几点感悟：</p>\n<p>我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。</p>\n<p>制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。</p>\n<p>及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。</p>\n<p>最后一点是我认为导致今天发生的几个问题的最主要的原因，<br>PO职责的履行不到位<br>，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。</p>\n<p>明天的计划<br>1.思考【xxxx】的其余实现思路。<br>2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.将基于xxxxx的xxx功能剥离出来单独实现。<br>2.思考了两种实现【xxxxxxx】这个功能的方案。<br>当天的收获<br>1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！<br>先来梳理一下scrum的四个核心理念：</p>\n<p>以团队为核心</p>\n<p>循环迭代交付</p>\n<p>定期复盘调整</p>\n<p>透明，暴露问题<br>明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。</p>\n<p>通过今天的培训，我有几点感悟：</p>\n<p>我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。</p>\n<p>制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。</p>\n<p>及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。</p>\n<p>最后一点是我认为导致今天发生的几个问题的最主要的原因，<br>PO职责的履行不到位<br>，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。</p>\n<p>明天的计划<br>1.思考【xxxx】的其余实现思路。<br>2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-18 Report","date":"2017-07-18T07:27:45.000Z","_content":"对于2017\n 07\n 17的daily report赵赵的回复。\n这个总结不合格。\n\n自己的问题，自己先问6次为什么（自己解答），然后再问别人。\n你现在还是抓不住重点。\n\n我描述你的问题是：问问题的时候描述太多\n反思的原因是：\n1. 抓不住重点\n2. 没有自己考虑周全\n\n那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。\n我上周已经告诉你了，先找到根本原因，在想action plan！\n我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！\n\n当天完成的工作内容\n1.写了xxx api\n2.在xxxx的函数里增加了xxxx的逻辑\n当天的收获\n1.对7月17提出的【如何去问问题】重新总结。\n问题\n：问问题时描述太多，太啰嗦。\n原因\n：\n\n\n提问时抓不住问题的重点 –> 提问之前，没有把问题的原因理解清楚 –> 急于寻找答案，未能静下心思考 –> 思维有惰性，希望答案可以不劳而获 –> 依赖他人，独立解决问题的能力差\n\n\n对问题考虑不全面 –>  对问题的解决方案有遗漏 –> 假设问题发生的情况时有遗漏 –> 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。\n\n\n总结\n：\n因为原因2中包含了原因1，所以先对原因2总结action plan。\n\n\n遇到问题 –> 立刻把问题写在纸上（不可只在脑中思考） –>  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –> 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –> 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –> 如果二叉树的叶子节点中已经存在问题发生的原因 –> 针对原因，思考问题的解决方案 –> 利用目前可用的所有工具（google，man，document）去找到对应的答案 –> 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （\n以上每一步的过程必须有记录，绝不可以只在脑中完成。\n）\n\n\n如果1中的办法未能找到正确的答案 –> 重复1并且每次结束后查阅记录信息 –> 如果连续6次的记录信息都一样 –> 表明一直被卡在了同一个地方 –> 此时才可以寻问他人 –> 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –> 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。\n\n\n明天的计划\n1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-18.md","raw":"---\ntitle: 2017-07-18 Report\ndate: 2017-07-18 15:27:45\ntags: daily report\n---\n对于2017\n 07\n 17的daily report赵赵的回复。\n这个总结不合格。\n\n自己的问题，自己先问6次为什么（自己解答），然后再问别人。\n你现在还是抓不住重点。\n\n我描述你的问题是：问问题的时候描述太多\n反思的原因是：\n1. 抓不住重点\n2. 没有自己考虑周全\n\n那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。\n我上周已经告诉你了，先找到根本原因，在想action plan！\n我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！\n\n当天完成的工作内容\n1.写了xxx api\n2.在xxxx的函数里增加了xxxx的逻辑\n当天的收获\n1.对7月17提出的【如何去问问题】重新总结。\n问题\n：问问题时描述太多，太啰嗦。\n原因\n：\n\n\n提问时抓不住问题的重点 –> 提问之前，没有把问题的原因理解清楚 –> 急于寻找答案，未能静下心思考 –> 思维有惰性，希望答案可以不劳而获 –> 依赖他人，独立解决问题的能力差\n\n\n对问题考虑不全面 –>  对问题的解决方案有遗漏 –> 假设问题发生的情况时有遗漏 –> 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。\n\n\n总结\n：\n因为原因2中包含了原因1，所以先对原因2总结action plan。\n\n\n遇到问题 –> 立刻把问题写在纸上（不可只在脑中思考） –>  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –> 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –> 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –> 如果二叉树的叶子节点中已经存在问题发生的原因 –> 针对原因，思考问题的解决方案 –> 利用目前可用的所有工具（google，man，document）去找到对应的答案 –> 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （\n以上每一步的过程必须有记录，绝不可以只在脑中完成。\n）\n\n\n如果1中的办法未能找到正确的答案 –> 重复1并且每次结束后查阅记录信息 –> 如果连续6次的记录信息都一样 –> 表明一直被卡在了同一个地方 –> 此时才可以寻问他人 –> 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –> 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。\n\n\n明天的计划\n1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。\n提出疑问或寻求帮助\n无。","slug":"2017-07-18","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opq000jlvtlmb3215fz","content":"<p>对于2017<br> 07<br> 17的daily report赵赵的回复。<br>这个总结不合格。</p>\n<p>自己的问题，自己先问6次为什么（自己解答），然后再问别人。<br>你现在还是抓不住重点。</p>\n<p>我描述你的问题是：问问题的时候描述太多<br>反思的原因是：</p>\n<ol>\n<li>抓不住重点</li>\n<li>没有自己考虑周全</li>\n</ol>\n<p>那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。<br>我上周已经告诉你了，先找到根本原因，在想action plan！<br>我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！</p>\n<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxxx的函数里增加了xxxx的逻辑<br>当天的收获<br>1.对7月17提出的【如何去问问题】重新总结。<br>问题<br>：问问题时描述太多，太啰嗦。<br>原因<br>：</p>\n<p>提问时抓不住问题的重点 –&gt; 提问之前，没有把问题的原因理解清楚 –&gt; 急于寻找答案，未能静下心思考 –&gt; 思维有惰性，希望答案可以不劳而获 –&gt; 依赖他人，独立解决问题的能力差</p>\n<p>对问题考虑不全面 –&gt;  对问题的解决方案有遗漏 –&gt; 假设问题发生的情况时有遗漏 –&gt; 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。</p>\n<p>总结<br>：<br>因为原因2中包含了原因1，所以先对原因2总结action plan。</p>\n<p>遇到问题 –&gt; 立刻把问题写在纸上（不可只在脑中思考） –&gt;  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –&gt; 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –&gt; 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –&gt; 如果二叉树的叶子节点中已经存在问题发生的原因 –&gt; 针对原因，思考问题的解决方案 –&gt; 利用目前可用的所有工具（google，man，document）去找到对应的答案 –&gt; 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （<br>以上每一步的过程必须有记录，绝不可以只在脑中完成。<br>）</p>\n<p>如果1中的办法未能找到正确的答案 –&gt; 重复1并且每次结束后查阅记录信息 –&gt; 如果连续6次的记录信息都一样 –&gt; 表明一直被卡在了同一个地方 –&gt; 此时才可以寻问他人 –&gt; 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –&gt; 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。</p>\n<p>明天的计划<br>1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于2017<br> 07<br> 17的daily report赵赵的回复。<br>这个总结不合格。</p>\n<p>自己的问题，自己先问6次为什么（自己解答），然后再问别人。<br>你现在还是抓不住重点。</p>\n<p>我描述你的问题是：问问题的时候描述太多<br>反思的原因是：</p>\n<ol>\n<li>抓不住重点</li>\n<li>没有自己考虑周全</li>\n</ol>\n<p>那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。<br>我上周已经告诉你了，先找到根本原因，在想action plan！<br>我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！</p>\n<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxxx的函数里增加了xxxx的逻辑<br>当天的收获<br>1.对7月17提出的【如何去问问题】重新总结。<br>问题<br>：问问题时描述太多，太啰嗦。<br>原因<br>：</p>\n<p>提问时抓不住问题的重点 –&gt; 提问之前，没有把问题的原因理解清楚 –&gt; 急于寻找答案，未能静下心思考 –&gt; 思维有惰性，希望答案可以不劳而获 –&gt; 依赖他人，独立解决问题的能力差</p>\n<p>对问题考虑不全面 –&gt;  对问题的解决方案有遗漏 –&gt; 假设问题发生的情况时有遗漏 –&gt; 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。</p>\n<p>总结<br>：<br>因为原因2中包含了原因1，所以先对原因2总结action plan。</p>\n<p>遇到问题 –&gt; 立刻把问题写在纸上（不可只在脑中思考） –&gt;  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –&gt; 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –&gt; 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –&gt; 如果二叉树的叶子节点中已经存在问题发生的原因 –&gt; 针对原因，思考问题的解决方案 –&gt; 利用目前可用的所有工具（google，man，document）去找到对应的答案 –&gt; 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （<br>以上每一步的过程必须有记录，绝不可以只在脑中完成。<br>）</p>\n<p>如果1中的办法未能找到正确的答案 –&gt; 重复1并且每次结束后查阅记录信息 –&gt; 如果连续6次的记录信息都一样 –&gt; 表明一直被卡在了同一个地方 –&gt; 此时才可以寻问他人 –&gt; 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –&gt; 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。</p>\n<p>明天的计划<br>1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-12 Report","date":"2017-07-12T07:27:45.000Z","_content":"当天完成的工作内容\n1.写了xxx api\n2.在xxx中修改了xx方法。\n当天的收获\n1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。\n可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的\n，遇到问题后先要用MECE分析一遍，再开始执行。\n明天的计划\n1.继续熟悉xxxxxx的架构。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-07-12.md","raw":"---\ntitle: 2017-07-12 Report\ndate: 2017-07-12 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.写了xxx api\n2.在xxx中修改了xx方法。\n当天的收获\n1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。\n可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的\n，遇到问题后先要用MECE分析一遍，再开始执行。\n明天的计划\n1.继续熟悉xxxxxx的架构。\n提出疑问或寻求帮助\n无。","slug":"2017-07-12","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opr000llvtl2kn74w3h","content":"<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxx中修改了xx方法。<br>当天的收获<br>1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。<br>可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的<br>，遇到问题后先要用MECE分析一遍，再开始执行。<br>明天的计划<br>1.继续熟悉xxxxxx的架构。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxx中修改了xx方法。<br>当天的收获<br>1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。<br>可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的<br>，遇到问题后先要用MECE分析一遍，再开始执行。<br>明天的计划<br>1.继续熟悉xxxxxx的架构。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-19 Report","date":"2017-07-19T07:27:45.000Z","_content":"当天完成的工作内容\n1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。\n当天的收获\n1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。\n反思一下：\n\n\n文档看不懂 –> 单词不理解 ——> 词汇量太少 –> 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –> 没有背单词的习惯。\n\n\n不能用英语表达问题 –> 除了半年一次的英语考试，平时没有用英语写作过 –> 平日缺少英文写作和表达的锻炼\n总结：\n1.因为对写作没有积极性 –> 所以不自己写作，去翻译英文文档 –> 每天翻译1段超过150个词的文档 –> 但我惰性很大，没有人督促肯定坚持不下来 –> 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） \n\n\n我只想背我不会的生词 –> 不打算买个词典一页一页开始背 –> 每天在使用有道词典的时候，查阅完单词的同时mark一下 –> 当天背当天查阅的单词 –> 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）\n以上两个方法与daily report保持同步。\n\n\n明天的计划\n1.把Ip限制的方案落实。\n提出疑问或寻求帮助\n无。\n今日翻译\nA variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.\n我的译文：\n这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。\n正确译文：\n该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。","source":"_posts/2017-07-19.md","raw":"---\ntitle: 2017-07-19 Report\ndate: 2017-07-19 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。\n当天的收获\n1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。\n反思一下：\n\n\n文档看不懂 –> 单词不理解 ——> 词汇量太少 –> 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –> 没有背单词的习惯。\n\n\n不能用英语表达问题 –> 除了半年一次的英语考试，平时没有用英语写作过 –> 平日缺少英文写作和表达的锻炼\n总结：\n1.因为对写作没有积极性 –> 所以不自己写作，去翻译英文文档 –> 每天翻译1段超过150个词的文档 –> 但我惰性很大，没有人督促肯定坚持不下来 –> 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） \n\n\n我只想背我不会的生词 –> 不打算买个词典一页一页开始背 –> 每天在使用有道词典的时候，查阅完单词的同时mark一下 –> 当天背当天查阅的单词 –> 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）\n以上两个方法与daily report保持同步。\n\n\n明天的计划\n1.把Ip限制的方案落实。\n提出疑问或寻求帮助\n无。\n今日翻译\nA variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.\n我的译文：\n这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。\n正确译文：\n该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。","slug":"2017-07-19","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8ops000nlvtl9o5i7yoy","content":"<p>当天完成的工作内容<br>1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。<br>当天的收获<br>1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。<br>反思一下：</p>\n<p>文档看不懂 –&gt; 单词不理解 ——&gt; 词汇量太少 –&gt; 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –&gt; 没有背单词的习惯。</p>\n<p>不能用英语表达问题 –&gt; 除了半年一次的英语考试，平时没有用英语写作过 –&gt; 平日缺少英文写作和表达的锻炼<br>总结：<br>1.因为对写作没有积极性 –&gt; 所以不自己写作，去翻译英文文档 –&gt; 每天翻译1段超过150个词的文档 –&gt; 但我惰性很大，没有人督促肯定坚持不下来 –&gt; 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） </p>\n<p>我只想背我不会的生词 –&gt; 不打算买个词典一页一页开始背 –&gt; 每天在使用有道词典的时候，查阅完单词的同时mark一下 –&gt; 当天背当天查阅的单词 –&gt; 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）<br>以上两个方法与daily report保持同步。</p>\n<p>明天的计划<br>1.把Ip限制的方案落实。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>A variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.<br>我的译文：<br>这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。<br>正确译文：<br>该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。<br>当天的收获<br>1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。<br>反思一下：</p>\n<p>文档看不懂 –&gt; 单词不理解 ——&gt; 词汇量太少 –&gt; 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –&gt; 没有背单词的习惯。</p>\n<p>不能用英语表达问题 –&gt; 除了半年一次的英语考试，平时没有用英语写作过 –&gt; 平日缺少英文写作和表达的锻炼<br>总结：<br>1.因为对写作没有积极性 –&gt; 所以不自己写作，去翻译英文文档 –&gt; 每天翻译1段超过150个词的文档 –&gt; 但我惰性很大，没有人督促肯定坚持不下来 –&gt; 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） </p>\n<p>我只想背我不会的生词 –&gt; 不打算买个词典一页一页开始背 –&gt; 每天在使用有道词典的时候，查阅完单词的同时mark一下 –&gt; 当天背当天查阅的单词 –&gt; 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）<br>以上两个方法与daily report保持同步。</p>\n<p>明天的计划<br>1.把Ip限制的方案落实。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>A variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.<br>我的译文：<br>这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。<br>正确译文：<br>该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。</p>\n"},{"title":"2017-07-20 Report","date":"2017-07-20T07:27:45.000Z","_content":"当天完成的工作内容\n1.给avatar的后端服务器加了Ip的rate限制。\n当天的收获\n1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。\n问题：眼界低，技术视野很窄。\n反思：为什么同样是技术人员，别人聊的内容我完全不理解 –> 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –> 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –>  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –> 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –> 惰性让我看到舒适区以外的陌生技术，就想着逃避 –> 没有强迫自己去拓展技术栈\n总结：\n首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –> 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –> 碎片时间看github，周一到周五每天star至少一个项目 –> 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）\n翻译英文文档和读技术博客是为了补足基础知识 –> 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –> 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。 \n千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。\n明天的计划\n1.修改github上ratelimit api，使其更好的贴合avatar。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.\n我的译文\n在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。\n正确译文\n装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务","source":"_posts/2017-07-20.md","raw":"---\ntitle: 2017-07-20 Report\ndate: 2017-07-20 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.给avatar的后端服务器加了Ip的rate限制。\n当天的收获\n1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。\n问题：眼界低，技术视野很窄。\n反思：为什么同样是技术人员，别人聊的内容我完全不理解 –> 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –> 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –>  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –> 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –> 惰性让我看到舒适区以外的陌生技术，就想着逃避 –> 没有强迫自己去拓展技术栈\n总结：\n首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –> 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –> 碎片时间看github，周一到周五每天star至少一个项目 –> 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）\n翻译英文文档和读技术博客是为了补足基础知识 –> 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –> 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。 \n千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。\n明天的计划\n1.修改github上ratelimit api，使其更好的贴合avatar。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.\n我的译文\n在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。\n正确译文\n装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务","slug":"2017-07-20","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opt000plvtl3qecbx8f","content":"<p>当天完成的工作内容<br>1.给avatar的后端服务器加了Ip的rate限制。<br>当天的收获<br>1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。<br>问题：眼界低，技术视野很窄。<br>反思：为什么同样是技术人员，别人聊的内容我完全不理解 –&gt; 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –&gt; 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –&gt;  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –&gt; 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –&gt; 惰性让我看到舒适区以外的陌生技术，就想着逃避 –&gt; 没有强迫自己去拓展技术栈<br>总结：<br>首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –&gt; 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –&gt; 碎片时间看github，周一到周五每天star至少一个项目 –&gt; 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）<br>翻译英文文档和读技术博客是为了补足基础知识 –&gt; 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –&gt; 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。<br>千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。<br>明天的计划<br>1.修改github上ratelimit api，使其更好的贴合avatar。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.<br>我的译文<br>在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。<br>正确译文<br>装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.给avatar的后端服务器加了Ip的rate限制。<br>当天的收获<br>1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。<br>问题：眼界低，技术视野很窄。<br>反思：为什么同样是技术人员，别人聊的内容我完全不理解 –&gt; 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –&gt; 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –&gt;  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –&gt; 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –&gt; 惰性让我看到舒适区以外的陌生技术，就想着逃避 –&gt; 没有强迫自己去拓展技术栈<br>总结：<br>首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –&gt; 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –&gt; 碎片时间看github，周一到周五每天star至少一个项目 –&gt; 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）<br>翻译英文文档和读技术博客是为了补足基础知识 –&gt; 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –&gt; 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。<br>千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。<br>明天的计划<br>1.修改github上ratelimit api，使其更好的贴合avatar。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.<br>我的译文<br>在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。<br>正确译文<br>装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务</p>\n"},{"title":"2017-07-17 Report","date":"2017-07-17T07:27:45.000Z","_content":"当天完成的工作内容\n1.fix了xxxxx中的重复任务和数据占用大量空间的问题。\n当天的收获\n1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。\n截止今日仍表现出来的问题：问问题时，\n描述的太冗余了\n，导致伟哥经常听完我的问题，第一句话就是：你在说什么。\n反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。\n总结：\n1.提问前先尝试\n独立解决\n这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。\n2.在提问时，\n明确问题\n，将自己\n目前做的尝试\n，已经\n收集到信息\n以及被\n卡住的原因\n告诉回答者。将问题变得\n简单\n，尽可能的将问题描述的简单易懂。\n明天的计划\n1.把xxxx中数据持久化部分的逻辑弄懂。\n提出疑问或寻求帮助\n对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。","source":"_posts/2017-07-17.md","raw":"---\ntitle: 2017-07-17 Report\ndate: 2017-07-17 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.fix了xxxxx中的重复任务和数据占用大量空间的问题。\n当天的收获\n1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。\n截止今日仍表现出来的问题：问问题时，\n描述的太冗余了\n，导致伟哥经常听完我的问题，第一句话就是：你在说什么。\n反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。\n总结：\n1.提问前先尝试\n独立解决\n这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。\n2.在提问时，\n明确问题\n，将自己\n目前做的尝试\n，已经\n收集到信息\n以及被\n卡住的原因\n告诉回答者。将问题变得\n简单\n，尽可能的将问题描述的简单易懂。\n明天的计划\n1.把xxxx中数据持久化部分的逻辑弄懂。\n提出疑问或寻求帮助\n对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。","slug":"2017-07-17","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opu000rlvtlgc5re36z","content":"<p>当天完成的工作内容<br>1.fix了xxxxx中的重复任务和数据占用大量空间的问题。<br>当天的收获<br>1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。<br>截止今日仍表现出来的问题：问问题时，<br>描述的太冗余了<br>，导致伟哥经常听完我的问题，第一句话就是：你在说什么。<br>反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。<br>总结：<br>1.提问前先尝试<br>独立解决<br>这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。<br>2.在提问时，<br>明确问题<br>，将自己<br>目前做的尝试<br>，已经<br>收集到信息<br>以及被<br>卡住的原因<br>告诉回答者。将问题变得<br>简单<br>，尽可能的将问题描述的简单易懂。<br>明天的计划<br>1.把xxxx中数据持久化部分的逻辑弄懂。<br>提出疑问或寻求帮助<br>对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.fix了xxxxx中的重复任务和数据占用大量空间的问题。<br>当天的收获<br>1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。<br>截止今日仍表现出来的问题：问问题时，<br>描述的太冗余了<br>，导致伟哥经常听完我的问题，第一句话就是：你在说什么。<br>反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。<br>总结：<br>1.提问前先尝试<br>独立解决<br>这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。<br>2.在提问时，<br>明确问题<br>，将自己<br>目前做的尝试<br>，已经<br>收集到信息<br>以及被<br>卡住的原因<br>告诉回答者。将问题变得<br>简单<br>，尽可能的将问题描述的简单易懂。<br>明天的计划<br>1.把xxxx中数据持久化部分的逻辑弄懂。<br>提出疑问或寻求帮助<br>对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。</p>\n"},{"title":"2017-07-21 Report","date":"2017-07-21T07:27:45.000Z","_content":"当天完成的工作内容\n1.x。\n当天的收获（简要概括在后面）\n1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。\n问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？\n我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）\n上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。\n反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –> 说话没有把握重点，想描述细节，但是细节与问题无关 –> 为什么没有用简单的语言说出重点 –> 因为问题我还没有思考完，我就开始回答了 –> 为什么问题不考虑完就要回答？ –> 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –> 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –> 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –> 为什么思维分散？ –> 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –> 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。\n目标是什么：\n要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。\n方法：\n完整的听完问题 –> 在脑中把问题重复几遍 ——> 如果对问题有不理解的地方，先问清楚 –> 确保问题已经听明白了 –> 思考问题的答案 –> 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –> 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –> 如果答案与问题完全相关，再回答 –> 如果思考偏了，跟对方请求一下再考虑一会。 –> 回答的时候，在心中默念问题 –> 只回答与问题有关的内容，无关的话不要说出来。 –> 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。\n实践总结的方法重新回答赵赵的问题：\n1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。\n2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。\n3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。\n4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。\n简要概括：\n问题：回答别人的提问时，回答冗余，并且逻辑混乱\n方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。\n目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。\n明天的计划\n1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。\n提出疑问或寻求帮助\n无。\n今日翻译\nBald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.\nA new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.\n我的译文\n研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。\n来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。\n正确译文\n研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。\n美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。","source":"_posts/2017-07-21.md","raw":"---\ntitle: 2017-07-21 Report\ndate: 2017-07-21 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.x。\n当天的收获（简要概括在后面）\n1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。\n问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？\n我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）\n上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。\n反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –> 说话没有把握重点，想描述细节，但是细节与问题无关 –> 为什么没有用简单的语言说出重点 –> 因为问题我还没有思考完，我就开始回答了 –> 为什么问题不考虑完就要回答？ –> 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –> 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –> 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –> 为什么思维分散？ –> 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –> 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。\n目标是什么：\n要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。\n方法：\n完整的听完问题 –> 在脑中把问题重复几遍 ——> 如果对问题有不理解的地方，先问清楚 –> 确保问题已经听明白了 –> 思考问题的答案 –> 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –> 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –> 如果答案与问题完全相关，再回答 –> 如果思考偏了，跟对方请求一下再考虑一会。 –> 回答的时候，在心中默念问题 –> 只回答与问题有关的内容，无关的话不要说出来。 –> 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。\n实践总结的方法重新回答赵赵的问题：\n1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。\n2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。\n3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。\n4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。\n简要概括：\n问题：回答别人的提问时，回答冗余，并且逻辑混乱\n方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。\n目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。\n明天的计划\n1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。\n提出疑问或寻求帮助\n无。\n今日翻译\nBald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.\nA new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.\n我的译文\n研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。\n来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。\n正确译文\n研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。\n美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。","slug":"2017-07-21","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opv000tlvtlgtdyussx","content":"<p>当天完成的工作内容<br>1.x。<br>当天的收获（简要概括在后面）<br>1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。<br>问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？<br>我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）<br>上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。<br>反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –&gt; 说话没有把握重点，想描述细节，但是细节与问题无关 –&gt; 为什么没有用简单的语言说出重点 –&gt; 因为问题我还没有思考完，我就开始回答了 –&gt; 为什么问题不考虑完就要回答？ –&gt; 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –&gt; 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –&gt; 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –&gt; 为什么思维分散？ –&gt; 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –&gt; 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。<br>目标是什么：<br>要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。<br>方法：<br>完整的听完问题 –&gt; 在脑中把问题重复几遍 ——&gt; 如果对问题有不理解的地方，先问清楚 –&gt; 确保问题已经听明白了 –&gt; 思考问题的答案 –&gt; 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –&gt; 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –&gt; 如果答案与问题完全相关，再回答 –&gt; 如果思考偏了，跟对方请求一下再考虑一会。 –&gt; 回答的时候，在心中默念问题 –&gt; 只回答与问题有关的内容，无关的话不要说出来。 –&gt; 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。<br>实践总结的方法重新回答赵赵的问题：<br>1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。<br>2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。<br>3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。<br>4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。<br>简要概括：<br>问题：回答别人的提问时，回答冗余，并且逻辑混乱<br>方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。<br>目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。<br>明天的计划<br>1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Bald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.<br>A new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.<br>我的译文<br>研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。<br>来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。<br>正确译文<br>研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。<br>美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.x。<br>当天的收获（简要概括在后面）<br>1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。<br>问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？<br>我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）<br>上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。<br>反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –&gt; 说话没有把握重点，想描述细节，但是细节与问题无关 –&gt; 为什么没有用简单的语言说出重点 –&gt; 因为问题我还没有思考完，我就开始回答了 –&gt; 为什么问题不考虑完就要回答？ –&gt; 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –&gt; 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –&gt; 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –&gt; 为什么思维分散？ –&gt; 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –&gt; 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。<br>目标是什么：<br>要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。<br>方法：<br>完整的听完问题 –&gt; 在脑中把问题重复几遍 ——&gt; 如果对问题有不理解的地方，先问清楚 –&gt; 确保问题已经听明白了 –&gt; 思考问题的答案 –&gt; 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –&gt; 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –&gt; 如果答案与问题完全相关，再回答 –&gt; 如果思考偏了，跟对方请求一下再考虑一会。 –&gt; 回答的时候，在心中默念问题 –&gt; 只回答与问题有关的内容，无关的话不要说出来。 –&gt; 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。<br>实践总结的方法重新回答赵赵的问题：<br>1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。<br>2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。<br>3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。<br>4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。<br>简要概括：<br>问题：回答别人的提问时，回答冗余，并且逻辑混乱<br>方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。<br>目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。<br>明天的计划<br>1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Bald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.<br>A new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.<br>我的译文<br>研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。<br>来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。<br>正确译文<br>研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。<br>美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。</p>\n"},{"title":"2017-07-24 Report","date":"2017-07-24T07:27:45.000Z","_content":"当天完成的工作内容\n1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。\n当天的收获\n1.总结的内容是： 如何用最短的时间找到靠谱的api？\n2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –> 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –> 那么只能去网上寻找资源 –> 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –> 那么如何有效的从这些资源里，快速找到我所需要的呢？ –> 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –> 那么现在根据近期记录的搜索方案，整理一下技巧。\n3.查找方法的总结：\n先分析一下问题 –> 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –> 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –> 重新跟伟哥确认一下需求或者问题 –> 重复上述步骤 –> 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –> 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –> 把轮子或者教程看明白后再开始动手写代码。\n概括上述内容：\n1.需求： fix Bug或者优化已有功能。\n2.目标： 用最少的时间去找到合适的轮子/fix bug。\n3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –>  动手前先跟伟哥沟通好，确认方案有可行性再写代码。 \n明天的计划\n1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。\n2.熟悉patter api后，用到avatar上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.\nI/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.\nI/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。","source":"_posts/2017-07-24.md","raw":"---\ntitle: 2017-07-24 Report\ndate: 2017-07-24 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。\n当天的收获\n1.总结的内容是： 如何用最短的时间找到靠谱的api？\n2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –> 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –> 那么只能去网上寻找资源 –> 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –> 那么如何有效的从这些资源里，快速找到我所需要的呢？ –> 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –> 那么现在根据近期记录的搜索方案，整理一下技巧。\n3.查找方法的总结：\n先分析一下问题 –> 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –> 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –> 重新跟伟哥确认一下需求或者问题 –> 重复上述步骤 –> 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –> 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –> 把轮子或者教程看明白后再开始动手写代码。\n概括上述内容：\n1.需求： fix Bug或者优化已有功能。\n2.目标： 用最少的时间去找到合适的轮子/fix bug。\n3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –>  动手前先跟伟哥沟通好，确认方案有可行性再写代码。 \n明天的计划\n1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。\n2.熟悉patter api后，用到avatar上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.\nI/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.\nI/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。","slug":"2017-07-24","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opw000vlvtlq95ktlcp","content":"<p>当天完成的工作内容<br>1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。<br>当天的收获<br>1.总结的内容是： 如何用最短的时间找到靠谱的api？<br>2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –&gt; 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –&gt; 那么只能去网上寻找资源 –&gt; 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –&gt; 那么如何有效的从这些资源里，快速找到我所需要的呢？ –&gt; 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –&gt; 那么现在根据近期记录的搜索方案，整理一下技巧。<br>3.查找方法的总结：<br>先分析一下问题 –&gt; 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –&gt; 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –&gt; 重新跟伟哥确认一下需求或者问题 –&gt; 重复上述步骤 –&gt; 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –&gt; 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –&gt; 把轮子或者教程看明白后再开始动手写代码。<br>概括上述内容：<br>1.需求： fix Bug或者优化已有功能。<br>2.目标： 用最少的时间去找到合适的轮子/fix bug。<br>3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –&gt;  动手前先跟伟哥沟通好，确认方案有可行性再写代码。<br>明天的计划<br>1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。<br>2.熟悉patter api后，用到avatar上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.<br>I/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.<br>I/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。<br>当天的收获<br>1.总结的内容是： 如何用最短的时间找到靠谱的api？<br>2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –&gt; 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –&gt; 那么只能去网上寻找资源 –&gt; 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –&gt; 那么如何有效的从这些资源里，快速找到我所需要的呢？ –&gt; 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –&gt; 那么现在根据近期记录的搜索方案，整理一下技巧。<br>3.查找方法的总结：<br>先分析一下问题 –&gt; 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –&gt; 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –&gt; 重新跟伟哥确认一下需求或者问题 –&gt; 重复上述步骤 –&gt; 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –&gt; 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –&gt; 把轮子或者教程看明白后再开始动手写代码。<br>概括上述内容：<br>1.需求： fix Bug或者优化已有功能。<br>2.目标： 用最少的时间去找到合适的轮子/fix bug。<br>3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –&gt;  动手前先跟伟哥沟通好，确认方案有可行性再写代码。<br>明天的计划<br>1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。<br>2.熟悉patter api后，用到avatar上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.<br>I/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.<br>I/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。</p>\n"},{"title":"2017-07-26 Report","date":"2017-07-26T07:27:45.000Z","_content":"当天完成的工作内容\n1.扩展了compare api，跑了几份category的数据给伟哥。\n2.帮同事爬取了OBD的数据。\n当天的收获\n1.今天总结的内容是： 如何避免做重复的工作。\n2.问题： 在工作中有时候会碰到做重复或者之前做过的任务（指的是机械性的任务）\n先举个重复任务的例子，在测试代码功能的时候，有时候涉及到Docker环境，镜像需要重新编译。每次写完代码，就需要手动一个一个的先删除原有的镜像，然后再编译镜像，再打tag，之后上传镜像。这是完全重复的工作，而且完成功能需要测试很多次，这样机械的任务完全应该被避免。\n3.反思： 做重复的任务是人人都会碰到的事情，为什么我会把它当做是一个问题呢？ –> 因为我很懒，看到任务是之前做过的，头很大。 –> 那如何去解决重复的任务，但是不要消耗同样的时间呢？ –> 优化方法，使得这一次比上一次完成更快吗？（手速更快的删除镜像？） –> 机械性的任务完成的再快时间还是浪费了 –> 那如何使得机械性任务一次完成，以后每次碰到了，都不需要再去耗费精力？ –> 机械性的写代码，就应该让电脑去完成 –> 写自动化脚本去完成。 –> 那为什么知道了自动化脚本可以完成，我还是屡屡的去做重复的任务呢？ –> 因为第一次碰到这个任务，是不知道之后还会重复做的；然后再次碰到了，因为有解决经验了所以这时候完成起来要比去写个脚本轻松的多。 –> 恶性循环导致问题始终不会被解决 –> 如何终止这个循环？ –> 区分一下任务属性，对于明显会重复的任务，应该第一次就编写自动化脚本。对于不确定会重复的任务，在碰到的第二次就开始写脚本。对于明显不会重复的任务，只需要完成一次即可的，完全没必要去讲究代码健壮性，要追求快速完成。\n方法：\n碰到任务，先区分一下任务属性： 如果任务是机械性的，而且接下来工作中明显会再次碰到的（定性为每测试一次就要删除一次镜像的此类任务），第一次就要写好脚本。如果任务不确定接下来会不会再次碰到（定性为使用Avatar的某个api，每次手动给数据），给数据的时候，不要复制粘贴，要用测试脚本去使用这个APi的功能。 –> 此时用删除镜像举例，确定需要写脚本（脚本在业余时间完成） –> 先在网上找停止容器，删除镜像等的命令，docker stop \n docker rmi *\n –> *部分是不能写固定，使用脚本的时候传进去 –> 之后用SHELL脚本去自动运行这些命令，完成这样的自动化功能。\n概括总结内容：\n问题： 工作时会碰到重复的机械任务。\n目标： 避免重复的机械任务。\n反思： 重复做机械任务，没有意义而且浪费精力。 需要写个自动化脚本来代替我完成这样的任务。\n总结： 先定性任务，把明确要重复做的任务，第一次做时就写好脚本。先把相关命令都写好，然后用SHELL整理成自动化的脚本。\n（在这周结束前，用shell把avatar的镜像操作写好，到时候把连接贴在daily report上）\n明天的计划\n1.优化返回类目关系树的性能，把compare api跟前端把数据格式沟通好，完成这两个功能，提交到GitHub上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI love choices.\nI love to walk around in bookstores not because I can buy all the books, but because I could buy one book, and I have so many to choose from.\nI like buffets.\nI rarely get to go to them, but when I do,\nthe first thing I do is walk around and see what the choice are.\nI also like the internet.\nIt seems like cyberspace really doesn’t have any limits.\nThere are so many things to discover— like space.\nSometimes, I think we don’t appreciate the freedom that we have.\nWe are free to make many different choice.\nFrom the food we eat— to the places we visit— to the people we meet— to the classes we take and on and on and on.\nBut freedom has dangers. If misused, it can be harmful.\nI could pile a mountain of food on my plate and NOT to eat it.\nIt would be a waste. But that’s a choice I have.\nThe Internet has dangers, too.\nIf parents are not careful and don’t supervise what their kids can see— well kids can lose some of their innocence because of freedom.\nThere’s a reason for legal age limits when it comes to driving, gambling, drinking,somking, and voting.\nUntil we reach that age, we aren’t free to do those things.\n我的翻译\n我爱选择\n我爱在书店里散步，不是因为我可以买所有的书，而是我可以买一本书。我有很多的选择。\n我爱自助餐。\n我很少去吃自助餐，不过当我这么做的时候，我第一件要做的事情就是环绕四周看看有什么事可以选择的。\n我也爱互联网。\n这大概是因为网络空间没有任何限制吧。\n这有太多的东西去探索，比如空间。\n有时候，我认为我们不会感谢我们拥有的自由。\n我们没有代价去做许多不同的选择。\n我们吃的食物，我们参观的地方，我们约会的人，我们去上的课，如此反复。\n但是自由存在危险，如果滥用，它就会伤害你。\n我可以堆积山一样的食物在我的盘子里，但是不去吃它。\n这可能会浪费，但这是我拥有的权利。\n互联网也同样有危险。\n如果父母不小心或者监督他们的孩子，孩子会因为自由失去他们的天真无邪。这是法定年龄限制当他们去开车，赌博，喝酒，抽烟时的原因。\n直到我们到了年纪，我们就不在没有代价的去做这些事情了。\n我爱选择。\n我喜欢在书店里徜徉，不是因为我能买下所有的书，\n而是因为我可以买一本书，我有这么多的选择。\n我还喜欢自助餐。\n虽然我很少去，但是当我去的时候，\n我做的第一件事就是四处逛逛，看看有什么选择。\n我还喜欢互联网。\n看来网络真的没有任何限制。\n有这么多的东西等待发——比如空间。\n有时候，我觉得我们不喜欢我们拥有的自由。\n我们可以自由地做出许多不同的选择。\n从我们所吃的食物到我们去的地方，我们见的人，我们所上的课程等等。\n但自由也有危险。如果滥用，将会带来危害。\n我可以将山一样的食物堆在我的盘子里，而我则不去吃它。\n它会是一种浪费。但这是一个选择。\n互联网也有危险。\n如果父母对他们的孩子所看到的不留神也不监督，那么孩子们会因为自由而失去一些他们的无辜的。\n当涉及驾车、赌博、酗酒、吸烟、和投票时法律会有年龄的限制。\n直到我们到了那个年岁，否则我们去做那些事将不会被赋予自由。","source":"_posts/2017-07-26.md","raw":"---\ntitle: 2017-07-26 Report\ndate: 2017-07-26 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.扩展了compare api，跑了几份category的数据给伟哥。\n2.帮同事爬取了OBD的数据。\n当天的收获\n1.今天总结的内容是： 如何避免做重复的工作。\n2.问题： 在工作中有时候会碰到做重复或者之前做过的任务（指的是机械性的任务）\n先举个重复任务的例子，在测试代码功能的时候，有时候涉及到Docker环境，镜像需要重新编译。每次写完代码，就需要手动一个一个的先删除原有的镜像，然后再编译镜像，再打tag，之后上传镜像。这是完全重复的工作，而且完成功能需要测试很多次，这样机械的任务完全应该被避免。\n3.反思： 做重复的任务是人人都会碰到的事情，为什么我会把它当做是一个问题呢？ –> 因为我很懒，看到任务是之前做过的，头很大。 –> 那如何去解决重复的任务，但是不要消耗同样的时间呢？ –> 优化方法，使得这一次比上一次完成更快吗？（手速更快的删除镜像？） –> 机械性的任务完成的再快时间还是浪费了 –> 那如何使得机械性任务一次完成，以后每次碰到了，都不需要再去耗费精力？ –> 机械性的写代码，就应该让电脑去完成 –> 写自动化脚本去完成。 –> 那为什么知道了自动化脚本可以完成，我还是屡屡的去做重复的任务呢？ –> 因为第一次碰到这个任务，是不知道之后还会重复做的；然后再次碰到了，因为有解决经验了所以这时候完成起来要比去写个脚本轻松的多。 –> 恶性循环导致问题始终不会被解决 –> 如何终止这个循环？ –> 区分一下任务属性，对于明显会重复的任务，应该第一次就编写自动化脚本。对于不确定会重复的任务，在碰到的第二次就开始写脚本。对于明显不会重复的任务，只需要完成一次即可的，完全没必要去讲究代码健壮性，要追求快速完成。\n方法：\n碰到任务，先区分一下任务属性： 如果任务是机械性的，而且接下来工作中明显会再次碰到的（定性为每测试一次就要删除一次镜像的此类任务），第一次就要写好脚本。如果任务不确定接下来会不会再次碰到（定性为使用Avatar的某个api，每次手动给数据），给数据的时候，不要复制粘贴，要用测试脚本去使用这个APi的功能。 –> 此时用删除镜像举例，确定需要写脚本（脚本在业余时间完成） –> 先在网上找停止容器，删除镜像等的命令，docker stop \n docker rmi *\n –> *部分是不能写固定，使用脚本的时候传进去 –> 之后用SHELL脚本去自动运行这些命令，完成这样的自动化功能。\n概括总结内容：\n问题： 工作时会碰到重复的机械任务。\n目标： 避免重复的机械任务。\n反思： 重复做机械任务，没有意义而且浪费精力。 需要写个自动化脚本来代替我完成这样的任务。\n总结： 先定性任务，把明确要重复做的任务，第一次做时就写好脚本。先把相关命令都写好，然后用SHELL整理成自动化的脚本。\n（在这周结束前，用shell把avatar的镜像操作写好，到时候把连接贴在daily report上）\n明天的计划\n1.优化返回类目关系树的性能，把compare api跟前端把数据格式沟通好，完成这两个功能，提交到GitHub上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI love choices.\nI love to walk around in bookstores not because I can buy all the books, but because I could buy one book, and I have so many to choose from.\nI like buffets.\nI rarely get to go to them, but when I do,\nthe first thing I do is walk around and see what the choice are.\nI also like the internet.\nIt seems like cyberspace really doesn’t have any limits.\nThere are so many things to discover— like space.\nSometimes, I think we don’t appreciate the freedom that we have.\nWe are free to make many different choice.\nFrom the food we eat— to the places we visit— to the people we meet— to the classes we take and on and on and on.\nBut freedom has dangers. If misused, it can be harmful.\nI could pile a mountain of food on my plate and NOT to eat it.\nIt would be a waste. But that’s a choice I have.\nThe Internet has dangers, too.\nIf parents are not careful and don’t supervise what their kids can see— well kids can lose some of their innocence because of freedom.\nThere’s a reason for legal age limits when it comes to driving, gambling, drinking,somking, and voting.\nUntil we reach that age, we aren’t free to do those things.\n我的翻译\n我爱选择\n我爱在书店里散步，不是因为我可以买所有的书，而是我可以买一本书。我有很多的选择。\n我爱自助餐。\n我很少去吃自助餐，不过当我这么做的时候，我第一件要做的事情就是环绕四周看看有什么事可以选择的。\n我也爱互联网。\n这大概是因为网络空间没有任何限制吧。\n这有太多的东西去探索，比如空间。\n有时候，我认为我们不会感谢我们拥有的自由。\n我们没有代价去做许多不同的选择。\n我们吃的食物，我们参观的地方，我们约会的人，我们去上的课，如此反复。\n但是自由存在危险，如果滥用，它就会伤害你。\n我可以堆积山一样的食物在我的盘子里，但是不去吃它。\n这可能会浪费，但这是我拥有的权利。\n互联网也同样有危险。\n如果父母不小心或者监督他们的孩子，孩子会因为自由失去他们的天真无邪。这是法定年龄限制当他们去开车，赌博，喝酒，抽烟时的原因。\n直到我们到了年纪，我们就不在没有代价的去做这些事情了。\n我爱选择。\n我喜欢在书店里徜徉，不是因为我能买下所有的书，\n而是因为我可以买一本书，我有这么多的选择。\n我还喜欢自助餐。\n虽然我很少去，但是当我去的时候，\n我做的第一件事就是四处逛逛，看看有什么选择。\n我还喜欢互联网。\n看来网络真的没有任何限制。\n有这么多的东西等待发——比如空间。\n有时候，我觉得我们不喜欢我们拥有的自由。\n我们可以自由地做出许多不同的选择。\n从我们所吃的食物到我们去的地方，我们见的人，我们所上的课程等等。\n但自由也有危险。如果滥用，将会带来危害。\n我可以将山一样的食物堆在我的盘子里，而我则不去吃它。\n它会是一种浪费。但这是一个选择。\n互联网也有危险。\n如果父母对他们的孩子所看到的不留神也不监督，那么孩子们会因为自由而失去一些他们的无辜的。\n当涉及驾车、赌博、酗酒、吸烟、和投票时法律会有年龄的限制。\n直到我们到了那个年岁，否则我们去做那些事将不会被赋予自由。","slug":"2017-07-26","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opw000xlvtlo8i4i2l2","content":"<p>当天完成的工作内容<br>1.扩展了compare api，跑了几份category的数据给伟哥。<br>2.帮同事爬取了OBD的数据。<br>当天的收获<br>1.今天总结的内容是： 如何避免做重复的工作。<br>2.问题： 在工作中有时候会碰到做重复或者之前做过的任务（指的是机械性的任务）<br>先举个重复任务的例子，在测试代码功能的时候，有时候涉及到Docker环境，镜像需要重新编译。每次写完代码，就需要手动一个一个的先删除原有的镜像，然后再编译镜像，再打tag，之后上传镜像。这是完全重复的工作，而且完成功能需要测试很多次，这样机械的任务完全应该被避免。<br>3.反思： 做重复的任务是人人都会碰到的事情，为什么我会把它当做是一个问题呢？ –&gt; 因为我很懒，看到任务是之前做过的，头很大。 –&gt; 那如何去解决重复的任务，但是不要消耗同样的时间呢？ –&gt; 优化方法，使得这一次比上一次完成更快吗？（手速更快的删除镜像？） –&gt; 机械性的任务完成的再快时间还是浪费了 –&gt; 那如何使得机械性任务一次完成，以后每次碰到了，都不需要再去耗费精力？ –&gt; 机械性的写代码，就应该让电脑去完成 –&gt; 写自动化脚本去完成。 –&gt; 那为什么知道了自动化脚本可以完成，我还是屡屡的去做重复的任务呢？ –&gt; 因为第一次碰到这个任务，是不知道之后还会重复做的；然后再次碰到了，因为有解决经验了所以这时候完成起来要比去写个脚本轻松的多。 –&gt; 恶性循环导致问题始终不会被解决 –&gt; 如何终止这个循环？ –&gt; 区分一下任务属性，对于明显会重复的任务，应该第一次就编写自动化脚本。对于不确定会重复的任务，在碰到的第二次就开始写脚本。对于明显不会重复的任务，只需要完成一次即可的，完全没必要去讲究代码健壮性，要追求快速完成。<br>方法：<br>碰到任务，先区分一下任务属性： 如果任务是机械性的，而且接下来工作中明显会再次碰到的（定性为每测试一次就要删除一次镜像的此类任务），第一次就要写好脚本。如果任务不确定接下来会不会再次碰到（定性为使用Avatar的某个api，每次手动给数据），给数据的时候，不要复制粘贴，要用测试脚本去使用这个APi的功能。 –&gt; 此时用删除镜像举例，确定需要写脚本（脚本在业余时间完成） –&gt; 先在网上找停止容器，删除镜像等的命令，docker stop<br> docker rmi <em><br> –&gt; </em>部分是不能写固定，使用脚本的时候传进去 –&gt; 之后用SHELL脚本去自动运行这些命令，完成这样的自动化功能。<br>概括总结内容：<br>问题： 工作时会碰到重复的机械任务。<br>目标： 避免重复的机械任务。<br>反思： 重复做机械任务，没有意义而且浪费精力。 需要写个自动化脚本来代替我完成这样的任务。<br>总结： 先定性任务，把明确要重复做的任务，第一次做时就写好脚本。先把相关命令都写好，然后用SHELL整理成自动化的脚本。<br>（在这周结束前，用shell把avatar的镜像操作写好，到时候把连接贴在daily report上）<br>明天的计划<br>1.优化返回类目关系树的性能，把compare api跟前端把数据格式沟通好，完成这两个功能，提交到GitHub上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I love choices.<br>I love to walk around in bookstores not because I can buy all the books, but because I could buy one book, and I have so many to choose from.<br>I like buffets.<br>I rarely get to go to them, but when I do,<br>the first thing I do is walk around and see what the choice are.<br>I also like the internet.<br>It seems like cyberspace really doesn’t have any limits.<br>There are so many things to discover— like space.<br>Sometimes, I think we don’t appreciate the freedom that we have.<br>We are free to make many different choice.<br>From the food we eat— to the places we visit— to the people we meet— to the classes we take and on and on and on.<br>But freedom has dangers. If misused, it can be harmful.<br>I could pile a mountain of food on my plate and NOT to eat it.<br>It would be a waste. But that’s a choice I have.<br>The Internet has dangers, too.<br>If parents are not careful and don’t supervise what their kids can see— well kids can lose some of their innocence because of freedom.<br>There’s a reason for legal age limits when it comes to driving, gambling, drinking,somking, and voting.<br>Until we reach that age, we aren’t free to do those things.<br>我的翻译<br>我爱选择<br>我爱在书店里散步，不是因为我可以买所有的书，而是我可以买一本书。我有很多的选择。<br>我爱自助餐。<br>我很少去吃自助餐，不过当我这么做的时候，我第一件要做的事情就是环绕四周看看有什么事可以选择的。<br>我也爱互联网。<br>这大概是因为网络空间没有任何限制吧。<br>这有太多的东西去探索，比如空间。<br>有时候，我认为我们不会感谢我们拥有的自由。<br>我们没有代价去做许多不同的选择。<br>我们吃的食物，我们参观的地方，我们约会的人，我们去上的课，如此反复。<br>但是自由存在危险，如果滥用，它就会伤害你。<br>我可以堆积山一样的食物在我的盘子里，但是不去吃它。<br>这可能会浪费，但这是我拥有的权利。<br>互联网也同样有危险。<br>如果父母不小心或者监督他们的孩子，孩子会因为自由失去他们的天真无邪。这是法定年龄限制当他们去开车，赌博，喝酒，抽烟时的原因。<br>直到我们到了年纪，我们就不在没有代价的去做这些事情了。<br>我爱选择。<br>我喜欢在书店里徜徉，不是因为我能买下所有的书，<br>而是因为我可以买一本书，我有这么多的选择。<br>我还喜欢自助餐。<br>虽然我很少去，但是当我去的时候，<br>我做的第一件事就是四处逛逛，看看有什么选择。<br>我还喜欢互联网。<br>看来网络真的没有任何限制。<br>有这么多的东西等待发——比如空间。<br>有时候，我觉得我们不喜欢我们拥有的自由。<br>我们可以自由地做出许多不同的选择。<br>从我们所吃的食物到我们去的地方，我们见的人，我们所上的课程等等。<br>但自由也有危险。如果滥用，将会带来危害。<br>我可以将山一样的食物堆在我的盘子里，而我则不去吃它。<br>它会是一种浪费。但这是一个选择。<br>互联网也有危险。<br>如果父母对他们的孩子所看到的不留神也不监督，那么孩子们会因为自由而失去一些他们的无辜的。<br>当涉及驾车、赌博、酗酒、吸烟、和投票时法律会有年龄的限制。<br>直到我们到了那个年岁，否则我们去做那些事将不会被赋予自由。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.扩展了compare api，跑了几份category的数据给伟哥。<br>2.帮同事爬取了OBD的数据。<br>当天的收获<br>1.今天总结的内容是： 如何避免做重复的工作。<br>2.问题： 在工作中有时候会碰到做重复或者之前做过的任务（指的是机械性的任务）<br>先举个重复任务的例子，在测试代码功能的时候，有时候涉及到Docker环境，镜像需要重新编译。每次写完代码，就需要手动一个一个的先删除原有的镜像，然后再编译镜像，再打tag，之后上传镜像。这是完全重复的工作，而且完成功能需要测试很多次，这样机械的任务完全应该被避免。<br>3.反思： 做重复的任务是人人都会碰到的事情，为什么我会把它当做是一个问题呢？ –&gt; 因为我很懒，看到任务是之前做过的，头很大。 –&gt; 那如何去解决重复的任务，但是不要消耗同样的时间呢？ –&gt; 优化方法，使得这一次比上一次完成更快吗？（手速更快的删除镜像？） –&gt; 机械性的任务完成的再快时间还是浪费了 –&gt; 那如何使得机械性任务一次完成，以后每次碰到了，都不需要再去耗费精力？ –&gt; 机械性的写代码，就应该让电脑去完成 –&gt; 写自动化脚本去完成。 –&gt; 那为什么知道了自动化脚本可以完成，我还是屡屡的去做重复的任务呢？ –&gt; 因为第一次碰到这个任务，是不知道之后还会重复做的；然后再次碰到了，因为有解决经验了所以这时候完成起来要比去写个脚本轻松的多。 –&gt; 恶性循环导致问题始终不会被解决 –&gt; 如何终止这个循环？ –&gt; 区分一下任务属性，对于明显会重复的任务，应该第一次就编写自动化脚本。对于不确定会重复的任务，在碰到的第二次就开始写脚本。对于明显不会重复的任务，只需要完成一次即可的，完全没必要去讲究代码健壮性，要追求快速完成。<br>方法：<br>碰到任务，先区分一下任务属性： 如果任务是机械性的，而且接下来工作中明显会再次碰到的（定性为每测试一次就要删除一次镜像的此类任务），第一次就要写好脚本。如果任务不确定接下来会不会再次碰到（定性为使用Avatar的某个api，每次手动给数据），给数据的时候，不要复制粘贴，要用测试脚本去使用这个APi的功能。 –&gt; 此时用删除镜像举例，确定需要写脚本（脚本在业余时间完成） –&gt; 先在网上找停止容器，删除镜像等的命令，docker stop<br> docker rmi <em><br> –&gt; </em>部分是不能写固定，使用脚本的时候传进去 –&gt; 之后用SHELL脚本去自动运行这些命令，完成这样的自动化功能。<br>概括总结内容：<br>问题： 工作时会碰到重复的机械任务。<br>目标： 避免重复的机械任务。<br>反思： 重复做机械任务，没有意义而且浪费精力。 需要写个自动化脚本来代替我完成这样的任务。<br>总结： 先定性任务，把明确要重复做的任务，第一次做时就写好脚本。先把相关命令都写好，然后用SHELL整理成自动化的脚本。<br>（在这周结束前，用shell把avatar的镜像操作写好，到时候把连接贴在daily report上）<br>明天的计划<br>1.优化返回类目关系树的性能，把compare api跟前端把数据格式沟通好，完成这两个功能，提交到GitHub上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I love choices.<br>I love to walk around in bookstores not because I can buy all the books, but because I could buy one book, and I have so many to choose from.<br>I like buffets.<br>I rarely get to go to them, but when I do,<br>the first thing I do is walk around and see what the choice are.<br>I also like the internet.<br>It seems like cyberspace really doesn’t have any limits.<br>There are so many things to discover— like space.<br>Sometimes, I think we don’t appreciate the freedom that we have.<br>We are free to make many different choice.<br>From the food we eat— to the places we visit— to the people we meet— to the classes we take and on and on and on.<br>But freedom has dangers. If misused, it can be harmful.<br>I could pile a mountain of food on my plate and NOT to eat it.<br>It would be a waste. But that’s a choice I have.<br>The Internet has dangers, too.<br>If parents are not careful and don’t supervise what their kids can see— well kids can lose some of their innocence because of freedom.<br>There’s a reason for legal age limits when it comes to driving, gambling, drinking,somking, and voting.<br>Until we reach that age, we aren’t free to do those things.<br>我的翻译<br>我爱选择<br>我爱在书店里散步，不是因为我可以买所有的书，而是我可以买一本书。我有很多的选择。<br>我爱自助餐。<br>我很少去吃自助餐，不过当我这么做的时候，我第一件要做的事情就是环绕四周看看有什么事可以选择的。<br>我也爱互联网。<br>这大概是因为网络空间没有任何限制吧。<br>这有太多的东西去探索，比如空间。<br>有时候，我认为我们不会感谢我们拥有的自由。<br>我们没有代价去做许多不同的选择。<br>我们吃的食物，我们参观的地方，我们约会的人，我们去上的课，如此反复。<br>但是自由存在危险，如果滥用，它就会伤害你。<br>我可以堆积山一样的食物在我的盘子里，但是不去吃它。<br>这可能会浪费，但这是我拥有的权利。<br>互联网也同样有危险。<br>如果父母不小心或者监督他们的孩子，孩子会因为自由失去他们的天真无邪。这是法定年龄限制当他们去开车，赌博，喝酒，抽烟时的原因。<br>直到我们到了年纪，我们就不在没有代价的去做这些事情了。<br>我爱选择。<br>我喜欢在书店里徜徉，不是因为我能买下所有的书，<br>而是因为我可以买一本书，我有这么多的选择。<br>我还喜欢自助餐。<br>虽然我很少去，但是当我去的时候，<br>我做的第一件事就是四处逛逛，看看有什么选择。<br>我还喜欢互联网。<br>看来网络真的没有任何限制。<br>有这么多的东西等待发——比如空间。<br>有时候，我觉得我们不喜欢我们拥有的自由。<br>我们可以自由地做出许多不同的选择。<br>从我们所吃的食物到我们去的地方，我们见的人，我们所上的课程等等。<br>但自由也有危险。如果滥用，将会带来危害。<br>我可以将山一样的食物堆在我的盘子里，而我则不去吃它。<br>它会是一种浪费。但这是一个选择。<br>互联网也有危险。<br>如果父母对他们的孩子所看到的不留神也不监督，那么孩子们会因为自由而失去一些他们的无辜的。<br>当涉及驾车、赌博、酗酒、吸烟、和投票时法律会有年龄的限制。<br>直到我们到了那个年岁，否则我们去做那些事将不会被赋予自由。</p>\n"},{"title":"2017-07-25 Report","date":"2017-07-25T07:27:45.000Z","_content":"当天完成的工作内容\n1.api/relation_tree\n当天的收获\n1.问题: 如何快速理解sql代码及写sql\n2.目标: 逻辑清晰的逐步完成复杂的sql\n3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –> 首先我没有把SQL格式化，SQL非常混乱难以阅读 –> 用在线工具格式化后，SQL逻辑清晰 –> 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –> 伟哥纠正我SQL要从内层向外层读 –> 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –>\n因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。\n4.方法：遇到SQL代码 –> formmater sql –> 从内至外的逐层阅读代码 –> 每一层阅读完，先核对数据的变化 –> 从变化中，思考业务逻辑。 \n5.用总结的方法重新处理一遍今天遇到的问题：\n原来的SQL:\nselect left(t2.published_at,7) month, count(*) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)>=’2011-01’ group by left(t2.published_at,7)\nFrommater后：\nSELECT left(t2.published_at,7) MONTH,\n                               count(*) AS value\nFROM\n  (SELECT d.asin AS parent_asin\n   FROM\n     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id\n      FROM amazon_review_insight.amazon_amazonasin\n      WHERE %s ) c\n   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1\nINNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin\nWHERE left(t2.published_at,7)>=’2011-01’\nGROUP BY left(t2.published_at,7)\n从内到外的阅读：\n1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH>=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。\n明天的计划\n1.在SQL里面嵌套一层Category的连接。\n2.帮公司同事完成OBD的数据爬取。\n提出疑问或寻求帮助\n无。\n今日翻译\nMost CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.\n我的译文\n大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。\n正确译文\n大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。","source":"_posts/2017-07-25.md","raw":"---\ntitle: 2017-07-25 Report\ndate: 2017-07-25 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.api/relation_tree\n当天的收获\n1.问题: 如何快速理解sql代码及写sql\n2.目标: 逻辑清晰的逐步完成复杂的sql\n3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –> 首先我没有把SQL格式化，SQL非常混乱难以阅读 –> 用在线工具格式化后，SQL逻辑清晰 –> 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –> 伟哥纠正我SQL要从内层向外层读 –> 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –>\n因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。\n4.方法：遇到SQL代码 –> formmater sql –> 从内至外的逐层阅读代码 –> 每一层阅读完，先核对数据的变化 –> 从变化中，思考业务逻辑。 \n5.用总结的方法重新处理一遍今天遇到的问题：\n原来的SQL:\nselect left(t2.published_at,7) month, count(*) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)>=’2011-01’ group by left(t2.published_at,7)\nFrommater后：\nSELECT left(t2.published_at,7) MONTH,\n                               count(*) AS value\nFROM\n  (SELECT d.asin AS parent_asin\n   FROM\n     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id\n      FROM amazon_review_insight.amazon_amazonasin\n      WHERE %s ) c\n   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1\nINNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin\nWHERE left(t2.published_at,7)>=’2011-01’\nGROUP BY left(t2.published_at,7)\n从内到外的阅读：\n1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH>=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。\n明天的计划\n1.在SQL里面嵌套一层Category的连接。\n2.帮公司同事完成OBD的数据爬取。\n提出疑问或寻求帮助\n无。\n今日翻译\nMost CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.\n我的译文\n大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。\n正确译文\n大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。","slug":"2017-07-25","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opx000zlvtl81adp53n","content":"<p>当天完成的工作内容<br>1.api/relation_tree<br>当天的收获<br>1.问题: 如何快速理解sql代码及写sql<br>2.目标: 逻辑清晰的逐步完成复杂的sql<br>3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –&gt; 首先我没有把SQL格式化，SQL非常混乱难以阅读 –&gt; 用在线工具格式化后，SQL逻辑清晰 –&gt; 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –&gt; 伟哥纠正我SQL要从内层向外层读 –&gt; 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –&gt;<br>因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。<br>4.方法：遇到SQL代码 –&gt; formmater sql –&gt; 从内至外的逐层阅读代码 –&gt; 每一层阅读完，先核对数据的变化 –&gt; 从变化中，思考业务逻辑。<br>5.用总结的方法重新处理一遍今天遇到的问题：<br>原来的SQL:<br>select left(t2.published_at,7) month, count(<em>) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)&gt;=’2011-01’ group by left(t2.published_at,7)<br>Frommater后：<br>SELECT left(t2.published_at,7) MONTH,<br>                               count(</em>) AS value<br>FROM<br>  (SELECT d.asin AS parent_asin<br>   FROM<br>     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id<br>      FROM amazon_review_insight.amazon_amazonasin<br>      WHERE %s ) c<br>   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1<br>INNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin<br>WHERE left(t2.published_at,7)&gt;=’2011-01’<br>GROUP BY left(t2.published_at,7)<br>从内到外的阅读：<br>1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH&gt;=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。<br>明天的计划<br>1.在SQL里面嵌套一层Category的连接。<br>2.帮公司同事完成OBD的数据爬取。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Most CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.<br>我的译文<br>大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。<br>正确译文<br>大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.api/relation_tree<br>当天的收获<br>1.问题: 如何快速理解sql代码及写sql<br>2.目标: 逻辑清晰的逐步完成复杂的sql<br>3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –&gt; 首先我没有把SQL格式化，SQL非常混乱难以阅读 –&gt; 用在线工具格式化后，SQL逻辑清晰 –&gt; 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –&gt; 伟哥纠正我SQL要从内层向外层读 –&gt; 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –&gt;<br>因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。<br>4.方法：遇到SQL代码 –&gt; formmater sql –&gt; 从内至外的逐层阅读代码 –&gt; 每一层阅读完，先核对数据的变化 –&gt; 从变化中，思考业务逻辑。<br>5.用总结的方法重新处理一遍今天遇到的问题：<br>原来的SQL:<br>select left(t2.published_at,7) month, count(<em>) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)&gt;=’2011-01’ group by left(t2.published_at,7)<br>Frommater后：<br>SELECT left(t2.published_at,7) MONTH,<br>                               count(</em>) AS value<br>FROM<br>  (SELECT d.asin AS parent_asin<br>   FROM<br>     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id<br>      FROM amazon_review_insight.amazon_amazonasin<br>      WHERE %s ) c<br>   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1<br>INNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin<br>WHERE left(t2.published_at,7)&gt;=’2011-01’<br>GROUP BY left(t2.published_at,7)<br>从内到外的阅读：<br>1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH&gt;=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。<br>明天的计划<br>1.在SQL里面嵌套一层Category的连接。<br>2.帮公司同事完成OBD的数据爬取。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Most CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.<br>我的译文<br>大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。<br>正确译文<br>大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。</p>\n"},{"title":"2017-08-02 Report","date":"2017-08-02T07:27:45.000Z","_content":"当天完成的工作内容\n1.解决了403和302的问题，爬取了edmunds下new car configurations(目前抓取的接口只有new car)。\n2.跟前端沟通后修改了compare api。\n当天的收获\n1.问题： 由于之前使用的mysql库不支持Python3.x，今天第一次使用了MysqlDB这个库。使用这个库的时候，我觉得既然执行相同的功能，但是每次因为使用的工具不同就需要重新学习一次新的工具，这样的学习效率太低了。\n2.方法：我认为这种弊端应该存在解决的方法 –> 我找了资料，发现对于RDBMS有统一的DB-API –> 我学习了异常类和常用的属性，比如connect()函数对象中user,password,host,database,dsn。cursor()对象中close(),execute(),fetchall()等等。 –> 把DB-api看完后，对于更换使用RDBMS的库，学习成本非常的低，因为这些接口使用起来是一样的。\n3.总结：  对于执行相同功能的库，一个一个的去学习话效率很低，应该直接在Python官网上，学习对应的底层API,这样在工具更换时，学习成本很低，能够举一反三。\n明天的计划\n1.解决修改后的compare api会在生产环境中碰到的问题。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-08-02.md","raw":"---\ntitle: 2017-08-02 Report\ndate: 2017-08-02 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.解决了403和302的问题，爬取了edmunds下new car configurations(目前抓取的接口只有new car)。\n2.跟前端沟通后修改了compare api。\n当天的收获\n1.问题： 由于之前使用的mysql库不支持Python3.x，今天第一次使用了MysqlDB这个库。使用这个库的时候，我觉得既然执行相同的功能，但是每次因为使用的工具不同就需要重新学习一次新的工具，这样的学习效率太低了。\n2.方法：我认为这种弊端应该存在解决的方法 –> 我找了资料，发现对于RDBMS有统一的DB-API –> 我学习了异常类和常用的属性，比如connect()函数对象中user,password,host,database,dsn。cursor()对象中close(),execute(),fetchall()等等。 –> 把DB-api看完后，对于更换使用RDBMS的库，学习成本非常的低，因为这些接口使用起来是一样的。\n3.总结：  对于执行相同功能的库，一个一个的去学习话效率很低，应该直接在Python官网上，学习对应的底层API,这样在工具更换时，学习成本很低，能够举一反三。\n明天的计划\n1.解决修改后的compare api会在生产环境中碰到的问题。\n提出疑问或寻求帮助\n无。","slug":"2017-08-02","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opy0011lvtlqwpmvckd","content":"<p>当天完成的工作内容<br>1.解决了403和302的问题，爬取了edmunds下new car configurations(目前抓取的接口只有new car)。<br>2.跟前端沟通后修改了compare api。<br>当天的收获<br>1.问题： 由于之前使用的mysql库不支持Python3.x，今天第一次使用了MysqlDB这个库。使用这个库的时候，我觉得既然执行相同的功能，但是每次因为使用的工具不同就需要重新学习一次新的工具，这样的学习效率太低了。<br>2.方法：我认为这种弊端应该存在解决的方法 –&gt; 我找了资料，发现对于RDBMS有统一的DB-API –&gt; 我学习了异常类和常用的属性，比如connect()函数对象中user,password,host,database,dsn。cursor()对象中close(),execute(),fetchall()等等。 –&gt; 把DB-api看完后，对于更换使用RDBMS的库，学习成本非常的低，因为这些接口使用起来是一样的。<br>3.总结：  对于执行相同功能的库，一个一个的去学习话效率很低，应该直接在Python官网上，学习对应的底层API,这样在工具更换时，学习成本很低，能够举一反三。<br>明天的计划<br>1.解决修改后的compare api会在生产环境中碰到的问题。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.解决了403和302的问题，爬取了edmunds下new car configurations(目前抓取的接口只有new car)。<br>2.跟前端沟通后修改了compare api。<br>当天的收获<br>1.问题： 由于之前使用的mysql库不支持Python3.x，今天第一次使用了MysqlDB这个库。使用这个库的时候，我觉得既然执行相同的功能，但是每次因为使用的工具不同就需要重新学习一次新的工具，这样的学习效率太低了。<br>2.方法：我认为这种弊端应该存在解决的方法 –&gt; 我找了资料，发现对于RDBMS有统一的DB-API –&gt; 我学习了异常类和常用的属性，比如connect()函数对象中user,password,host,database,dsn。cursor()对象中close(),execute(),fetchall()等等。 –&gt; 把DB-api看完后，对于更换使用RDBMS的库，学习成本非常的低，因为这些接口使用起来是一样的。<br>3.总结：  对于执行相同功能的库，一个一个的去学习话效率很低，应该直接在Python官网上，学习对应的底层API,这样在工具更换时，学习成本很低，能够举一反三。<br>明天的计划<br>1.解决修改后的compare api会在生产环境中碰到的问题。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-07-31 Report","date":"2017-07-31T07:27:45.000Z","_content":"当天完成的工作内容\n1.找了一些车型数据库，但是数据与目前所需的不匹配。\n2.规划了对于edmunds的爬虫策略。\n当天的收获\n1.问题： 周五总结的方法，细节上没有阐述清楚，难以执行。\n2.反思： 方法应该要思考到每一步明确做什么，而不仅仅是怎么做。\n3.方法： 我拟了一份开发功能时需要注意的细节清单，在开发过程中遇到问题，及时添加进去。反复迭代这份清单。\n4.细节清单：\n写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，合集，交集，差集，补集。\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n5.上周计划完成的自动化脚本，我写了一个可以快捷复制的工具。便于工作中复制一些重复的参数。\nhttps://github.com/Miksztowi/CorePython/blob/master/auto_copy.py\n这个只能在Mac py3.x的环境下work,我计划这周Update跨平台以及兼容2.x，add快捷键的功能\n明天的计划\n1.如果在edmunds和JATO申请的APi没有通过，就开始爬取edmunds的数据。\n2.如果通过了，那么根据Api直接获取我们所需的数据。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are also not suited to large data transfers. In the systems in this chapter, each byte of data transferred between an I/O device and memory must pass through the CPU. This is inefficient for many common operations, such as loading a program from disk into memory. Direct memory access, DMA, is a method used to bypass the CPU in these transfers, thus performing them much more quickly.\n我的翻译\n这些I/O接口也不太适合大型数据传输。在这个部分的系统中，每个在I/O设备和内存间传输的数据字节都必须要通过CPU。这个对很多普通的操作是无效的，比如从内中磁条中加载程序。直接内存连接，DMA是一种方法用来错开这些传输的CPU,因此程序必须运行快一点。\n正确翻译\n这些I/O接口也不适合大量的数据传输。在本章的系统中，I/O设备和存储器之间传输的每一个字节都必须通过CPU，这对于许多常见的操作（例如从磁盘向主机存装载一个程序）来说效率低下。直接存储器访问就是在数据传输中绕过CPU的一种方法，因此执行起来速度很快。","source":"_posts/2017-07-31.md","raw":"---\ntitle: 2017-07-31 Report\ndate: 2017-07-31 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.找了一些车型数据库，但是数据与目前所需的不匹配。\n2.规划了对于edmunds的爬虫策略。\n当天的收获\n1.问题： 周五总结的方法，细节上没有阐述清楚，难以执行。\n2.反思： 方法应该要思考到每一步明确做什么，而不仅仅是怎么做。\n3.方法： 我拟了一份开发功能时需要注意的细节清单，在开发过程中遇到问题，及时添加进去。反复迭代这份清单。\n4.细节清单：\n写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，合集，交集，差集，补集。\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n5.上周计划完成的自动化脚本，我写了一个可以快捷复制的工具。便于工作中复制一些重复的参数。\nhttps://github.com/Miksztowi/CorePython/blob/master/auto_copy.py\n这个只能在Mac py3.x的环境下work,我计划这周Update跨平台以及兼容2.x，add快捷键的功能\n明天的计划\n1.如果在edmunds和JATO申请的APi没有通过，就开始爬取edmunds的数据。\n2.如果通过了，那么根据Api直接获取我们所需的数据。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are also not suited to large data transfers. In the systems in this chapter, each byte of data transferred between an I/O device and memory must pass through the CPU. This is inefficient for many common operations, such as loading a program from disk into memory. Direct memory access, DMA, is a method used to bypass the CPU in these transfers, thus performing them much more quickly.\n我的翻译\n这些I/O接口也不太适合大型数据传输。在这个部分的系统中，每个在I/O设备和内存间传输的数据字节都必须要通过CPU。这个对很多普通的操作是无效的，比如从内中磁条中加载程序。直接内存连接，DMA是一种方法用来错开这些传输的CPU,因此程序必须运行快一点。\n正确翻译\n这些I/O接口也不适合大量的数据传输。在本章的系统中，I/O设备和存储器之间传输的每一个字节都必须通过CPU，这对于许多常见的操作（例如从磁盘向主机存装载一个程序）来说效率低下。直接存储器访问就是在数据传输中绕过CPU的一种方法，因此执行起来速度很快。","slug":"2017-07-31","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8opz0013lvtl5hbw916e","content":"<p>当天完成的工作内容<br>1.找了一些车型数据库，但是数据与目前所需的不匹配。<br>2.规划了对于edmunds的爬虫策略。<br>当天的收获<br>1.问题： 周五总结的方法，细节上没有阐述清楚，难以执行。<br>2.反思： 方法应该要思考到每一步明确做什么，而不仅仅是怎么做。<br>3.方法： 我拟了一份开发功能时需要注意的细节清单，在开发过程中遇到问题，及时添加进去。反复迭代这份清单。<br>4.细节清单：<br>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，合集，交集，差集，补集。</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>5.上周计划完成的自动化脚本，我写了一个可以快捷复制的工具。便于工作中复制一些重复的参数。<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/auto_copy.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/auto_copy.py</a><br>这个只能在Mac py3.x的环境下work,我计划这周Update跨平台以及兼容2.x，add快捷键的功能<br>明天的计划<br>1.如果在edmunds和JATO申请的APi没有通过，就开始爬取edmunds的数据。<br>2.如果通过了，那么根据Api直接获取我们所需的数据。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are also not suited to large data transfers. In the systems in this chapter, each byte of data transferred between an I/O device and memory must pass through the CPU. This is inefficient for many common operations, such as loading a program from disk into memory. Direct memory access, DMA, is a method used to bypass the CPU in these transfers, thus performing them much more quickly.<br>我的翻译<br>这些I/O接口也不太适合大型数据传输。在这个部分的系统中，每个在I/O设备和内存间传输的数据字节都必须要通过CPU。这个对很多普通的操作是无效的，比如从内中磁条中加载程序。直接内存连接，DMA是一种方法用来错开这些传输的CPU,因此程序必须运行快一点。<br>正确翻译<br>这些I/O接口也不适合大量的数据传输。在本章的系统中，I/O设备和存储器之间传输的每一个字节都必须通过CPU，这对于许多常见的操作（例如从磁盘向主机存装载一个程序）来说效率低下。直接存储器访问就是在数据传输中绕过CPU的一种方法，因此执行起来速度很快。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.找了一些车型数据库，但是数据与目前所需的不匹配。<br>2.规划了对于edmunds的爬虫策略。<br>当天的收获<br>1.问题： 周五总结的方法，细节上没有阐述清楚，难以执行。<br>2.反思： 方法应该要思考到每一步明确做什么，而不仅仅是怎么做。<br>3.方法： 我拟了一份开发功能时需要注意的细节清单，在开发过程中遇到问题，及时添加进去。反复迭代这份清单。<br>4.细节清单：<br>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，合集，交集，差集，补集。</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>5.上周计划完成的自动化脚本，我写了一个可以快捷复制的工具。便于工作中复制一些重复的参数。<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/auto_copy.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/auto_copy.py</a><br>这个只能在Mac py3.x的环境下work,我计划这周Update跨平台以及兼容2.x，add快捷键的功能<br>明天的计划<br>1.如果在edmunds和JATO申请的APi没有通过，就开始爬取edmunds的数据。<br>2.如果通过了，那么根据Api直接获取我们所需的数据。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are also not suited to large data transfers. In the systems in this chapter, each byte of data transferred between an I/O device and memory must pass through the CPU. This is inefficient for many common operations, such as loading a program from disk into memory. Direct memory access, DMA, is a method used to bypass the CPU in these transfers, thus performing them much more quickly.<br>我的翻译<br>这些I/O接口也不太适合大型数据传输。在这个部分的系统中，每个在I/O设备和内存间传输的数据字节都必须要通过CPU。这个对很多普通的操作是无效的，比如从内中磁条中加载程序。直接内存连接，DMA是一种方法用来错开这些传输的CPU,因此程序必须运行快一点。<br>正确翻译<br>这些I/O接口也不适合大量的数据传输。在本章的系统中，I/O设备和存储器之间传输的每一个字节都必须通过CPU，这对于许多常见的操作（例如从磁盘向主机存装载一个程序）来说效率低下。直接存储器访问就是在数据传输中绕过CPU的一种方法，因此执行起来速度很快。</p>\n"},{"title":"2017-08-03 Report","date":"2017-08-03T07:27:45.000Z","_content":"当天完成的工作内容\n1.update compare api to handle cache problem\n2.add refresh_relation_tree commands.\n当天的收获\n1.问题： 前天爬取edmunds的数据库的时候写过一段Insert 的SQL，但是表里的字段有50多个，我写的SQL逐个复制了五十多个字段，非常的麻烦。\n2.反思： 如果五十个多个字段，有改动，那么又要重新粘贴，而且参数检查也非常的麻烦 –>\n怎么让参数简洁，便于改动呢？ –> 用Orm，写一个数据对象，爬虫解析Html标签的时候，直接赋值，赋值结束后直接commit，这样就避免了写一条五十多个参数的SQL语句。\n3.方法： 我先去看了sqlalchemy这个支持orm操作的库 –> 学习了简单的增删改查的使用 –> 修改原来的代码中数据库的部分 –> 可以直接save了，但是处理数据的部分就在爬虫的同时完成了，这不符合scrapy的设计哲学 –> scrapy 的爬虫部分应该是只负责爬取数据，数据的持久化应该由pipeline去完成，而不是直接在爬虫部分做完。 –> 所以碰到了新的问题，如何把sqlalchemy的操作在Pipeline里完成。\n今日只解决了sql参数的问题，但是新的问题未解决。 明晚的总结来写新的问题。\n明天的计划\n1.edmunds只抓取了New car的data，数据还不够，明天找找used car的数据接口。\n提出疑问或寻求帮助\n无。\n今日翻译\nBefore numbers are converted from one number base to another, the digits of a number system must be understood. Early in our education, we learned that a decimal, or base 10, number was constructed with 10 digits: 0 through 9. The first digit in any numbering system is always a zero. For example, a base 8 (octal) number contains 8 digits: 0 through 7; a base 2 (binary) number contains 2 digits: 0 and 1.\n我的翻译\n在一个数字从基于某一数字的另一个数字转换之前，必须要理解数字的系统。在我们教育的早期，我们学习到十进制，或者基于10，数字会被转换成10个数字： 0-9，第一个数字在其他任何数字系统里都是一个0.举个例子，八进制的系统里有8个数字：0-7， 基于二进制的数字里包含2个数字： 0-1 \n正确翻译\n将数从—种数制向另一种数制转换之前，必须了解数的计数系统。在早期教育中，我们已学习了十进制数，或以10为基的数，它由10个数字组成：0到9。任何计数制的第一个数字总是零，这种规则适用于任何其他数制。例如，以8为基的数(八进制)包含8个数字：0到7，而以2为基的数(二进制)包含2个数字：0和1。","source":"_posts/2017-08-03.md","raw":"---\ntitle: 2017-08-03 Report\ndate: 2017-08-03 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.update compare api to handle cache problem\n2.add refresh_relation_tree commands.\n当天的收获\n1.问题： 前天爬取edmunds的数据库的时候写过一段Insert 的SQL，但是表里的字段有50多个，我写的SQL逐个复制了五十多个字段，非常的麻烦。\n2.反思： 如果五十个多个字段，有改动，那么又要重新粘贴，而且参数检查也非常的麻烦 –>\n怎么让参数简洁，便于改动呢？ –> 用Orm，写一个数据对象，爬虫解析Html标签的时候，直接赋值，赋值结束后直接commit，这样就避免了写一条五十多个参数的SQL语句。\n3.方法： 我先去看了sqlalchemy这个支持orm操作的库 –> 学习了简单的增删改查的使用 –> 修改原来的代码中数据库的部分 –> 可以直接save了，但是处理数据的部分就在爬虫的同时完成了，这不符合scrapy的设计哲学 –> scrapy 的爬虫部分应该是只负责爬取数据，数据的持久化应该由pipeline去完成，而不是直接在爬虫部分做完。 –> 所以碰到了新的问题，如何把sqlalchemy的操作在Pipeline里完成。\n今日只解决了sql参数的问题，但是新的问题未解决。 明晚的总结来写新的问题。\n明天的计划\n1.edmunds只抓取了New car的data，数据还不够，明天找找used car的数据接口。\n提出疑问或寻求帮助\n无。\n今日翻译\nBefore numbers are converted from one number base to another, the digits of a number system must be understood. Early in our education, we learned that a decimal, or base 10, number was constructed with 10 digits: 0 through 9. The first digit in any numbering system is always a zero. For example, a base 8 (octal) number contains 8 digits: 0 through 7; a base 2 (binary) number contains 2 digits: 0 and 1.\n我的翻译\n在一个数字从基于某一数字的另一个数字转换之前，必须要理解数字的系统。在我们教育的早期，我们学习到十进制，或者基于10，数字会被转换成10个数字： 0-9，第一个数字在其他任何数字系统里都是一个0.举个例子，八进制的系统里有8个数字：0-7， 基于二进制的数字里包含2个数字： 0-1 \n正确翻译\n将数从—种数制向另一种数制转换之前，必须了解数的计数系统。在早期教育中，我们已学习了十进制数，或以10为基的数，它由10个数字组成：0到9。任何计数制的第一个数字总是零，这种规则适用于任何其他数制。例如，以8为基的数(八进制)包含8个数字：0到7，而以2为基的数(二进制)包含2个数字：0和1。","slug":"2017-08-03","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq00015lvtlxyaisyaz","content":"<p>当天完成的工作内容<br>1.update compare api to handle cache problem<br>2.add refresh_relation_tree commands.<br>当天的收获<br>1.问题： 前天爬取edmunds的数据库的时候写过一段Insert 的SQL，但是表里的字段有50多个，我写的SQL逐个复制了五十多个字段，非常的麻烦。<br>2.反思： 如果五十个多个字段，有改动，那么又要重新粘贴，而且参数检查也非常的麻烦 –&gt;<br>怎么让参数简洁，便于改动呢？ –&gt; 用Orm，写一个数据对象，爬虫解析Html标签的时候，直接赋值，赋值结束后直接commit，这样就避免了写一条五十多个参数的SQL语句。<br>3.方法： 我先去看了sqlalchemy这个支持orm操作的库 –&gt; 学习了简单的增删改查的使用 –&gt; 修改原来的代码中数据库的部分 –&gt; 可以直接save了，但是处理数据的部分就在爬虫的同时完成了，这不符合scrapy的设计哲学 –&gt; scrapy 的爬虫部分应该是只负责爬取数据，数据的持久化应该由pipeline去完成，而不是直接在爬虫部分做完。 –&gt; 所以碰到了新的问题，如何把sqlalchemy的操作在Pipeline里完成。<br>今日只解决了sql参数的问题，但是新的问题未解决。 明晚的总结来写新的问题。<br>明天的计划<br>1.edmunds只抓取了New car的data，数据还不够，明天找找used car的数据接口。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Before numbers are converted from one number base to another, the digits of a number system must be understood. Early in our education, we learned that a decimal, or base 10, number was constructed with 10 digits: 0 through 9. The first digit in any numbering system is always a zero. For example, a base 8 (octal) number contains 8 digits: 0 through 7; a base 2 (binary) number contains 2 digits: 0 and 1.<br>我的翻译<br>在一个数字从基于某一数字的另一个数字转换之前，必须要理解数字的系统。在我们教育的早期，我们学习到十进制，或者基于10，数字会被转换成10个数字： 0-9，第一个数字在其他任何数字系统里都是一个0.举个例子，八进制的系统里有8个数字：0-7， 基于二进制的数字里包含2个数字： 0-1<br>正确翻译<br>将数从—种数制向另一种数制转换之前，必须了解数的计数系统。在早期教育中，我们已学习了十进制数，或以10为基的数，它由10个数字组成：0到9。任何计数制的第一个数字总是零，这种规则适用于任何其他数制。例如，以8为基的数(八进制)包含8个数字：0到7，而以2为基的数(二进制)包含2个数字：0和1。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.update compare api to handle cache problem<br>2.add refresh_relation_tree commands.<br>当天的收获<br>1.问题： 前天爬取edmunds的数据库的时候写过一段Insert 的SQL，但是表里的字段有50多个，我写的SQL逐个复制了五十多个字段，非常的麻烦。<br>2.反思： 如果五十个多个字段，有改动，那么又要重新粘贴，而且参数检查也非常的麻烦 –&gt;<br>怎么让参数简洁，便于改动呢？ –&gt; 用Orm，写一个数据对象，爬虫解析Html标签的时候，直接赋值，赋值结束后直接commit，这样就避免了写一条五十多个参数的SQL语句。<br>3.方法： 我先去看了sqlalchemy这个支持orm操作的库 –&gt; 学习了简单的增删改查的使用 –&gt; 修改原来的代码中数据库的部分 –&gt; 可以直接save了，但是处理数据的部分就在爬虫的同时完成了，这不符合scrapy的设计哲学 –&gt; scrapy 的爬虫部分应该是只负责爬取数据，数据的持久化应该由pipeline去完成，而不是直接在爬虫部分做完。 –&gt; 所以碰到了新的问题，如何把sqlalchemy的操作在Pipeline里完成。<br>今日只解决了sql参数的问题，但是新的问题未解决。 明晚的总结来写新的问题。<br>明天的计划<br>1.edmunds只抓取了New car的data，数据还不够，明天找找used car的数据接口。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Before numbers are converted from one number base to another, the digits of a number system must be understood. Early in our education, we learned that a decimal, or base 10, number was constructed with 10 digits: 0 through 9. The first digit in any numbering system is always a zero. For example, a base 8 (octal) number contains 8 digits: 0 through 7; a base 2 (binary) number contains 2 digits: 0 and 1.<br>我的翻译<br>在一个数字从基于某一数字的另一个数字转换之前，必须要理解数字的系统。在我们教育的早期，我们学习到十进制，或者基于10，数字会被转换成10个数字： 0-9，第一个数字在其他任何数字系统里都是一个0.举个例子，八进制的系统里有8个数字：0-7， 基于二进制的数字里包含2个数字： 0-1<br>正确翻译<br>将数从—种数制向另一种数制转换之前，必须了解数的计数系统。在早期教育中，我们已学习了十进制数，或以10为基的数，它由10个数字组成：0到9。任何计数制的第一个数字总是零，这种规则适用于任何其他数制。例如，以8为基的数(八进制)包含8个数字：0到7，而以2为基的数(二进制)包含2个数字：0和1。</p>\n"},{"title":"2017-07-28 Report","date":"2017-07-28T07:27:45.000Z","_content":"当天完成的工作内容\n1.add relation_tree api\n2.update compare api\n当天的收获\n1.今天的总结是： 规范开发流程\n2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。\n3.反思：\n为什么写的代码没有健壮性？ –> 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –> 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –> 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –> 为什么没有认识到这样的差距? –> 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——> 开发流程出错在哪里了呢？ ——> 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。\n4.总结：\n规范需要实现的功能 –> 检查输入数据的类型 –> 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –> 输入数据检查通过后开始写功能 –> 功能\n中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –> 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –> 首先减少数据库操作次数，把查询上万次变成了查询一次 –> 用空间换时间，在实现的过程中，用dict做映射 –> 性能从30分钟变成了10S中，大大的优化了速度。 –> 性能问题解决后，要考虑异常情况 –> 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——> 异常解决后，功能才算是完成了。\n概括内容：\n问题： 代码健壮性差。\n反思： 开发流程有问题，没有规范的开发方法。\n总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。\n但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）\n明天的计划\n1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.\n我的翻译\n这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。\n正确译文\n这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。","source":"_posts/2017-07-28.md","raw":"---\ntitle: 2017-07-28 Report\ndate: 2017-07-28 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.add relation_tree api\n2.update compare api\n当天的收获\n1.今天的总结是： 规范开发流程\n2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。\n3.反思：\n为什么写的代码没有健壮性？ –> 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –> 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –> 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –> 为什么没有认识到这样的差距? –> 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——> 开发流程出错在哪里了呢？ ——> 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。\n4.总结：\n规范需要实现的功能 –> 检查输入数据的类型 –> 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –> 输入数据检查通过后开始写功能 –> 功能\n中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –> 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –> 首先减少数据库操作次数，把查询上万次变成了查询一次 –> 用空间换时间，在实现的过程中，用dict做映射 –> 性能从30分钟变成了10S中，大大的优化了速度。 –> 性能问题解决后，要考虑异常情况 –> 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——> 异常解决后，功能才算是完成了。\n概括内容：\n问题： 代码健壮性差。\n反思： 开发流程有问题，没有规范的开发方法。\n总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。\n但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）\n明天的计划\n1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.\n我的翻译\n这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。\n正确译文\n这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。","slug":"2017-07-28","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq00017lvtlmf3o4boo","content":"<p>当天完成的工作内容<br>1.add relation_tree api<br>2.update compare api<br>当天的收获<br>1.今天的总结是： 规范开发流程<br>2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。<br>3.反思：<br>为什么写的代码没有健壮性？ –&gt; 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –&gt; 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –&gt; 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –&gt; 为什么没有认识到这样的差距? –&gt; 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——&gt; 开发流程出错在哪里了呢？ ——&gt; 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。<br>4.总结：<br>规范需要实现的功能 –&gt; 检查输入数据的类型 –&gt; 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –&gt; 输入数据检查通过后开始写功能 –&gt; 功能<br>中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –&gt; 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –&gt; 首先减少数据库操作次数，把查询上万次变成了查询一次 –&gt; 用空间换时间，在实现的过程中，用dict做映射 –&gt; 性能从30分钟变成了10S中，大大的优化了速度。 –&gt; 性能问题解决后，要考虑异常情况 –&gt; 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——&gt; 异常解决后，功能才算是完成了。<br>概括内容：<br>问题： 代码健壮性差。<br>反思： 开发流程有问题，没有规范的开发方法。<br>总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。<br>但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）<br>明天的计划<br>1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.<br>我的翻译<br>这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。<br>正确译文<br>这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.add relation_tree api<br>2.update compare api<br>当天的收获<br>1.今天的总结是： 规范开发流程<br>2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。<br>3.反思：<br>为什么写的代码没有健壮性？ –&gt; 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –&gt; 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –&gt; 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –&gt; 为什么没有认识到这样的差距? –&gt; 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——&gt; 开发流程出错在哪里了呢？ ——&gt; 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。<br>4.总结：<br>规范需要实现的功能 –&gt; 检查输入数据的类型 –&gt; 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –&gt; 输入数据检查通过后开始写功能 –&gt; 功能<br>中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –&gt; 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –&gt; 首先减少数据库操作次数，把查询上万次变成了查询一次 –&gt; 用空间换时间，在实现的过程中，用dict做映射 –&gt; 性能从30分钟变成了10S中，大大的优化了速度。 –&gt; 性能问题解决后，要考虑异常情况 –&gt; 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——&gt; 异常解决后，功能才算是完成了。<br>概括内容：<br>问题： 代码健壮性差。<br>反思： 开发流程有问题，没有规范的开发方法。<br>总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。<br>但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）<br>明天的计划<br>1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.<br>我的翻译<br>这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。<br>正确译文<br>这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。</p>\n"},{"title":"2017-08-01 Report","date":"2017-08-01T07:27:45.000Z","_content":"当天完成的工作内容\n1.crawled car informations and configurations from edmunds.\n当天的收获\n1.问题： 今天跟学长（小超）在后端返回的数据格式上有争议，他希望我给每个child都加上parent_id的数据，但是我认为parent_id既然可以遍历获取到就没有必要让每个child都重复加上了。\n2.反思： 为什么学长希望我加上一段数据呢？ ——> 因为前端对于我返回的数据格式处理有点麻烦，希望我简化一下 –> 为什么我不愿意修改呢？ –> 其实不是怕麻烦的原因，我很愿意帮学长加上，不过我认为如果加上数据会导致parent_id的重复次数会等于其子节点的数量。而且parent_id即使不加上也是可以通过遍历得到的。 –> 那我是如何跟学长沟通的呢？ –> 我的沟通很差劲，1.因为这份数据是我提供的，我可能比学长更清楚一点数据如何使用。但是我没有换位思考，没有理解学长 2.虽然我认为没有必要修改，但是我却没有给学长提供一份可行的解决方案，导致问题的解决没有进展。3.前端的问题太复杂的时候，后端要帮忙简化问题，要互相帮助。\n4.目标： 合作中遇到问题时，能帮对方解决问题。\n3.总结： 1.换位思考 –> 从对方了解到的信息和他的解决思路考虑，先明白他的想法，再去沟通 –> 学长认为要加parent_id的原因，是因为获取到child_id的时候得不到parent_id。 –> 按照他的想法，确实是得不到Parent_id的，也确实加上Parent_id直接获取会更方便些。 –> 明白了他的需求后，考虑有没有比他提供的解决思路更好的办法 –> 我觉得可以在遍历的child的时候，在循环里加上parent_id=当前Id，因为遍历当前节点的id可以默认为是父亲节点，也可以用得到的parent_id和child_id做多对一或者一对多的映射，这样用child_id就可以直接得到parent_id了。 –> 先跟告诉对方我的解决方案，让对方看看这个方案是不是更合适，如果我想到的可行方案都不能work –> 那么直接按照对方的思路去做，我去在后端加上Parent_id。 –> 如果能work，那么问题得到解决。 –> 最后伟哥给学长提了用栈的思路，在前端解决了这个问题。不需要后端的变动。（当时学长告诉我的问题是得不到parent_id，所以我觉得映射就可以了，而用栈是针对于实际碰到的问题的解决方法）\n明天的计划\n1.解决edmuds访问过快会403的问题。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe use of the microprocessor requires a working knowledge of binary, decimal, and hexadecimal numbering systems. This section provides a background for those who are unfamiliar with number systems. Conversions between decimal and binary, decimal and hexadecimal, and binary and hexadecimal are described.\n我的翻译\n使用微型处理器需要有二进制，十进制和十六进制的数字系统的工作知识。这个层面提供一个背景给那些不熟悉数字系统的人。描述在十进制和二进制，十进制的十六进制，二进制和十六进制的转换。\n正确翻译\n使用微处理器需要掌握二进制、十进制和十六进制数制系统的基本知识，本节为那些不熟悉数制系统的读者提供这方面的背景知识。说明了十进制与二进制之间、十进制与十六进制之间，及二进制与十六进制之间的转换。","source":"_posts/2017-08-01.md","raw":"---\ntitle: 2017-08-01 Report\ndate: 2017-08-01 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.crawled car informations and configurations from edmunds.\n当天的收获\n1.问题： 今天跟学长（小超）在后端返回的数据格式上有争议，他希望我给每个child都加上parent_id的数据，但是我认为parent_id既然可以遍历获取到就没有必要让每个child都重复加上了。\n2.反思： 为什么学长希望我加上一段数据呢？ ——> 因为前端对于我返回的数据格式处理有点麻烦，希望我简化一下 –> 为什么我不愿意修改呢？ –> 其实不是怕麻烦的原因，我很愿意帮学长加上，不过我认为如果加上数据会导致parent_id的重复次数会等于其子节点的数量。而且parent_id即使不加上也是可以通过遍历得到的。 –> 那我是如何跟学长沟通的呢？ –> 我的沟通很差劲，1.因为这份数据是我提供的，我可能比学长更清楚一点数据如何使用。但是我没有换位思考，没有理解学长 2.虽然我认为没有必要修改，但是我却没有给学长提供一份可行的解决方案，导致问题的解决没有进展。3.前端的问题太复杂的时候，后端要帮忙简化问题，要互相帮助。\n4.目标： 合作中遇到问题时，能帮对方解决问题。\n3.总结： 1.换位思考 –> 从对方了解到的信息和他的解决思路考虑，先明白他的想法，再去沟通 –> 学长认为要加parent_id的原因，是因为获取到child_id的时候得不到parent_id。 –> 按照他的想法，确实是得不到Parent_id的，也确实加上Parent_id直接获取会更方便些。 –> 明白了他的需求后，考虑有没有比他提供的解决思路更好的办法 –> 我觉得可以在遍历的child的时候，在循环里加上parent_id=当前Id，因为遍历当前节点的id可以默认为是父亲节点，也可以用得到的parent_id和child_id做多对一或者一对多的映射，这样用child_id就可以直接得到parent_id了。 –> 先跟告诉对方我的解决方案，让对方看看这个方案是不是更合适，如果我想到的可行方案都不能work –> 那么直接按照对方的思路去做，我去在后端加上Parent_id。 –> 如果能work，那么问题得到解决。 –> 最后伟哥给学长提了用栈的思路，在前端解决了这个问题。不需要后端的变动。（当时学长告诉我的问题是得不到parent_id，所以我觉得映射就可以了，而用栈是针对于实际碰到的问题的解决方法）\n明天的计划\n1.解决edmuds访问过快会403的问题。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe use of the microprocessor requires a working knowledge of binary, decimal, and hexadecimal numbering systems. This section provides a background for those who are unfamiliar with number systems. Conversions between decimal and binary, decimal and hexadecimal, and binary and hexadecimal are described.\n我的翻译\n使用微型处理器需要有二进制，十进制和十六进制的数字系统的工作知识。这个层面提供一个背景给那些不熟悉数字系统的人。描述在十进制和二进制，十进制的十六进制，二进制和十六进制的转换。\n正确翻译\n使用微处理器需要掌握二进制、十进制和十六进制数制系统的基本知识，本节为那些不熟悉数制系统的读者提供这方面的背景知识。说明了十进制与二进制之间、十进制与十六进制之间，及二进制与十六进制之间的转换。","slug":"2017-08-01","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq10019lvtl8y7154qv","content":"<p>当天完成的工作内容<br>1.crawled car informations and configurations from edmunds.<br>当天的收获<br>1.问题： 今天跟学长（小超）在后端返回的数据格式上有争议，他希望我给每个child都加上parent_id的数据，但是我认为parent_id既然可以遍历获取到就没有必要让每个child都重复加上了。<br>2.反思： 为什么学长希望我加上一段数据呢？ ——&gt; 因为前端对于我返回的数据格式处理有点麻烦，希望我简化一下 –&gt; 为什么我不愿意修改呢？ –&gt; 其实不是怕麻烦的原因，我很愿意帮学长加上，不过我认为如果加上数据会导致parent_id的重复次数会等于其子节点的数量。而且parent_id即使不加上也是可以通过遍历得到的。 –&gt; 那我是如何跟学长沟通的呢？ –&gt; 我的沟通很差劲，1.因为这份数据是我提供的，我可能比学长更清楚一点数据如何使用。但是我没有换位思考，没有理解学长 2.虽然我认为没有必要修改，但是我却没有给学长提供一份可行的解决方案，导致问题的解决没有进展。3.前端的问题太复杂的时候，后端要帮忙简化问题，要互相帮助。<br>4.目标： 合作中遇到问题时，能帮对方解决问题。<br>3.总结： 1.换位思考 –&gt; 从对方了解到的信息和他的解决思路考虑，先明白他的想法，再去沟通 –&gt; 学长认为要加parent_id的原因，是因为获取到child_id的时候得不到parent_id。 –&gt; 按照他的想法，确实是得不到Parent_id的，也确实加上Parent_id直接获取会更方便些。 –&gt; 明白了他的需求后，考虑有没有比他提供的解决思路更好的办法 –&gt; 我觉得可以在遍历的child的时候，在循环里加上parent_id=当前Id，因为遍历当前节点的id可以默认为是父亲节点，也可以用得到的parent_id和child_id做多对一或者一对多的映射，这样用child_id就可以直接得到parent_id了。 –&gt; 先跟告诉对方我的解决方案，让对方看看这个方案是不是更合适，如果我想到的可行方案都不能work –&gt; 那么直接按照对方的思路去做，我去在后端加上Parent_id。 –&gt; 如果能work，那么问题得到解决。 –&gt; 最后伟哥给学长提了用栈的思路，在前端解决了这个问题。不需要后端的变动。（当时学长告诉我的问题是得不到parent_id，所以我觉得映射就可以了，而用栈是针对于实际碰到的问题的解决方法）<br>明天的计划<br>1.解决edmuds访问过快会403的问题。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The use of the microprocessor requires a working knowledge of binary, decimal, and hexadecimal numbering systems. This section provides a background for those who are unfamiliar with number systems. Conversions between decimal and binary, decimal and hexadecimal, and binary and hexadecimal are described.<br>我的翻译<br>使用微型处理器需要有二进制，十进制和十六进制的数字系统的工作知识。这个层面提供一个背景给那些不熟悉数字系统的人。描述在十进制和二进制，十进制的十六进制，二进制和十六进制的转换。<br>正确翻译<br>使用微处理器需要掌握二进制、十进制和十六进制数制系统的基本知识，本节为那些不熟悉数制系统的读者提供这方面的背景知识。说明了十进制与二进制之间、十进制与十六进制之间，及二进制与十六进制之间的转换。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.crawled car informations and configurations from edmunds.<br>当天的收获<br>1.问题： 今天跟学长（小超）在后端返回的数据格式上有争议，他希望我给每个child都加上parent_id的数据，但是我认为parent_id既然可以遍历获取到就没有必要让每个child都重复加上了。<br>2.反思： 为什么学长希望我加上一段数据呢？ ——&gt; 因为前端对于我返回的数据格式处理有点麻烦，希望我简化一下 –&gt; 为什么我不愿意修改呢？ –&gt; 其实不是怕麻烦的原因，我很愿意帮学长加上，不过我认为如果加上数据会导致parent_id的重复次数会等于其子节点的数量。而且parent_id即使不加上也是可以通过遍历得到的。 –&gt; 那我是如何跟学长沟通的呢？ –&gt; 我的沟通很差劲，1.因为这份数据是我提供的，我可能比学长更清楚一点数据如何使用。但是我没有换位思考，没有理解学长 2.虽然我认为没有必要修改，但是我却没有给学长提供一份可行的解决方案，导致问题的解决没有进展。3.前端的问题太复杂的时候，后端要帮忙简化问题，要互相帮助。<br>4.目标： 合作中遇到问题时，能帮对方解决问题。<br>3.总结： 1.换位思考 –&gt; 从对方了解到的信息和他的解决思路考虑，先明白他的想法，再去沟通 –&gt; 学长认为要加parent_id的原因，是因为获取到child_id的时候得不到parent_id。 –&gt; 按照他的想法，确实是得不到Parent_id的，也确实加上Parent_id直接获取会更方便些。 –&gt; 明白了他的需求后，考虑有没有比他提供的解决思路更好的办法 –&gt; 我觉得可以在遍历的child的时候，在循环里加上parent_id=当前Id，因为遍历当前节点的id可以默认为是父亲节点，也可以用得到的parent_id和child_id做多对一或者一对多的映射，这样用child_id就可以直接得到parent_id了。 –&gt; 先跟告诉对方我的解决方案，让对方看看这个方案是不是更合适，如果我想到的可行方案都不能work –&gt; 那么直接按照对方的思路去做，我去在后端加上Parent_id。 –&gt; 如果能work，那么问题得到解决。 –&gt; 最后伟哥给学长提了用栈的思路，在前端解决了这个问题。不需要后端的变动。（当时学长告诉我的问题是得不到parent_id，所以我觉得映射就可以了，而用栈是针对于实际碰到的问题的解决方法）<br>明天的计划<br>1.解决edmuds访问过快会403的问题。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The use of the microprocessor requires a working knowledge of binary, decimal, and hexadecimal numbering systems. This section provides a background for those who are unfamiliar with number systems. Conversions between decimal and binary, decimal and hexadecimal, and binary and hexadecimal are described.<br>我的翻译<br>使用微型处理器需要有二进制，十进制和十六进制的数字系统的工作知识。这个层面提供一个背景给那些不熟悉数字系统的人。描述在十进制和二进制，十进制的十六进制，二进制和十六进制的转换。<br>正确翻译<br>使用微处理器需要掌握二进制、十进制和十六进制数制系统的基本知识，本节为那些不熟悉数制系统的读者提供这方面的背景知识。说明了十进制与二进制之间、十进制与十六进制之间，及二进制与十六进制之间的转换。</p>\n"},{"title":"2017-08-07 Report","date":"2017-08-07T07:27:45.000Z","_content":"当天完成的工作内容\n1.get features of car from edmunds\n当天的收获\n1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。\n2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——> 在A中开始爬取就会有no find的问题，但是在B中爬取文件就没有问题。 –> 那么既然运行的文件和目标文件都在同一个文件夹里，怎么会有这样的问题呢？ ——> 用os.getcwd()做个测试，发现在A中运行B中的文件和B中直接运行得到的路径是不一样的 –> 所以路径取决于运行文件的位置而不是文件所在的位置。\n3.方法： 遇到no find file or directory的问题 ——> 先检查一遍文件名的反斜杠，避免转义的问题。 –> 文件名，如果使用相对路径，那么检查运行文件的位置时候是跟文件所处的路径相同。 –> 如果路径不同，那么要修改文件名为运行的路径位置，或者使用绝对路径。\n总结： 如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n明天的计划\n1.get tire pressure data。\n提出疑问或寻求帮助\n无。\n今日翻译\nIf the base of a number exceeds 10, the additional digits use the letters of the alphabet, beginning with an A, For example, a base 12 number contains 12 digits: 0 through 9, followed by A for 10 and B for 11, Note that a base 10 number does not contain a 10 digit, just as a base 8 number does not contain an 8 digit. The most common numbering systems used with computers are decimal, binary, and hexadecimal (base 16). (Many years ago octal numbers were popular.) Each system is described and used in this section of the chapter.\n\n我的翻译\n如果基数超过10，那么10之后的数字使用字母，从A开始。举个例子，12进制包含12个数字，0到9，之后是A表示10，B表示11。注意10进制不包括10这个数字，就好像8进制没有8。最常使用的数字系统是十进制和十六进制（许多年以前流行八进制）。每一个系统被这个部分的章节使用和描述。\n正确翻译\n如果基数大于10，其余数字用从A开始的字母表示，例如，以12为基的数包含12个数字，0到9，之后用A代表10，B代表11。注意，以10为基的数不包含数字10，如同以8为基的数不包括数字8一样。计算机中最通用的计数制是十进制、二进制、八进制和十六进制(基为16)。每种计数制都将在本节中进行说明和应用。","source":"_posts/2017-08-07.md","raw":"---\ntitle: 2017-08-07 Report\ndate: 2017-08-07 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.get features of car from edmunds\n当天的收获\n1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。\n2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——> 在A中开始爬取就会有no find的问题，但是在B中爬取文件就没有问题。 –> 那么既然运行的文件和目标文件都在同一个文件夹里，怎么会有这样的问题呢？ ——> 用os.getcwd()做个测试，发现在A中运行B中的文件和B中直接运行得到的路径是不一样的 –> 所以路径取决于运行文件的位置而不是文件所在的位置。\n3.方法： 遇到no find file or directory的问题 ——> 先检查一遍文件名的反斜杠，避免转义的问题。 –> 文件名，如果使用相对路径，那么检查运行文件的位置时候是跟文件所处的路径相同。 –> 如果路径不同，那么要修改文件名为运行的路径位置，或者使用绝对路径。\n总结： 如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n明天的计划\n1.get tire pressure data。\n提出疑问或寻求帮助\n无。\n今日翻译\nIf the base of a number exceeds 10, the additional digits use the letters of the alphabet, beginning with an A, For example, a base 12 number contains 12 digits: 0 through 9, followed by A for 10 and B for 11, Note that a base 10 number does not contain a 10 digit, just as a base 8 number does not contain an 8 digit. The most common numbering systems used with computers are decimal, binary, and hexadecimal (base 16). (Many years ago octal numbers were popular.) Each system is described and used in this section of the chapter.\n\n我的翻译\n如果基数超过10，那么10之后的数字使用字母，从A开始。举个例子，12进制包含12个数字，0到9，之后是A表示10，B表示11。注意10进制不包括10这个数字，就好像8进制没有8。最常使用的数字系统是十进制和十六进制（许多年以前流行八进制）。每一个系统被这个部分的章节使用和描述。\n正确翻译\n如果基数大于10，其余数字用从A开始的字母表示，例如，以12为基的数包含12个数字，0到9，之后用A代表10，B代表11。注意，以10为基的数不包含数字10，如同以8为基的数不包括数字8一样。计算机中最通用的计数制是十进制、二进制、八进制和十六进制(基为16)。每种计数制都将在本节中进行说明和应用。","slug":"2017-08-07","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq2001blvtl7ufwaueh","content":"<p>当天完成的工作内容<br>1.get features of car from edmunds<br>当天的收获<br>1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。<br>2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——&gt; 在A中开始爬取就会有no find的问题，但是在B中爬取文件就没有问题。 –&gt; 那么既然运行的文件和目标文件都在同一个文件夹里，怎么会有这样的问题呢？ ——&gt; 用os.getcwd()做个测试，发现在A中运行B中的文件和B中直接运行得到的路径是不一样的 –&gt; 所以路径取决于运行文件的位置而不是文件所在的位置。<br>3.方法： 遇到no find file or directory的问题 ——&gt; 先检查一遍文件名的反斜杠，避免转义的问题。 –&gt; 文件名，如果使用相对路径，那么检查运行文件的位置时候是跟文件所处的路径相同。 –&gt; 如果路径不同，那么要修改文件名为运行的路径位置，或者使用绝对路径。<br>总结： 如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。<br>明天的计划<br>1.get tire pressure data。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>If the base of a number exceeds 10, the additional digits use the letters of the alphabet, beginning with an A, For example, a base 12 number contains 12 digits: 0 through 9, followed by A for 10 and B for 11, Note that a base 10 number does not contain a 10 digit, just as a base 8 number does not contain an 8 digit. The most common numbering systems used with computers are decimal, binary, and hexadecimal (base 16). (Many years ago octal numbers were popular.) Each system is described and used in this section of the chapter.</p>\n<p>我的翻译<br>如果基数超过10，那么10之后的数字使用字母，从A开始。举个例子，12进制包含12个数字，0到9，之后是A表示10，B表示11。注意10进制不包括10这个数字，就好像8进制没有8。最常使用的数字系统是十进制和十六进制（许多年以前流行八进制）。每一个系统被这个部分的章节使用和描述。<br>正确翻译<br>如果基数大于10，其余数字用从A开始的字母表示，例如，以12为基的数包含12个数字，0到9，之后用A代表10，B代表11。注意，以10为基的数不包含数字10，如同以8为基的数不包括数字8一样。计算机中最通用的计数制是十进制、二进制、八进制和十六进制(基为16)。每种计数制都将在本节中进行说明和应用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.get features of car from edmunds<br>当天的收获<br>1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。<br>2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——&gt; 在A中开始爬取就会有no find的问题，但是在B中爬取文件就没有问题。 –&gt; 那么既然运行的文件和目标文件都在同一个文件夹里，怎么会有这样的问题呢？ ——&gt; 用os.getcwd()做个测试，发现在A中运行B中的文件和B中直接运行得到的路径是不一样的 –&gt; 所以路径取决于运行文件的位置而不是文件所在的位置。<br>3.方法： 遇到no find file or directory的问题 ——&gt; 先检查一遍文件名的反斜杠，避免转义的问题。 –&gt; 文件名，如果使用相对路径，那么检查运行文件的位置时候是跟文件所处的路径相同。 –&gt; 如果路径不同，那么要修改文件名为运行的路径位置，或者使用绝对路径。<br>总结： 如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。<br>明天的计划<br>1.get tire pressure data。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>If the base of a number exceeds 10, the additional digits use the letters of the alphabet, beginning with an A, For example, a base 12 number contains 12 digits: 0 through 9, followed by A for 10 and B for 11, Note that a base 10 number does not contain a 10 digit, just as a base 8 number does not contain an 8 digit. The most common numbering systems used with computers are decimal, binary, and hexadecimal (base 16). (Many years ago octal numbers were popular.) Each system is described and used in this section of the chapter.</p>\n<p>我的翻译<br>如果基数超过10，那么10之后的数字使用字母，从A开始。举个例子，12进制包含12个数字，0到9，之后是A表示10，B表示11。注意10进制不包括10这个数字，就好像8进制没有8。最常使用的数字系统是十进制和十六进制（许多年以前流行八进制）。每一个系统被这个部分的章节使用和描述。<br>正确翻译<br>如果基数大于10，其余数字用从A开始的字母表示，例如，以12为基的数包含12个数字，0到9，之后用A代表10，B代表11。注意，以10为基的数不包含数字10，如同以8为基的数不包括数字8一样。计算机中最通用的计数制是十进制、二进制、八进制和十六进制(基为16)。每种计数制都将在本节中进行说明和应用。</p>\n"},{"title":"2017-08-04 Report","date":"2017-08-04T07:27:45.000Z","_content":"当天完成的工作内容\n1.add relation_tree api\n2.update compare api\n当天的收获\n1.今天的总结是： 规范开发流程\n2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。\n3.反思：\n为什么写的代码没有健壮性？ –> 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –> 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –> 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –> 为什么没有认识到这样的差距? –> 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——> 开发流程出错在哪里了呢？ ——> 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。\n4.总结：\n规范需要实现的功能 –> 检查输入数据的类型 –> 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –> 输入数据检查通过后开始写功能 –> 功能\n中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –> 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –> 首先减少数据库操作次数，把查询上万次变成了查询一次 –> 用空间换时间，在实现的过程中，用dict做映射 –> 性能从30分钟变成了10S中，大大的优化了速度。 –> 性能问题解决后，要考虑异常情况 –> 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——> 异常解决后，功能才算是完成了。\n概括内容：\n问题： 代码健壮性差。\n反思： 开发流程有问题，没有规范的开发方法。\n总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。\n但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）\n明天的计划\n1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.\n我的翻译\n这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。\n正确译文\n这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。\n当天完成的工作内容\n1.api/relation_tree\n当天的收获\n1.问题: 如何快速理解sql代码及写sql\n2.目标: 逻辑清晰的逐步完成复杂的sql\n3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –> 首先我没有把SQL格式化，SQL非常混乱难以阅读 –> 用在线工具格式化后，SQL逻辑清晰 –> 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –> 伟哥纠正我SQL要从内层向外层读 –> 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –>\n因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。\n4.方法：遇到SQL代码 –> formmater sql –> 从内至外的逐层阅读代码 –> 每一层阅读完，先核对数据的变化 –> 从变化中，思考业务逻辑。 \n5.用总结的方法重新处理一遍今天遇到的问题：\n原来的SQL:\nselect left(t2.published_at,7) month, count(*) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)>=’2011-01’ group by left(t2.published_at,7)\nFrommater后：\nSELECT left(t2.published_at,7) MONTH,\n                               count(*) AS value\nFROM\n  (SELECT d.asin AS parent_asin\n   FROM\n     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id\n      FROM amazon_review_insight.amazon_amazonasin\n      WHERE %s ) c\n   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1\nINNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin\nWHERE left(t2.published_at,7)>=’2011-01’\nGROUP BY left(t2.published_at,7)\n从内到外的阅读：\n1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH>=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。\n明天的计划\n1.在SQL里面嵌套一层Category的连接。\n2.帮公司同事完成OBD的数据爬取。\n提出疑问或寻求帮助\n无。\n今日翻译\nMost CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.\n我的译文\n大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。\n正确译文\n大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。\n当天完成的工作内容\n1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。\n当天的收获\n1.总结的内容是： 如何用最短的时间找到靠谱的api？\n2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –> 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –> 那么只能去网上寻找资源 –> 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –> 那么如何有效的从这些资源里，快速找到我所需要的呢？ –> 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –> 那么现在根据近期记录的搜索方案，整理一下技巧。\n3.查找方法的总结：\n先分析一下问题 –> 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –> 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –> 重新跟伟哥确认一下需求或者问题 –> 重复上述步骤 –> 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –> 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –> 把轮子或者教程看明白后再开始动手写代码。\n概括上述内容：\n1.需求： fix Bug或者优化已有功能。\n2.目标： 用最少的时间去找到合适的轮子/fix bug。\n3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –>  动手前先跟伟哥沟通好，确认方案有可行性再写代码。 \n明天的计划\n1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。\n2.熟悉patter api后，用到avatar上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.\nI/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.\nI/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。\n当天完成的工作内容\n1.x。\n当天的收获（简要概括在后面）\n1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。\n问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？\n我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）\n上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。\n反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –> 说话没有把握重点，想描述细节，但是细节与问题无关 –> 为什么没有用简单的语言说出重点 –> 因为问题我还没有思考完，我就开始回答了 –> 为什么问题不考虑完就要回答？ –> 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –> 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –> 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –> 为什么思维分散？ –> 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –> 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。\n目标是什么：\n要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。\n方法：\n完整的听完问题 –> 在脑中把问题重复几遍 ——> 如果对问题有不理解的地方，先问清楚 –> 确保问题已经听明白了 –> 思考问题的答案 –> 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –> 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –> 如果答案与问题完全相关，再回答 –> 如果思考偏了，跟对方请求一下再考虑一会。 –> 回答的时候，在心中默念问题 –> 只回答与问题有关的内容，无关的话不要说出来。 –> 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。\n实践总结的方法重新回答赵赵的问题：\n1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。\n2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。\n3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。\n4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。\n简要概括：\n问题：回答别人的提问时，回答冗余，并且逻辑混乱\n方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。\n目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。\n明天的计划\n1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。\n提出疑问或寻求帮助\n无。\n今日翻译\nBald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.\nA new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.\n我的译文\n研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。\n来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。\n正确译文\n研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。\n美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。\n当天完成的工作内容\n1.给avatar的后端服务器加了Ip的rate限制。\n当天的收获\n1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。\n问题：眼界低，技术视野很窄。\n反思：为什么同样是技术人员，别人聊的内容我完全不理解 –> 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –> 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –>  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –> 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –> 惰性让我看到舒适区以外的陌生技术，就想着逃避 –> 没有强迫自己去拓展技术栈\n总结：\n首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –> 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –> 碎片时间看github，周一到周五每天star至少一个项目 –> 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）\n翻译英文文档和读技术博客是为了补足基础知识 –> 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –> 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。 \n千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。\n明天的计划\n1.修改github上ratelimit api，使其更好的贴合avatar。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.\n我的译文\n在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。\n正确译文\n装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务","source":"_posts/2017-08-04.md","raw":"---\ntitle: 2017-08-04 Report\ndate: 2017-08-04 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.add relation_tree api\n2.update compare api\n当天的收获\n1.今天的总结是： 规范开发流程\n2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。\n3.反思：\n为什么写的代码没有健壮性？ –> 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –> 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –> 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –> 为什么没有认识到这样的差距? –> 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——> 开发流程出错在哪里了呢？ ——> 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。\n4.总结：\n规范需要实现的功能 –> 检查输入数据的类型 –> 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –> 输入数据检查通过后开始写功能 –> 功能\n中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –> 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –> 首先减少数据库操作次数，把查询上万次变成了查询一次 –> 用空间换时间，在实现的过程中，用dict做映射 –> 性能从30分钟变成了10S中，大大的优化了速度。 –> 性能问题解决后，要考虑异常情况 –> 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——> 异常解决后，功能才算是完成了。\n概括内容：\n问题： 代码健壮性差。\n反思： 开发流程有问题，没有规范的开发方法。\n总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。\n但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）\n明天的计划\n1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。\n提出疑问或寻求帮助\n无。\n今日翻译\nThese I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.\n我的翻译\n这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。\n正确译文\n这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。\n当天完成的工作内容\n1.api/relation_tree\n当天的收获\n1.问题: 如何快速理解sql代码及写sql\n2.目标: 逻辑清晰的逐步完成复杂的sql\n3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –> 首先我没有把SQL格式化，SQL非常混乱难以阅读 –> 用在线工具格式化后，SQL逻辑清晰 –> 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –> 伟哥纠正我SQL要从内层向外层读 –> 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –>\n因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。\n4.方法：遇到SQL代码 –> formmater sql –> 从内至外的逐层阅读代码 –> 每一层阅读完，先核对数据的变化 –> 从变化中，思考业务逻辑。 \n5.用总结的方法重新处理一遍今天遇到的问题：\n原来的SQL:\nselect left(t2.published_at,7) month, count(*) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)>=’2011-01’ group by left(t2.published_at,7)\nFrommater后：\nSELECT left(t2.published_at,7) MONTH,\n                               count(*) AS value\nFROM\n  (SELECT d.asin AS parent_asin\n   FROM\n     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id\n      FROM amazon_review_insight.amazon_amazonasin\n      WHERE %s ) c\n   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1\nINNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin\nWHERE left(t2.published_at,7)>=’2011-01’\nGROUP BY left(t2.published_at,7)\n从内到外的阅读：\n1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH>=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。\n明天的计划\n1.在SQL里面嵌套一层Category的连接。\n2.帮公司同事完成OBD的数据爬取。\n提出疑问或寻求帮助\n无。\n今日翻译\nMost CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.\n我的译文\n大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。\n正确译文\n大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。\n当天完成的工作内容\n1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。\n当天的收获\n1.总结的内容是： 如何用最短的时间找到靠谱的api？\n2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –> 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –> 那么只能去网上寻找资源 –> 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –> 那么如何有效的从这些资源里，快速找到我所需要的呢？ –> 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –> 那么现在根据近期记录的搜索方案，整理一下技巧。\n3.查找方法的总结：\n先分析一下问题 –> 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –> 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –> 重新跟伟哥确认一下需求或者问题 –> 重复上述步骤 –> 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –> 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –> 把轮子或者教程看明白后再开始动手写代码。\n概括上述内容：\n1.需求： fix Bug或者优化已有功能。\n2.目标： 用最少的时间去找到合适的轮子/fix bug。\n3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –>  动手前先跟伟哥沟通好，确认方案有可行性再写代码。 \n明天的计划\n1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。\n2.熟悉patter api后，用到avatar上。\n提出疑问或寻求帮助\n无。\n今日翻译\nI/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.\nI/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.\nI/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。\n当天完成的工作内容\n1.x。\n当天的收获（简要概括在后面）\n1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。\n问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？\n我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）\n上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。\n反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –> 说话没有把握重点，想描述细节，但是细节与问题无关 –> 为什么没有用简单的语言说出重点 –> 因为问题我还没有思考完，我就开始回答了 –> 为什么问题不考虑完就要回答？ –> 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –> 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –> 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –> 为什么思维分散？ –> 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –> 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。\n目标是什么：\n要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。\n方法：\n完整的听完问题 –> 在脑中把问题重复几遍 ——> 如果对问题有不理解的地方，先问清楚 –> 确保问题已经听明白了 –> 思考问题的答案 –> 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –> 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –> 如果答案与问题完全相关，再回答 –> 如果思考偏了，跟对方请求一下再考虑一会。 –> 回答的时候，在心中默念问题 –> 只回答与问题有关的内容，无关的话不要说出来。 –> 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。\n实践总结的方法重新回答赵赵的问题：\n1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。\n2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。\n3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。\n4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。\n简要概括：\n问题：回答别人的提问时，回答冗余，并且逻辑混乱\n方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。\n目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。\n明天的计划\n1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。\n提出疑问或寻求帮助\n无。\n今日翻译\nBald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.\nA new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.\n我的译文\n研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。\n来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。\n正确译文\n研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。\n美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。\n当天完成的工作内容\n1.给avatar的后端服务器加了Ip的rate限制。\n当天的收获\n1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。\n问题：眼界低，技术视野很窄。\n反思：为什么同样是技术人员，别人聊的内容我完全不理解 –> 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –> 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –>  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –> 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –> 惰性让我看到舒适区以外的陌生技术，就想着逃避 –> 没有强迫自己去拓展技术栈\n总结：\n首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –> 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –> 碎片时间看github，周一到周五每天star至少一个项目 –> 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）\n翻译英文文档和读技术博客是为了补足基础知识 –> 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –> 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。 \n千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。\n明天的计划\n1.修改github上ratelimit api，使其更好的贴合avatar。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.\n我的译文\n在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。\n正确译文\n装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务","slug":"2017-08-04","published":1,"updated":"2017-11-04T09:51:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq2001dlvtlmlquakcc","content":"<p>当天完成的工作内容<br>1.add relation_tree api<br>2.update compare api<br>当天的收获<br>1.今天的总结是： 规范开发流程<br>2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。<br>3.反思：<br>为什么写的代码没有健壮性？ –&gt; 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –&gt; 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –&gt; 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –&gt; 为什么没有认识到这样的差距? –&gt; 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——&gt; 开发流程出错在哪里了呢？ ——&gt; 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。<br>4.总结：<br>规范需要实现的功能 –&gt; 检查输入数据的类型 –&gt; 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –&gt; 输入数据检查通过后开始写功能 –&gt; 功能<br>中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –&gt; 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –&gt; 首先减少数据库操作次数，把查询上万次变成了查询一次 –&gt; 用空间换时间，在实现的过程中，用dict做映射 –&gt; 性能从30分钟变成了10S中，大大的优化了速度。 –&gt; 性能问题解决后，要考虑异常情况 –&gt; 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——&gt; 异常解决后，功能才算是完成了。<br>概括内容：<br>问题： 代码健壮性差。<br>反思： 开发流程有问题，没有规范的开发方法。<br>总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。<br>但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）<br>明天的计划<br>1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.<br>我的翻译<br>这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。<br>正确译文<br>这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。<br>当天完成的工作内容<br>1.api/relation_tree<br>当天的收获<br>1.问题: 如何快速理解sql代码及写sql<br>2.目标: 逻辑清晰的逐步完成复杂的sql<br>3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –&gt; 首先我没有把SQL格式化，SQL非常混乱难以阅读 –&gt; 用在线工具格式化后，SQL逻辑清晰 –&gt; 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –&gt; 伟哥纠正我SQL要从内层向外层读 –&gt; 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –&gt;<br>因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。<br>4.方法：遇到SQL代码 –&gt; formmater sql –&gt; 从内至外的逐层阅读代码 –&gt; 每一层阅读完，先核对数据的变化 –&gt; 从变化中，思考业务逻辑。<br>5.用总结的方法重新处理一遍今天遇到的问题：<br>原来的SQL:<br>select left(t2.published_at,7) month, count(<em>) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)&gt;=’2011-01’ group by left(t2.published_at,7)<br>Frommater后：<br>SELECT left(t2.published_at,7) MONTH,<br>                               count(</em>) AS value<br>FROM<br>  (SELECT d.asin AS parent_asin<br>   FROM<br>     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id<br>      FROM amazon_review_insight.amazon_amazonasin<br>      WHERE %s ) c<br>   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1<br>INNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin<br>WHERE left(t2.published_at,7)&gt;=’2011-01’<br>GROUP BY left(t2.published_at,7)<br>从内到外的阅读：<br>1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH&gt;=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。<br>明天的计划<br>1.在SQL里面嵌套一层Category的连接。<br>2.帮公司同事完成OBD的数据爬取。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Most CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.<br>我的译文<br>大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。<br>正确译文<br>大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。<br>当天完成的工作内容<br>1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。<br>当天的收获<br>1.总结的内容是： 如何用最短的时间找到靠谱的api？<br>2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –&gt; 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –&gt; 那么只能去网上寻找资源 –&gt; 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –&gt; 那么如何有效的从这些资源里，快速找到我所需要的呢？ –&gt; 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –&gt; 那么现在根据近期记录的搜索方案，整理一下技巧。<br>3.查找方法的总结：<br>先分析一下问题 –&gt; 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –&gt; 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –&gt; 重新跟伟哥确认一下需求或者问题 –&gt; 重复上述步骤 –&gt; 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –&gt; 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –&gt; 把轮子或者教程看明白后再开始动手写代码。<br>概括上述内容：<br>1.需求： fix Bug或者优化已有功能。<br>2.目标： 用最少的时间去找到合适的轮子/fix bug。<br>3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –&gt;  动手前先跟伟哥沟通好，确认方案有可行性再写代码。<br>明天的计划<br>1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。<br>2.熟悉patter api后，用到avatar上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.<br>I/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.<br>I/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。<br>当天完成的工作内容<br>1.x。<br>当天的收获（简要概括在后面）<br>1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。<br>问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？<br>我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）<br>上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。<br>反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –&gt; 说话没有把握重点，想描述细节，但是细节与问题无关 –&gt; 为什么没有用简单的语言说出重点 –&gt; 因为问题我还没有思考完，我就开始回答了 –&gt; 为什么问题不考虑完就要回答？ –&gt; 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –&gt; 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –&gt; 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –&gt; 为什么思维分散？ –&gt; 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –&gt; 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。<br>目标是什么：<br>要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。<br>方法：<br>完整的听完问题 –&gt; 在脑中把问题重复几遍 ——&gt; 如果对问题有不理解的地方，先问清楚 –&gt; 确保问题已经听明白了 –&gt; 思考问题的答案 –&gt; 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –&gt; 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –&gt; 如果答案与问题完全相关，再回答 –&gt; 如果思考偏了，跟对方请求一下再考虑一会。 –&gt; 回答的时候，在心中默念问题 –&gt; 只回答与问题有关的内容，无关的话不要说出来。 –&gt; 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。<br>实践总结的方法重新回答赵赵的问题：<br>1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。<br>2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。<br>3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。<br>4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。<br>简要概括：<br>问题：回答别人的提问时，回答冗余，并且逻辑混乱<br>方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。<br>目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。<br>明天的计划<br>1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Bald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.<br>A new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.<br>我的译文<br>研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。<br>来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。<br>正确译文<br>研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。<br>美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。<br>当天完成的工作内容<br>1.给avatar的后端服务器加了Ip的rate限制。<br>当天的收获<br>1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。<br>问题：眼界低，技术视野很窄。<br>反思：为什么同样是技术人员，别人聊的内容我完全不理解 –&gt; 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –&gt; 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –&gt;  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –&gt; 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –&gt; 惰性让我看到舒适区以外的陌生技术，就想着逃避 –&gt; 没有强迫自己去拓展技术栈<br>总结：<br>首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –&gt; 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –&gt; 碎片时间看github，周一到周五每天star至少一个项目 –&gt; 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）<br>翻译英文文档和读技术博客是为了补足基础知识 –&gt; 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –&gt; 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。<br>千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。<br>明天的计划<br>1.修改github上ratelimit api，使其更好的贴合avatar。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.<br>我的译文<br>在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。<br>正确译文<br>装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.add relation_tree api<br>2.update compare api<br>当天的收获<br>1.今天的总结是： 规范开发流程<br>2.问题： 写的relation_tree api，因为没有考虑上线后会出现的异常，导致提交的代码没有健壮性。<br>3.反思：<br>为什么写的代码没有健壮性？ –&gt; 因为只考虑了如何实现功能，没有考虑异常情况下功能的影响，开发前没有考虑极端情况 –&gt; 为什么只考虑实现功能但是不考虑异常情况和极端值呢？ –&gt; 因为没有考虑到功能脚本和线上真正可以使用的功能的差距 –&gt; 为什么没有认识到这样的差距? –&gt; 因为从一开始的开发流程就出现了错误，导致思考不到这样的差距 ——&gt; 开发流程出错在哪里了呢？ ——&gt; 对于开发功能之前，没有给需要实现的功能明确的保证，如输出的格式，输入的数据类型输入的值等等，没有这些明确规范功能的测试用例。<br>4.总结：<br>规范需要实现的功能 –&gt; 检查输入数据的类型 –&gt; 对输入的数据考虑极值情况，比如数值型，那么1和1.0是否影响功能结果要进行测试 –&gt; 输入数据检查通过后开始写功能 –&gt; 功能<br>中不仅要正常的实现，而且要考虑性能，比如APi是否可以接受以分钟为单位的实现 –&gt; 如果性能存在问题，那么这个问题是必须要解决的，这次relation_tree 因为多次对数据库的操作，导致实现时间是分钟为单位的 –&gt; 首先减少数据库操作次数，把查询上万次变成了查询一次 –&gt; 用空间换时间，在实现的过程中，用dict做映射 –&gt; 性能从30分钟变成了10S中，大大的优化了速度。 –&gt; 性能问题解决后，要考虑异常情况 –&gt; 程序在出错的过程中，在try里面使其恢复原有功能同时打印log日志便于修复，我在缓存中的Try里，取消从redis中读数数据，而是调函数得到数据。这样使得异常也可以返回正常数据（不过要消耗十秒钟的时间） ——&gt; 异常解决后，功能才算是完成了。<br>概括内容：<br>问题： 代码健壮性差。<br>反思： 开发流程有问题，没有规范的开发方法。<br>总结的方法： 从输入类型一直到输出结果，类型检查要明确，考虑性能问题，以及异常问题，极端情况，用测试用例来驱动开发。<br>但是我还是没有把方法中的对应步骤总结完善（还没操作过这个方法，细节上把握不太清楚），我打算周末尝试驱动测试开发一个实例后，再次总结这个问题（把细节总结好，实例和总结的连接我会贴在下次的daily report上）<br>明天的计划<br>1.写好开发功能前需要通过的步骤清单，周一贴在桌子上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>These I/O interfaces are fine for small computers, such as the microwave oven controller, but they suffer from poor performance in larger computer systems. In all but the smallest systems, it is not acceptable for the CPU to have to wait thousands of clock cycles for data from an I/O device. Many systems use interrupts so they can perform useful work while waiting for the much slower I/O devices.<br>我的翻译<br>这些I/O接口对小型计算机很适用，比如微博烤炉控制器，但是它们在更大一点的计算机上表现的很差。在所有系统中最小的系统里，它不被CPU接受,因为不得不等待上千次的时钟循环去从一个I/O设备中取数据。许多系统使用中断器，所以他们可以在等待慢得多的I/O设备时有效的工作。<br>正确译文<br>这些I/O接口对于小型的计算机而言已经很好了，比如说微波炉控制器，但是在大型的计算机系统中它们的性能则很差。在除最小系统以外的所有系统中，让CPU等待成千上万个时钟周期方从I/O设备中得到数据是不能接收的，为此，许多系统都使用了中断机制,以便CPU在等待慢得多的I/O设备时，可以执行其他有用的工作。<br>当天完成的工作内容<br>1.api/relation_tree<br>当天的收获<br>1.问题: 如何快速理解sql代码及写sql<br>2.目标: 逻辑清晰的逐步完成复杂的sql<br>3.反思：今天要在原有的SQL里再增加一层内连接，但是我一直不理解SQL的业务逻辑。 –&gt; 首先我没有把SQL格式化，SQL非常混乱难以阅读 –&gt; 用在线工具格式化后，SQL逻辑清晰 –&gt; 但是我仍然阅读存在问题，因为我读SQL是从前往后读 –&gt; 伟哥纠正我SQL要从内层向外层读 –&gt; 从内向外读后，逻辑清晰，很快可以明白SQL的意思，但是不理解业务逻辑的含义 –&gt;<br>因为业务逻辑不仅需要明白SQL的意思，还要对照表里，去明白每一次的连接后得到的数据。根据数据的对比去思考业务逻辑。<br>4.方法：遇到SQL代码 –&gt; formmater sql –&gt; 从内至外的逐层阅读代码 –&gt; 每一层阅读完，先核对数据的变化 –&gt; 从变化中，思考业务逻辑。<br>5.用总结的方法重新处理一遍今天遇到的问题：<br>原来的SQL:<br>select left(t2.published_at,7) month, count(<em>) as value from (select d.asin as parent_asin from (SELECT distinct coalesce(parent_asin_id, id) as parent_asin_id from amazon_review_insight.amazon_amazonasin WHERE %s ) c inner join amazon_review_insight.amazon_amazonasin d on c.parent_asin_id = d.id ) t1 inner join amazon_review_insight.amazon_amazonreview t2 on t1.parent_asin = t2.parent_asin where left(t2.published_at,7)&gt;=’2011-01’ group by left(t2.published_at,7)<br>Frommater后：<br>SELECT left(t2.published_at,7) MONTH,<br>                               count(</em>) AS value<br>FROM<br>  (SELECT d.asin AS parent_asin<br>   FROM<br>     (SELECT DISTINCT coalesce(parent_asin_id, id) AS parent_asin_id<br>      FROM amazon_review_insight.amazon_amazonasin<br>      WHERE %s ) c<br>   INNER JOIN amazon_review_insight.amazon_amazonasin d ON c.parent_asin_id = d.id) t1<br>INNER JOIN amazon_review_insight.amazon_amazonreview t2 ON t1.parent_asin = t2.parent_asin<br>WHERE left(t2.published_at,7)&gt;=’2011-01’<br>GROUP BY left(t2.published_at,7)<br>从内到外的阅读：<br>1.根据where的条件，得到parent_asin_id后同D表根据c.parent_asin_id = d.id做连接，select d.asin。此时对比一下得到的数据（parent_asin）和之前的数据（parent_asin_id），明白了这次的逻辑是为了取parent_asin。将得到的表命名t1，再次同amazon_amazonreview根据t1.parent_asin = t2.parent_asin做连接。再根据MONTH&gt;=’2011-01’的条件，对得到的数据按照月份分组后聚合。得到了月份和对应的value值。对比现在的数据（月份和对应的数量）和之前的数据（parent_asin），明白了业务逻辑是取parent_asin对应的月份和数量。<br>明天的计划<br>1.在SQL里面嵌套一层Category的连接。<br>2.帮公司同事完成OBD的数据爬取。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Most CPUs have a control input signal called READY (or something similar). Normally this input is high. When the CPU outputs the address of the I/O device and the correct control signals, enabling the tri-state buffers of the I/O device interface, the I/O device sets READY low. The CPU reads this signal and continues to output the same address and control signals, which cause the buffers to remain enabled. In the hard disk drive example, the drive rotates the disk and positions its read heads until it reads the desired data.<br>我的译文<br>大多数的CPU都有一个叫做READY（或者别的）的输入控制信号。通常这个输入是高，当CPU输出地址和正确的控制信号到I/O设备，I/O设备接口的三态缓冲使用的时候，I/O设备会设置READY为低。CPU读取这个信号然后继续去输出相同的地址和控制信号，这些会让缓冲保持能用。用硬盘驱动举例，驱动转动磁盘然后指向磁头的位置直到它可以读取应该被读取的数据。<br>正确译文<br>大多数CPU都有一个控制输入信号，叫做就绪信号（READY）（或其他意思相近的名称），通常它为高电平。当CPU输出某I/O设备的地址和正确的控制信号，促使I/O设备接口的三态缓冲器有效时，该I/O设备置READY信号为低电平。CPU读取这一信号，并且继续输出同样的地址信号和控制信号，使缓冲器保持有效。在硬盘驱动器的例子中，此时驱动器旋转磁头，并且定位读写头，直到读到想要要的数据为止。<br>当天完成的工作内容<br>1.avatar目前的tag_service的准确率和召回率不高，对其中存在的问题做了分析。根据网上提供的资料表示词形还原会比词干抽取（avatar的做法）效果更好。pattern的表现很差，目前在网上找了一些开源的pattern api打算跟项目中的作对比。<br>当天的收获<br>1.总结的内容是： 如何用最短的时间找到靠谱的api？<br>2.需求： 在工作中，对原有的功能进行优化或者fix bug的时候，希望用最短的时间来完成任务 –&gt; 如果自己去造轮子，目前我的能力连代码中未优化的轮子都造不出来 –&gt; 那么只能去网上寻找资源 –&gt; 网上的资源非常多，google，github，stackoverflow，技术博客 等等 –&gt; 那么如何有效的从这些资源里，快速找到我所需要的呢？ –&gt; 虽然遇到问题，用Google查找是Ok的。但是google出来的，有时候需要看很久的英文资料，而且看完了资料后发现所提供的工具并不合适我的要求 –&gt; 那么现在根据近期记录的搜索方案，整理一下技巧。<br>3.查找方法的总结：<br>先分析一下问题 –&gt; 1.如果现在是要fix bug，那么跳过Google,直接在stackoverflow上面查找。2.现在需要的是优化已有的功能，同样跳过google，直接在Github把功能描述出来，看看是不是已经存在可以满足需求的轮子了 –&gt; 如果上面两个问题都没有找到解决办法，其实不一定是目前没有可用的轮子，而是我对问题或者需求没有理解清楚 –&gt; 重新跟伟哥确认一下需求或者问题 –&gt; 重复上述步骤 –&gt; 如果已经找到了解决方案，那么先把方案跟伟哥确认一下可行性之后开始执行 –&gt; 如果没有解决方案，那么说明目前确实没有成熟的轮子合适需求，这时候开始Google，找解决问题的思路，了解完思路后绝对不要去手写代码，此时一定要把想到的思路去Github和技术博客中找轮子或者教程。 –&gt; 把轮子或者教程看明白后再开始动手写代码。<br>概括上述内容：<br>1.需求： fix Bug或者优化已有功能。<br>2.目标： 用最少的时间去找到合适的轮子/fix bug。<br>3.方法： 先分析问题，不同的问题，第一步尝试有区别。fix bug先stackoverflow，优化功能先去Github找轮子。 对细节上不懂得地方先Google。有了思路后可以去相关的技术博客里找教程（今天在coolshell里找到了一片文本挖掘的教程。） –&gt;  动手前先跟伟哥沟通好，确认方案有可行性再写代码。<br>明天的计划<br>1.用词形还原提取的Tag跟目前avatar的做对比，择优选择。<br>2.熟悉patter api后，用到avatar上。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>I/O devices are much slower than CPUs and memory. For this reason, they can have timing problems when interacting with the CPU. To illustrate this, consider what happens when a CPU wants to read data from a disk. It may take the disk drive several milliseconds to position its heads properly to read the desired value. In this time, the CPU could have read in invalid data and fetched, decoded, and executed thousands of instructions.<br>I/O设备比cpu和内存要慢很多。因为这个原因，它们和cpu相互作用的时候会有时间问题。为了阐明这个现象，思考一下当cpu想要从磁盘里读数据的时候会发生什么。它会用几毫秒的时间驱动到磁盘头的位置，去读取所希望的正确数据。这时候，cpu可能会无效的数据可能会被读取、抓取、解码或者执行上千次指令.<br>I/O设备比CPU和存储器慢得多。基于这个原因，当它们与CPU交互时，就可能存在时序上的问题。为了说明这一点，考虑当CPU想要从硬盘中读取数据时会发生的情况，这可能要消耗磁盘驱动器几个毫秒来正确的定位磁头，以便读取想要的数值，而在这段时间里，CPU可能已经读入了不正确的数据，并且读取、译解和执行了成千上万条指令。<br>当天完成的工作内容<br>1.x。<br>当天的收获（简要概括在后面）<br>1.今天总结的主题是：我在回答别人问题时1.急于回答而不是思考2.回答的答案不是最简洁的语言。<br>问题阐述： 今天赵赵问了我几个问题：1.这周的工作完成了哪些内容？2.ip check耗时多久？3.完成ip check中浪费了多久的时间？4.你有没有想过下次遇到这样的问题，如何去节约时间？<br>我的回答:1.完成了一些Bug的修复，具体的忘记了。记得是给ip做rate的限制，定制白名单，修复网上提供的api…..巴拉巴拉一大堆。2.ip check用了两天半的时间，其中因为修复一些问题和选择合适的api用了时间3.我昨天晚上思考了一下，我大概浪费了半天的时间。（具体怎么浪费的我没描述出来）。4.我下次遇到这样的问题，我又把遇到的问题描述了一遍 然后继续巴拉巴拉一大堆…..（后面赵赵不愿再听了，伟哥也在旁边提醒我问题先思考一下再说）<br>上面是今天回答问题的过程，接下来反思这个过程，并且重新回答一次。<br>反思： 为什么回答每一个问题，答案不仅冗余而且还不准确 –&gt; 说话没有把握重点，想描述细节，但是细节与问题无关 –&gt; 为什么没有用简单的语言说出重点 –&gt; 因为问题我还没有思考完，我就开始回答了 –&gt; 为什么问题不考虑完就要回答？ –&gt; 有一点思路我就想要回答，但是完整的思考过程还没有结束（回答第三个问题的时候，我一想到我昨晚有思考怎么解决，我就开始回答了，可是答完这一句，还没有回忆起来计划怎么去解决的。回答的时候就断档了） –&gt; 为什么有一点思路就想要回答，却不能听完整个问题，并且回答前把答案整理好再说出来？ –&gt; 思维太分散，问题是A,我在思考A的时候想要开始回答，可是回答A的时候又想到了B,我就开始想说B,说B的时候又想到了C,就这样一直循环下去，脑子里面思考的早已经不是A了，A的部分只思考了一点，没有完整思考，所以只回答了一点点。 –&gt; 为什么思维分散？ –&gt; 因为我不强迫自己只思考A,我想到什么我就说什么，思维不严谨 –&gt; 所以应该强迫思考完A再开始回答。只思考与A有关的，不要先考虑别的问题。对于与A无关的一律断舍离。<br>目标是什么：<br>要做到完整的听完问题后，把问题思考明白，然后再开始回答。不再发生跳逻辑，不再回答与问题无关的内容。<br>方法：<br>完整的听完问题 –&gt; 在脑中把问题重复几遍 ——&gt; 如果对问题有不理解的地方，先问清楚 –&gt; 确保问题已经听明白了 –&gt; 思考问题的答案 –&gt; 如果思考突然跳转到别的地方，立刻重复问自己问题是什么，确保思考的过程只与问题有关。但可以把跳转到的想法先放心里，但是不要去思考。 –&gt; 问题思考完后，不要先关心答案对不对，先把答案告诉自己，看看能不能与问题对上号 –&gt; 如果答案与问题完全相关，再回答 –&gt; 如果思考偏了，跟对方请求一下再考虑一会。 –&gt; 回答的时候，在心中默念问题 –&gt; 只回答与问题有关的内容，无关的话不要说出来。 –&gt; 等对方确认你的回答没有问题后，这次回答的过程算作结束，否则跟对方明确沟通中的问题出现在哪，继续重复上面过程。<br>实践总结的方法重新回答赵赵的问题：<br>1.这周的工作完成了哪些内容？ 回答: 修复了Avatar中，爬虫会将同一个任务多次重复的Bug。在爬虫模块中增加了清理占用空间的方法，清理已经被使用过的100多G数据。在后端做了Ip check功能。<br>2.ip check耗时多久？ 回答： 从周三下午开始到周五上午交付，耗时两个工作日。其中在完成这个功能时，别的部门同事委托我去爬取OBD数据，花费了数个小时。所以实际耗时一天半。<br>3.完成ip check中浪费了多久的时间？ 回答：我觉得有浪费近半天的时间，这半天的时间我去阅读了几个Api的源码想要优化实现ip check，但是实现Ip check只要看看范例，不需要阅读源码。<br>4.你有没有想过下次遇到这样的问题，如何去节约时间？ 回答：先把功能实现，优化应该在功能实现后去做而不是功能实现前。<br>简要概括：<br>问题：回答别人的提问时，回答冗余，并且逻辑混乱<br>方法：听完后问题，不明白的地方先沟通清楚，再开始思考，只思考与问题有关的内容，并且逻辑要是有明确因果关系，不能跳逻辑。问什么，答什么，不说问题无关内容。<br>目标：完整的听完别人问题后，能做到思考完再开始回答。回答时，只回答与问题相关内容。<br>明天的计划<br>1.最近了解了GFW的原理，打算用github上的项目，自己去实现翻墙。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Bald men are perceived to be more dominant, more athletic and better leaders, researchers have claimed.<br>A new study from information management lecturer Albert Mannes at the University of Pennsylvania’s Wharton School of Business suggests that while men with male-pattern baldness tend to view themselves as having poor self-esteem, those who take the pre-emptivestep of shaving a thinning head of hair improved their image.<br>我的译文<br>研究人员声称秃顶的男人被认为的更有统治力，更加健壮并且是更好的领导。<br>来自宾夕法尼亚的沃顿商学院的商人Albert Mannes有新的研究，表明当男性秃头的时候倾向于在意他们脆弱的自尊心，顶着光秃秃的头的能提高他们的想象力。<br>正确译文<br>研究人员称，人们普遍认为秃头男更具主导力、更健壮、领导能力更强。<br>美国宾夕法尼亚大学沃顿商学院的信息管理系讲师阿尔伯特 曼尼斯开展的一项新研究指出，尽管谢顶男子往往会因为脱发而感到自卑，但那些在头发掉光前就先行一步剃光头的男人形象则会有所改观。<br>当天完成的工作内容<br>1.给avatar的后端服务器加了Ip的rate限制。<br>当天的收获<br>1.今天晚上在公司听了饿了么开发人员的培训，主题是关于rust语言的，但这不是重点。重点是在过程中我觉得作为一个技术人员，却听不懂他和其他技术人员的谈话，这是一件令人沮丧的事情。<br>问题：眼界低，技术视野很窄。<br>反思：为什么同样是技术人员，别人聊的内容我完全不理解 –&gt; 1.聊得内容，我未曾听过。2.他们谈论的问题我没有考虑过 –&gt; 技术眼界很低（我观察到公司很多人github上是非常活跃的，而我却连github都用不熟练） –&gt;  明明知道Github，技术博客，源码，官方文档是很重要的，但是我在这上面下的功夫少之又少 –&gt; 平日对技术探索浅尝辄止，不愿走出舒适区(比如今天他们聊得泛型，这个概念一个星期前我在看技术博客的时候有看到，但是到今天我都没有去了解它) –&gt; 惰性让我看到舒适区以外的陌生技术，就想着逃避 –&gt; 没有强迫自己去拓展技术栈<br>总结：<br>首先不能相信自己的自制力（我是大懒蛋，我没有自制力） –&gt; 做可以被记录的事情，来让自己的技术扩展，但是平日的时间很紧凑，碎片时间比较多 –&gt; 碎片时间看github，周一到周五每天star至少一个项目 –&gt; 不要求自己去看源码，但是一定要给至少给一个项目star，为了多了解新技术或者有创意的idea。 （截止2017年7月20日我有50个star项目。）<br>翻译英文文档和读技术博客是为了补足基础知识 –&gt; 翻译文档已经每天写在daily report里，但是技术博客没有定义好记录方式（不记录，我就会偷懒） –&gt; 保持跟coolshell发布技术博客同步跟新， 他们写一篇技术博客，我当天就写一篇读后感发布到我的博客上（到时候我会把地址留在daily report的最后，不必帮我校正，我只是想督促自己），当然如果发布的是技术类的，那必须写，如果他们发布一篇鸡汤文，可以选择不写。<br>千万不要再相信自己的自制力，我已经让自己失望了N次。任何方法我都要有记录形式。<br>明天的计划<br>1.修改github上ratelimit api，使其更好的贴合avatar。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The load logic plays the role of the enable logic in the input device interface. When this logic receives the correct address and control signals, it asserts the LD signal of the register, causing it to read data from the system’s data bus. The output device can then read the data from the register at its leisure while the CPU performs other tasks.<br>我的译文<br>在输入设备接口中加载逻辑扮演着功能实现逻辑。当这个逻辑接受到正确地址和控制信号。它就会断言寄存器的LD信号。这是因为它从系统数据枢纽中读取信息。当CPU执行其他任务的时候，外部设备在其空闲的时间从寄存器中读取数据。<br>正确译文<br>装载逻辑发挥着输入设备接口中使能逻辑的作用。当此逻辑获得正确的地址信号和控制信号后，它发出寄存器的LD信号，促使它从系统数据总线上读取数据。然后输出设备可以在其空闲的时候从寄存器中读取该数据，同时CPU可以执行其他的任务</p>\n"},{"title":"2017-08-05 Report","date":"2017-08-05T07:27:45.000Z","_content":"当天完成的工作内容\n1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。\n当天的收获\n1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。\n反思一下：\n\n\n文档看不懂 –> 单词不理解 ——> 词汇量太少 –> 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –> 没有背单词的习惯。\n\n\n不能用英语表达问题 –> 除了半年一次的英语考试，平时没有用英语写作过 –> 平日缺少英文写作和表达的锻炼\n总结：\n1.因为对写作没有积极性 –> 所以不自己写作，去翻译英文文档 –> 每天翻译1段超过150个词的文档 –> 但我惰性很大，没有人督促肯定坚持不下来 –> 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） \n\n\n我只想背我不会的生词 –> 不打算买个词典一页一页开始背 –> 每天在使用有道词典的时候，查阅完单词的同时mark一下 –> 当天背当天查阅的单词 –> 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）\n以上两个方法与daily report保持同步。\n\n\n明天的计划\n1.把Ip限制的方案落实。\n提出疑问或寻求帮助\n无。\n今日翻译\nA variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.\n我的译文：\n这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。\n正确译文：\n该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。\n对于2017\n 07\n 17的daily report赵赵的回复。\n这个总结不合格。\n\n自己的问题，自己先问6次为什么（自己解答），然后再问别人。\n你现在还是抓不住重点。\n\n我描述你的问题是：问问题的时候描述太多\n反思的原因是：\n1. 抓不住重点\n2. 没有自己考虑周全\n\n那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。\n我上周已经告诉你了，先找到根本原因，在想action plan！\n我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！\n\n当天完成的工作内容\n1.写了xxx api\n2.在xxxx的函数里增加了xxxx的逻辑\n当天的收获\n1.对7月17提出的【如何去问问题】重新总结。\n问题\n：问问题时描述太多，太啰嗦。\n原因\n：\n\n\n提问时抓不住问题的重点 –> 提问之前，没有把问题的原因理解清楚 –> 急于寻找答案，未能静下心思考 –> 思维有惰性，希望答案可以不劳而获 –> 依赖他人，独立解决问题的能力差\n\n\n对问题考虑不全面 –>  对问题的解决方案有遗漏 –> 假设问题发生的情况时有遗漏 –> 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。\n\n\n总结\n：\n因为原因2中包含了原因1，所以先对原因2总结action plan。\n\n\n遇到问题 –> 立刻把问题写在纸上（不可只在脑中思考） –>  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –> 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –> 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –> 如果二叉树的叶子节点中已经存在问题发生的原因 –> 针对原因，思考问题的解决方案 –> 利用目前可用的所有工具（google，man，document）去找到对应的答案 –> 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （\n以上每一步的过程必须有记录，绝不可以只在脑中完成。\n）\n\n\n如果1中的办法未能找到正确的答案 –> 重复1并且每次结束后查阅记录信息 –> 如果连续6次的记录信息都一样 –> 表明一直被卡在了同一个地方 –> 此时才可以寻问他人 –> 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –> 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。\n\n\n明天的计划\n1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.fix了xxxxx中的重复任务和数据占用大量空间的问题。\n当天的收获\n1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。\n截止今日仍表现出来的问题：问问题时，\n描述的太冗余了\n，导致伟哥经常听完我的问题，第一句话就是：你在说什么。\n反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。\n总结：\n1.提问前先尝试\n独立解决\n这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。\n2.在提问时，\n明确问题\n，将自己\n目前做的尝试\n，已经\n收集到信息\n以及被\n卡住的原因\n告诉回答者。将问题变得\n简单\n，尽可能的将问题描述的简单易懂。\n明天的计划\n1.把xxxx中数据持久化部分的逻辑弄懂。\n提出疑问或寻求帮助\n对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。\n当天完成的工作内容\n1.给伟哥提供了几种解决【xxxx】的解决方案。\n当天的收获\n1.以下内容是当时整个问题的解决流程：\n在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。\n以下是反思部分：\n遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。\n以下是总结部分：\n遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。\n明天的计划\n1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.将基于xxxxx的xxx功能剥离出来单独实现。\n2.思考了两种实现【xxxxxxx】这个功能的方案。\n当天的收获\n1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！\n先来梳理一下scrum的四个核心理念：\n\n\n以团队为核心\n\n\n循环迭代交付\n\n\n定期复盘调整\n\n\n透明，暴露问题\n明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。\n\n\n通过今天的培训，我有几点感悟：\n\n\n我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。\n\n\n制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。\n\n\n及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。\n\n\n最后一点是我认为导致今天发生的几个问题的最主要的原因，\nPO职责的履行不到位\n，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。\n\n\n明天的计划\n1.思考【xxxx】的其余实现思路。\n2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-08-05.md","raw":"---\ntitle: 2017-08-05 Report\ndate: 2017-08-05 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。\n当天的收获\n1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。\n反思一下：\n\n\n文档看不懂 –> 单词不理解 ——> 词汇量太少 –> 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –> 没有背单词的习惯。\n\n\n不能用英语表达问题 –> 除了半年一次的英语考试，平时没有用英语写作过 –> 平日缺少英文写作和表达的锻炼\n总结：\n1.因为对写作没有积极性 –> 所以不自己写作，去翻译英文文档 –> 每天翻译1段超过150个词的文档 –> 但我惰性很大，没有人督促肯定坚持不下来 –> 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） \n\n\n我只想背我不会的生词 –> 不打算买个词典一页一页开始背 –> 每天在使用有道词典的时候，查阅完单词的同时mark一下 –> 当天背当天查阅的单词 –> 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）\n以上两个方法与daily report保持同步。\n\n\n明天的计划\n1.把Ip限制的方案落实。\n提出疑问或寻求帮助\n无。\n今日翻译\nA variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.\n我的译文：\n这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。\n正确译文：\n该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。\n对于2017\n 07\n 17的daily report赵赵的回复。\n这个总结不合格。\n\n自己的问题，自己先问6次为什么（自己解答），然后再问别人。\n你现在还是抓不住重点。\n\n我描述你的问题是：问问题的时候描述太多\n反思的原因是：\n1. 抓不住重点\n2. 没有自己考虑周全\n\n那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。\n我上周已经告诉你了，先找到根本原因，在想action plan！\n我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！\n\n当天完成的工作内容\n1.写了xxx api\n2.在xxxx的函数里增加了xxxx的逻辑\n当天的收获\n1.对7月17提出的【如何去问问题】重新总结。\n问题\n：问问题时描述太多，太啰嗦。\n原因\n：\n\n\n提问时抓不住问题的重点 –> 提问之前，没有把问题的原因理解清楚 –> 急于寻找答案，未能静下心思考 –> 思维有惰性，希望答案可以不劳而获 –> 依赖他人，独立解决问题的能力差\n\n\n对问题考虑不全面 –>  对问题的解决方案有遗漏 –> 假设问题发生的情况时有遗漏 –> 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。\n\n\n总结\n：\n因为原因2中包含了原因1，所以先对原因2总结action plan。\n\n\n遇到问题 –> 立刻把问题写在纸上（不可只在脑中思考） –>  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –> 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –> 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –> 如果二叉树的叶子节点中已经存在问题发生的原因 –> 针对原因，思考问题的解决方案 –> 利用目前可用的所有工具（google，man，document）去找到对应的答案 –> 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （\n以上每一步的过程必须有记录，绝不可以只在脑中完成。\n）\n\n\n如果1中的办法未能找到正确的答案 –> 重复1并且每次结束后查阅记录信息 –> 如果连续6次的记录信息都一样 –> 表明一直被卡在了同一个地方 –> 此时才可以寻问他人 –> 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –> 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。\n\n\n明天的计划\n1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.fix了xxxxx中的重复任务和数据占用大量空间的问题。\n当天的收获\n1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。\n截止今日仍表现出来的问题：问问题时，\n描述的太冗余了\n，导致伟哥经常听完我的问题，第一句话就是：你在说什么。\n反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。\n总结：\n1.提问前先尝试\n独立解决\n这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。\n2.在提问时，\n明确问题\n，将自己\n目前做的尝试\n，已经\n收集到信息\n以及被\n卡住的原因\n告诉回答者。将问题变得\n简单\n，尽可能的将问题描述的简单易懂。\n明天的计划\n1.把xxxx中数据持久化部分的逻辑弄懂。\n提出疑问或寻求帮助\n对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。\n当天完成的工作内容\n1.给伟哥提供了几种解决【xxxx】的解决方案。\n当天的收获\n1.以下内容是当时整个问题的解决流程：\n在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。\n以下是反思部分：\n遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。\n以下是总结部分：\n遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。\n明天的计划\n1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.将基于xxxxx的xxx功能剥离出来单独实现。\n2.思考了两种实现【xxxxxxx】这个功能的方案。\n当天的收获\n1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！\n先来梳理一下scrum的四个核心理念：\n\n\n以团队为核心\n\n\n循环迭代交付\n\n\n定期复盘调整\n\n\n透明，暴露问题\n明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。\n\n\n通过今天的培训，我有几点感悟：\n\n\n我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。\n\n\n制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。\n\n\n及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。\n\n\n最后一点是我认为导致今天发生的几个问题的最主要的原因，\nPO职责的履行不到位\n，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。\n\n\n明天的计划\n1.思考【xxxx】的其余实现思路。\n2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。\n提出疑问或寻求帮助\n无。","slug":"2017-08-05","published":1,"updated":"2017-11-04T09:51:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq3001flvtlor66h5a0","content":"<p>当天完成的工作内容<br>1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。<br>当天的收获<br>1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。<br>反思一下：</p>\n<p>文档看不懂 –&gt; 单词不理解 ——&gt; 词汇量太少 –&gt; 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –&gt; 没有背单词的习惯。</p>\n<p>不能用英语表达问题 –&gt; 除了半年一次的英语考试，平时没有用英语写作过 –&gt; 平日缺少英文写作和表达的锻炼<br>总结：<br>1.因为对写作没有积极性 –&gt; 所以不自己写作，去翻译英文文档 –&gt; 每天翻译1段超过150个词的文档 –&gt; 但我惰性很大，没有人督促肯定坚持不下来 –&gt; 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） </p>\n<p>我只想背我不会的生词 –&gt; 不打算买个词典一页一页开始背 –&gt; 每天在使用有道词典的时候，查阅完单词的同时mark一下 –&gt; 当天背当天查阅的单词 –&gt; 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）<br>以上两个方法与daily report保持同步。</p>\n<p>明天的计划<br>1.把Ip限制的方案落实。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>A variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.<br>我的译文：<br>这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。<br>正确译文：<br>该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。<br>对于2017<br> 07<br> 17的daily report赵赵的回复。<br>这个总结不合格。</p>\n<p>自己的问题，自己先问6次为什么（自己解答），然后再问别人。<br>你现在还是抓不住重点。</p>\n<p>我描述你的问题是：问问题的时候描述太多<br>反思的原因是：</p>\n<ol>\n<li>抓不住重点</li>\n<li>没有自己考虑周全</li>\n</ol>\n<p>那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。<br>我上周已经告诉你了，先找到根本原因，在想action plan！<br>我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！</p>\n<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxxx的函数里增加了xxxx的逻辑<br>当天的收获<br>1.对7月17提出的【如何去问问题】重新总结。<br>问题<br>：问问题时描述太多，太啰嗦。<br>原因<br>：</p>\n<p>提问时抓不住问题的重点 –&gt; 提问之前，没有把问题的原因理解清楚 –&gt; 急于寻找答案，未能静下心思考 –&gt; 思维有惰性，希望答案可以不劳而获 –&gt; 依赖他人，独立解决问题的能力差</p>\n<p>对问题考虑不全面 –&gt;  对问题的解决方案有遗漏 –&gt; 假设问题发生的情况时有遗漏 –&gt; 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。</p>\n<p>总结<br>：<br>因为原因2中包含了原因1，所以先对原因2总结action plan。</p>\n<p>遇到问题 –&gt; 立刻把问题写在纸上（不可只在脑中思考） –&gt;  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –&gt; 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –&gt; 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –&gt; 如果二叉树的叶子节点中已经存在问题发生的原因 –&gt; 针对原因，思考问题的解决方案 –&gt; 利用目前可用的所有工具（google，man，document）去找到对应的答案 –&gt; 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （<br>以上每一步的过程必须有记录，绝不可以只在脑中完成。<br>）</p>\n<p>如果1中的办法未能找到正确的答案 –&gt; 重复1并且每次结束后查阅记录信息 –&gt; 如果连续6次的记录信息都一样 –&gt; 表明一直被卡在了同一个地方 –&gt; 此时才可以寻问他人 –&gt; 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –&gt; 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。</p>\n<p>明天的计划<br>1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.fix了xxxxx中的重复任务和数据占用大量空间的问题。<br>当天的收获<br>1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。<br>截止今日仍表现出来的问题：问问题时，<br>描述的太冗余了<br>，导致伟哥经常听完我的问题，第一句话就是：你在说什么。<br>反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。<br>总结：<br>1.提问前先尝试<br>独立解决<br>这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。<br>2.在提问时，<br>明确问题<br>，将自己<br>目前做的尝试<br>，已经<br>收集到信息<br>以及被<br>卡住的原因<br>告诉回答者。将问题变得<br>简单<br>，尽可能的将问题描述的简单易懂。<br>明天的计划<br>1.把xxxx中数据持久化部分的逻辑弄懂。<br>提出疑问或寻求帮助<br>对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。<br>当天完成的工作内容<br>1.给伟哥提供了几种解决【xxxx】的解决方案。<br>当天的收获<br>1.以下内容是当时整个问题的解决流程：<br>在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。<br>以下是反思部分：<br>遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。<br>以下是总结部分：<br>遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。<br>明天的计划<br>1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.将基于xxxxx的xxx功能剥离出来单独实现。<br>2.思考了两种实现【xxxxxxx】这个功能的方案。<br>当天的收获<br>1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！<br>先来梳理一下scrum的四个核心理念：</p>\n<p>以团队为核心</p>\n<p>循环迭代交付</p>\n<p>定期复盘调整</p>\n<p>透明，暴露问题<br>明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。</p>\n<p>通过今天的培训，我有几点感悟：</p>\n<p>我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。</p>\n<p>制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。</p>\n<p>及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。</p>\n<p>最后一点是我认为导致今天发生的几个问题的最主要的原因，<br>PO职责的履行不到位<br>，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。</p>\n<p>明天的计划<br>1.思考【xxxx】的其余实现思路。<br>2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.筛选了一些反爬虫的API，找了可以实行的ip限制方案。<br>当天的收获<br>1.总结的问题： 英文能力弱，带来了很多的弊端，目前暴露出来的： 1.英文文档读起来费劲，但偏偏大部分优秀资源都没有中文版。2. 削弱了自己获取资源的能力，比如遇到问题想在stackoverflow求助一下，连问题都描述不了。<br>反思一下：</p>\n<p>文档看不懂 –&gt; 单词不理解 ——&gt; 词汇量太少 –&gt; 一年没有背单词了，每次在词典中查完生词也只是标记一下，没有复习过。 –&gt; 没有背单词的习惯。</p>\n<p>不能用英语表达问题 –&gt; 除了半年一次的英语考试，平时没有用英语写作过 –&gt; 平日缺少英文写作和表达的锻炼<br>总结：<br>1.因为对写作没有积极性 –&gt; 所以不自己写作，去翻译英文文档 –&gt; 每天翻译1段超过150个词的文档 –&gt; 但我惰性很大，没有人督促肯定坚持不下来 –&gt; 以后在daily report下写第五个点【今日翻译】，把今天翻译的原文和译文记录（不用帮我校正，只是为了强迫自己坚持下去） </p>\n<p>我只想背我不会的生词 –&gt; 不打算买个词典一页一页开始背 –&gt; 每天在使用有道词典的时候，查阅完单词的同时mark一下 –&gt; 当天背当天查阅的单词 –&gt; 保持每天生词本是清空的 （查多少个，背多少个，数目不固定）<br>以上两个方法与daily report保持同步。</p>\n<p>明天的计划<br>1.把Ip限制的方案落实。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>A variant of this design replaces the register with tri-state buffers. The same logic used to load the register is used to enable the tri-state buffers instead. Although this can work for some designs, the output device must read in data while the buffers are enabled. Once they are disabled, the outputs of the buffers are tri-stated and the data is no longer available to the output device.<br>我的译文：<br>这个多样的设计替代了tri-state缓冲的寄存器。同样的逻辑被用来加载寄存器是过去被用来替代tri-state缓冲的。即使这个能够工作于同样的设计，外部设备必须要在缓存能用的时候可以读书数据。一旦它们失效，输出到缓冲会tri-stated而且数据不在对外部设备可用。<br>正确译文：<br>该设计也可以用三态缓冲器代替寄存器。装载寄存器的逻辑同样用于使能三态缓冲器。虽然对于某些设计这是可行的，但是输出设备必须在缓冲器有效时读入数据。一旦缓冲器被禁止，其输出就是三态，该数据也就不再能够供输出设备使用。<br>对于2017<br> 07<br> 17的daily report赵赵的回复。<br>这个总结不合格。</p>\n<p>自己的问题，自己先问6次为什么（自己解答），然后再问别人。<br>你现在还是抓不住重点。</p>\n<p>我描述你的问题是：问问题的时候描述太多<br>反思的原因是：</p>\n<ol>\n<li>抓不住重点</li>\n<li>没有自己考虑周全</li>\n</ol>\n<p>那上面两个问题，分别的原因又是什么？ 自己回答之后，再问原因。<br>我上周已经告诉你了，先找到根本原因，在想action plan！<br>我告诉你N遍的方法，也带着你做过N遍了，你不照着实施，现在还要问我要方法？！</p>\n<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxxx的函数里增加了xxxx的逻辑<br>当天的收获<br>1.对7月17提出的【如何去问问题】重新总结。<br>问题<br>：问问题时描述太多，太啰嗦。<br>原因<br>：</p>\n<p>提问时抓不住问题的重点 –&gt; 提问之前，没有把问题的原因理解清楚 –&gt; 急于寻找答案，未能静下心思考 –&gt; 思维有惰性，希望答案可以不劳而获 –&gt; 依赖他人，独立解决问题的能力差</p>\n<p>对问题考虑不全面 –&gt;  对问题的解决方案有遗漏 –&gt; 假设问题发生的情况时有遗漏 –&gt; 解决问题的方法不当，即没有用正确的方法在分析问题时保证尽可能完整清晰。</p>\n<p>总结<br>：<br>因为原因2中包含了原因1，所以先对原因2总结action plan。</p>\n<p>遇到问题 –&gt; 立刻把问题写在纸上（不可只在脑中思考） –&gt;  把问题用画二叉树的方式，把可能导致的原因逐层开始画出来 –&gt; 对上一步中画完的二叉树，用逻辑推理一遍，确定问题发生的原因已经出现在某个叶子节点上 –&gt; 如果没有任何叶子节点可以推断为导致问题发生的原因，那么问题的考虑必定有遗漏，继续思考或者此时寻求他人建议，并且将完成的二叉树给回答者看，让回答者尽快明确被卡住的原因。 –&gt; 如果二叉树的叶子节点中已经存在问题发生的原因 –&gt; 针对原因，思考问题的解决方案 –&gt; 利用目前可用的所有工具（google，man，document）去找到对应的答案 –&gt; 直到所有答案都被尝试或者找到了正确解决问题的答案为止，否则记录每一个答案不正确的原因，留作之后寻问他人时提供【目前已知的信息】。 （<br>以上每一步的过程必须有记录，绝不可以只在脑中完成。<br>）</p>\n<p>如果1中的办法未能找到正确的答案 –&gt; 重复1并且每次结束后查阅记录信息 –&gt; 如果连续6次的记录信息都一样 –&gt; 表明一直被卡在了同一个地方 –&gt; 此时才可以寻问他人 –&gt; 如果重复1后每次的记录过程不一样，那么表明每次都有新的进展 –&gt; 应该继续静下心重复1直到问题解决或者6次的记录信息都相同，再寻问他人。</p>\n<p>明天的计划<br>1.熟悉xxxx中xxxxx部分的架构，xxxxx，增加反爬虫机制。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.fix了xxxxx中的重复任务和数据占用大量空间的问题。<br>当天的收获<br>1.今天总结的内容是在入职xxxxx前，赵赵就多次提醒我注意的问题–如何去问问题。<br>截止今日仍表现出来的问题：问问题时，<br>描述的太冗余了<br>，导致伟哥经常听完我的问题，第一句话就是：你在说什么。<br>反思：1.描述的冗余是因为我总是想把所有的细节都描述清楚，担心会遗漏某个细节，但事实反应出来的是描述的太多会让回答者找不到问题的重心，反而不利于沟通。2.问问题前没有将问题考虑详细，或者尽可能的先尝试独立解决后再去提问。有时候问了一个问题，伟哥立马反问我一句这个问题的原因是什么，我却答不上来。<br>总结：<br>1.提问前先尝试<br>独立解决<br>这个问题，如果是技术上的那么应该google/或者将相关文档阅读一遍后再去提问，如果是方向选择上的那么应该及时向伟哥寻求建议。<br>2.在提问时，<br>明确问题<br>，将自己<br>目前做的尝试<br>，已经<br>收集到信息<br>以及被<br>卡住的原因<br>告诉回答者。将问题变得<br>简单<br>，尽可能的将问题描述的简单易懂。<br>明天的计划<br>1.把xxxx中数据持久化部分的逻辑弄懂。<br>提出疑问或寻求帮助<br>对于我今天总结出来的提问方式（针对于我目前暴露出来的问题），我参考了赵赵之前发给我的资料。但总结不对之处或者有遗漏的地方，希望赵赵与伟哥不吝赐教。<br>当天完成的工作内容<br>1.给伟哥提供了几种解决【xxxx】的解决方案。<br>当天的收获<br>1.以下内容是当时整个问题的解决流程：<br>在思考【xxxxx】的解决方案的时候，我先在纸上写了一些方案发给伟哥，伟哥告诉我不要先急于寻找解决办法，先理解问题。果然我把方案按照逻辑理一遍后发现这些方案连问题的切入点都不对，没有一点意义。之后开始按照伟哥的建议先明白问题的发生原因。因为一开始把调度器也理解为队列，所以在阅读代码上逻辑总是有问题。又跟伟哥请教后，才明白只有一个队列，正确的读通代码后，理解了问题的原因。之后我开始明确目标：解决什么问题，问题怎么解决，有哪些可行方案，每种方案解决的核心是什么。我把这些要求都写在了纸上后开始思考思路，根据导致问题发生的两种情况，我分别写出了对应的方案，发给伟哥（不过伟哥在忙高创会），我接着把方案种的逻辑，替换目前代码中的逻辑，我发现目前代码中的逻辑有一些小问题，但是这不是导致问题xxxxxxxxx，而这里才是导致问题的主要原因。<br>以下是反思部分：<br>遇到问题，不要急于解决，要先明白为什么会有这个问题。不能明确问题的原因，不能定位问题的位置，不能定义好解决的目标，跳过这些阶段所做的思考和行动都是无用功。最后还是不能解决，还是要求助伟哥，这样解决问题的方法太失败了。<br>以下是总结部分：<br>遇到【xxxxx】 –》读一遍代码，理清代码逻辑 –》 知道xxxxx的， 用来对xxxx积存的任务做释放 –》 如果上一步中，代码逻辑不够清晰或者读不通，及时跟伟哥请教 –》 理清了代码逻辑后，拿出笔和纸，用mece把现在出现的问题分析一下 –》 worker执行的队列中有大量重复内容 –》 提出【传送的内容大量重复，没有逻辑对是否重复传送做检查】的假设 –》 验证假设 –》 在代码中加检查是否重复的逻辑 –》 如果检查内容是重复的则不发送，不重复才发送 –》 逻辑增加的过程中，发现代码已经有了检查逻辑，但是检查逻辑中存在bug，会导致仍然将重复内容发送 –》 把解决的方案交付给伟哥，让伟哥判断其是否有实践价值（伟哥让我先做到这一步与他沟通后再继续）。<br>明天的计划<br>1.等明天xxxx结束后再于伟哥进一步沟通，确认方案是否可行。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.将基于xxxxx的xxx功能剥离出来单独实现。<br>2.思考了两种实现【xxxxxxx】这个功能的方案。<br>当天的收获<br>1.今天最大的收获就是参加了Jiachen的scrum培训！感觉太棒了！！<br>先来梳理一下scrum的四个核心理念：</p>\n<p>以团队为核心</p>\n<p>循环迭代交付</p>\n<p>定期复盘调整</p>\n<p>透明，暴露问题<br>明确了这四个理念和sprint的细节后，jiachen让我们开展了两个多小时的实践（超时了半个小时）。在一位小哥毛遂自荐成为了PO后，我们【暴暴队】配置就Ok了。第一轮的sprint，大家很混乱，不知道各自应该做什么，比较明显的问题就是PO在给成员介绍Backlogs的时候，没有介绍需要实现的目标和产出形式，只是一味的解释Backlogs。第二轮Sprint的过程中，大家吸取了第一轮的经验，对于每个Backlogs先明确产出，不过这个环节又太过于深挖细节，导致大量时间被消耗在了细节上，不仅如此，当大家开始领取Backlogs去TODO的时候，发现还有成员没有分配到任务！资源的浪费！虽然前面两轮过程很曲折，不过好在大家在review中及时发现错误，在第三轮中，在指定的时间内完成了任务。</p>\n<p>通过今天的培训，我有几点感悟：</p>\n<p>我认为在没有明确的目标和实现需求下的讨论，大部分的都是无收益的。</p>\n<p>制定的目标要考虑当前资源和交付时间。事实上，完成讨论中出现的细节问题，那么就不可能按时交付，这样深挖细节反而背离了讨论的本质。讨论应该是为了更简单有效的解决问题，而不是将问题变得越来越复杂，导致大家最后都认为无法实现。</p>\n<p>及时的review就是及时的止损，将错误最快的解决，沿着正确的方向进行到底。</p>\n<p>最后一点是我认为导致今天发生的几个问题的最主要的原因，<br>PO职责的履行不到位<br>，PO在团队中的作用真的非常非常重要！PO职责的不到位会让团队变得非常混乱，大家的方向不能得到统一，那么还谈什么效率呢？当然今天的PO是随机选的，大家之前都没有经验，不过也正因为如此，才将这一问题暴露的特别明显。</p>\n<p>明天的计划<br>1.思考【xxxx】的其余实现思路。<br>2.思考有没有办法解决xxxxx系统中，每xxxxx秒进行一次xxxx带来的弊端。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-08-06 Report","date":"2017-08-06T07:27:45.000Z","_content":"当天完成的工作内容\n1.写了xxx api\n2.在xxx中修改了xx方法。\n当天的收获\n1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。\n可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的\n，遇到问题后先要用MECE分析一遍，再开始执行。\n明天的计划\n1.继续熟悉xxxxxx的架构。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.写了一个xxxxxapi。\n当天的收获\n1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。\n2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。\n明天的计划\n1.继续熟悉avatar的架构。\n提出疑问或寻求帮助\n无。\n今天感觉好疲惫，daily report没有用心写了QAQ\n\n当天完成的工作内容\n1.修复了xxxx前端和后端的几个小bug。\n当天的收获\n1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。\n明天的计划\n1.继续熟悉avatar数据处理部分的逻辑。\n提出疑问或寻求帮助\n无。\n\n\ntitle: 《教父》摘录\n\n\ndate: 2017-06-10 00:11:12\n\n\ntags:书中的一些笔记\n\n\n他已经学会从不出言威胁，唐教会了他这一点，但卡洛完全明白了他的意思：他离死只差半步。 \n\n\n就在这时，唐· 柯里昂发表了将被长久纪念的演说，巩固了他在众人中最具远见的领袖地位，演说充满逻辑常理，发自肺腑，切中要害。他在演说中创造了一个短语，日后像丘吉尔的“ 铁幕” 一样变得人尽皆知，但到十年后才进入公众视线。他第一次起身对委员会说话。他个子不高，因为“ 病况” 有点消瘦，六十岁的年龄终究显出了几分老态，但无疑已经恢复了过去的全部力量，仍旧拥有过去的所有智慧。“我们如果失去理性，那算是什么样的人啊，” 他说，“ 没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。重新挑起所有争端，诉诸暴力和混战，能够满足我的什么目标呢？我的儿子死了，这是不幸，我必须承受，不能让我周围的世界随我一同受苦。因此，我今天说，我以名誉发誓，我不会寻求复仇，不会追查往事的前因后果。我将胸怀坦荡离开这里。“有一点我想说的是，我们必须看顾自己的利益。我们这些人都拒绝当傻瓜，拒绝当傀儡，被高处的人扯着线蹦蹦跳跳。我们在这个国家运气不错。我们的大部分子女已经过上了更好的生活。你们有些人的儿子是教授、科学家、音乐家—— 真是走运。你们的孙子也许会成为新的首领。我们谁都不希望见到儿孙走上我们的老路，那样过日子太艰难了。他们可以和其他人一样，我们的勇气赢来了他们的地位和安稳。我已经有了孙子，希望他们的孩子有朝一日能成为—— 谁知道呢？—— 州长？总统？在美国一切皆有可能。可是，我们必须跟着时代向前走。刀枪刺杀的年月已经过去。我们要像商人一样狡猾，从商的钱更多，对我们的儿孙更好。“至于我们的行为，我们不需要对那些炮筒子、那些首领负责，他们擅自决定我们该怎么处理我们的生命，他们宣战，希望我们用血肉保护他们的战果。我们凭什么为了保护他人的利益而伤害自己？而我们看顾我们自己的利益，他们凭什么插手？这是我们的事业12。” 唐· 柯里昂说，“ 这是我们自己的事业。我们管理自己的世界，因为这就是我们的世界，我们的事业。我们必须紧密团结，抵抗外来的干涉。否则他们就会给我们套上鼻环，就像他们已经给美国的另外几百万那不勒斯人和意大利人套上了鼻环一样。“为了这个原因，我愿意为儿子报仇，这是为了大家的利益。我现在发誓，只要我还负责指挥家族的行动，若是没有正当理由和遇到最激烈的挑衅，就连一个指头也不会举起来反对在座各位。我愿意为了共同利益牺牲我的商业利益。我发誓保证，以名誉保证，你们都清楚我从没有违背过誓言和名誉。“不过，我也有个自私的目的。因为受到索洛佐和那位警长的凶杀指控，我最小的儿子不得不逃跑。我必须安排他安全回国，洗清污名。这是我个人的事情，我会自己做些安排。也许我必须找到真凶，或者向政府证明他的无辜，也许证人和线人会撤回他们的谎言。可是，我还是要说，这是我个人的事情，我相信我能把我的儿子带回家。“但是，有句话我得说在前头。我是个迷信的人，这个毛病多么可笑，但我不得不说，要是什么倒霉的变故落在我的小儿子头上，要是某个警察不小心开枪打死他，要是他在牢房里上吊自杀，要是什么新证人冒出来证明他有罪，那迷信就会让我觉得这是因为在座有人还对我心怀恶意。再进一步说，假如我的儿子被雷劈了，我都会怪罪在座的某些人。要是他乘的飞机坠海，乘的船只沉入滚滚波涛，他得上致命的热病，汽车被火车撞了，迷信同样会让我归咎于在座某些人的恶意。各位先生，这种恶意，这种厄运，我可永远不会原谅。但除此之外，我愿意拿我孙子辈的灵魂起誓，我绝对不会打破我们缔结的和平。说到底，我们毕竟比那些双手沾满无数人类鲜血的领袖要好，不是吗？” 说完这些，唐· 柯里昂从他的位置顺着会议桌走向唐· 塔塔利亚的座位。塔塔利亚起身迎接他，两人拥抱，彼此亲吻面颊。房间里的其他唐鼓掌，见到谁都使劲握手，祝贺唐· 柯里昂和唐· 塔塔利亚新建立的友谊。这恐怕不是全世界最美好的友谊，他们不会互送圣诞礼物，但他们也不会彼此仇杀。在他们的世界里，这样的友谊就足够了，需要的也只是这样的友谊。\n\n\n唉，老天应该允许每个人一辈子犯一次傻。\n\n\n女人和孩子能够承担粗心大意的后果，男人却不行。\n\n\n他的手底下是个活生生的器官，活生生的器官需要另外一个活生生的器官。\n\n\n他第一次理解了意大利男人那闻名遐迩的嫉妒。此时此刻，要是有谁敢碰一下这女孩，妄图宣称拥有她，从他手里夺走她，他就会毫不犹豫杀死对方。他想占有她，就像吝啬鬼想占有金币那样疯狂，就像小佃农想拥有一片土地那样饥渴，想把她锁在房间里，囚禁她，只有他一个人能碰。\n\n\n让朋友低估你的优点，让敌人高估你的缺点。\n\n\n履行职责的人能获得恰当的奖赏。\n\n\n你对你所爱的人不能随便说‘不’字，也不能常常说，这就是诀窍。当你说‘不’字时，你得把‘不’字说得听上去就像‘是’字一样悦耳。另一个办法就是你得设法让他们说‘不’字。你得耐心，还得不怕麻烦。不过，我是个老朽，你是新的时髦的一代，你不必听我这老一套。” 这就是说话的艺术，如同上面，你要跟他讲道理，让他无法拒绝，我想我的生命中缺少这个勇气，我不是很愿意违背朋友的愿望，但是有时却还是受到了伤害，我一直在学习如何说不，人善被人欺，所以我一直也在不断学，学会说，学会做人，我希望能把身边所谓我认为应该学的品质学会，那么那时，我也可以大声说不，这也是小说最能打动我的话，但我很早之前以前明白了他的道理，只是，我没在履行。\n\n\n伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。\n\n\n今天做了什么\n\n\n写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。\n\n\n今天学到了什么\n\n\n今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我\n想当然\n的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行\nDouble check\n也使得问题迟迟没有被发现。所以，以后写代码\n不能想当然\n，只有\n通过Double check\n的逻辑，才是可以开始实现的逻辑。\n\n\nmac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。\n\n\n同样的错误不要犯两次。\n\n\n明天的计划\n1.继续找车型数据库。\n2.利用休息时间把mac上工作环境配置完善。\n3.尽力完成好mentor的每一个要求。","source":"_posts/2017-08-06.md","raw":"---\ntitle: 2017-08-06 Report\ndate: 2017-08-06 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.写了xxx api\n2.在xxx中修改了xx方法。\n当天的收获\n1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。\n可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的\n，遇到问题后先要用MECE分析一遍，再开始执行。\n明天的计划\n1.继续熟悉xxxxxx的架构。\n提出疑问或寻求帮助\n无。\n当天完成的工作内容\n1.写了一个xxxxxapi。\n当天的收获\n1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。\n2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。\n明天的计划\n1.继续熟悉avatar的架构。\n提出疑问或寻求帮助\n无。\n今天感觉好疲惫，daily report没有用心写了QAQ\n\n当天完成的工作内容\n1.修复了xxxx前端和后端的几个小bug。\n当天的收获\n1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。\n明天的计划\n1.继续熟悉avatar数据处理部分的逻辑。\n提出疑问或寻求帮助\n无。\n\n\ntitle: 《教父》摘录\n\n\ndate: 2017-06-10 00:11:12\n\n\ntags:书中的一些笔记\n\n\n他已经学会从不出言威胁，唐教会了他这一点，但卡洛完全明白了他的意思：他离死只差半步。 \n\n\n就在这时，唐· 柯里昂发表了将被长久纪念的演说，巩固了他在众人中最具远见的领袖地位，演说充满逻辑常理，发自肺腑，切中要害。他在演说中创造了一个短语，日后像丘吉尔的“ 铁幕” 一样变得人尽皆知，但到十年后才进入公众视线。他第一次起身对委员会说话。他个子不高，因为“ 病况” 有点消瘦，六十岁的年龄终究显出了几分老态，但无疑已经恢复了过去的全部力量，仍旧拥有过去的所有智慧。“我们如果失去理性，那算是什么样的人啊，” 他说，“ 没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。重新挑起所有争端，诉诸暴力和混战，能够满足我的什么目标呢？我的儿子死了，这是不幸，我必须承受，不能让我周围的世界随我一同受苦。因此，我今天说，我以名誉发誓，我不会寻求复仇，不会追查往事的前因后果。我将胸怀坦荡离开这里。“有一点我想说的是，我们必须看顾自己的利益。我们这些人都拒绝当傻瓜，拒绝当傀儡，被高处的人扯着线蹦蹦跳跳。我们在这个国家运气不错。我们的大部分子女已经过上了更好的生活。你们有些人的儿子是教授、科学家、音乐家—— 真是走运。你们的孙子也许会成为新的首领。我们谁都不希望见到儿孙走上我们的老路，那样过日子太艰难了。他们可以和其他人一样，我们的勇气赢来了他们的地位和安稳。我已经有了孙子，希望他们的孩子有朝一日能成为—— 谁知道呢？—— 州长？总统？在美国一切皆有可能。可是，我们必须跟着时代向前走。刀枪刺杀的年月已经过去。我们要像商人一样狡猾，从商的钱更多，对我们的儿孙更好。“至于我们的行为，我们不需要对那些炮筒子、那些首领负责，他们擅自决定我们该怎么处理我们的生命，他们宣战，希望我们用血肉保护他们的战果。我们凭什么为了保护他人的利益而伤害自己？而我们看顾我们自己的利益，他们凭什么插手？这是我们的事业12。” 唐· 柯里昂说，“ 这是我们自己的事业。我们管理自己的世界，因为这就是我们的世界，我们的事业。我们必须紧密团结，抵抗外来的干涉。否则他们就会给我们套上鼻环，就像他们已经给美国的另外几百万那不勒斯人和意大利人套上了鼻环一样。“为了这个原因，我愿意为儿子报仇，这是为了大家的利益。我现在发誓，只要我还负责指挥家族的行动，若是没有正当理由和遇到最激烈的挑衅，就连一个指头也不会举起来反对在座各位。我愿意为了共同利益牺牲我的商业利益。我发誓保证，以名誉保证，你们都清楚我从没有违背过誓言和名誉。“不过，我也有个自私的目的。因为受到索洛佐和那位警长的凶杀指控，我最小的儿子不得不逃跑。我必须安排他安全回国，洗清污名。这是我个人的事情，我会自己做些安排。也许我必须找到真凶，或者向政府证明他的无辜，也许证人和线人会撤回他们的谎言。可是，我还是要说，这是我个人的事情，我相信我能把我的儿子带回家。“但是，有句话我得说在前头。我是个迷信的人，这个毛病多么可笑，但我不得不说，要是什么倒霉的变故落在我的小儿子头上，要是某个警察不小心开枪打死他，要是他在牢房里上吊自杀，要是什么新证人冒出来证明他有罪，那迷信就会让我觉得这是因为在座有人还对我心怀恶意。再进一步说，假如我的儿子被雷劈了，我都会怪罪在座的某些人。要是他乘的飞机坠海，乘的船只沉入滚滚波涛，他得上致命的热病，汽车被火车撞了，迷信同样会让我归咎于在座某些人的恶意。各位先生，这种恶意，这种厄运，我可永远不会原谅。但除此之外，我愿意拿我孙子辈的灵魂起誓，我绝对不会打破我们缔结的和平。说到底，我们毕竟比那些双手沾满无数人类鲜血的领袖要好，不是吗？” 说完这些，唐· 柯里昂从他的位置顺着会议桌走向唐· 塔塔利亚的座位。塔塔利亚起身迎接他，两人拥抱，彼此亲吻面颊。房间里的其他唐鼓掌，见到谁都使劲握手，祝贺唐· 柯里昂和唐· 塔塔利亚新建立的友谊。这恐怕不是全世界最美好的友谊，他们不会互送圣诞礼物，但他们也不会彼此仇杀。在他们的世界里，这样的友谊就足够了，需要的也只是这样的友谊。\n\n\n唉，老天应该允许每个人一辈子犯一次傻。\n\n\n女人和孩子能够承担粗心大意的后果，男人却不行。\n\n\n他的手底下是个活生生的器官，活生生的器官需要另外一个活生生的器官。\n\n\n他第一次理解了意大利男人那闻名遐迩的嫉妒。此时此刻，要是有谁敢碰一下这女孩，妄图宣称拥有她，从他手里夺走她，他就会毫不犹豫杀死对方。他想占有她，就像吝啬鬼想占有金币那样疯狂，就像小佃农想拥有一片土地那样饥渴，想把她锁在房间里，囚禁她，只有他一个人能碰。\n\n\n让朋友低估你的优点，让敌人高估你的缺点。\n\n\n履行职责的人能获得恰当的奖赏。\n\n\n你对你所爱的人不能随便说‘不’字，也不能常常说，这就是诀窍。当你说‘不’字时，你得把‘不’字说得听上去就像‘是’字一样悦耳。另一个办法就是你得设法让他们说‘不’字。你得耐心，还得不怕麻烦。不过，我是个老朽，你是新的时髦的一代，你不必听我这老一套。” 这就是说话的艺术，如同上面，你要跟他讲道理，让他无法拒绝，我想我的生命中缺少这个勇气，我不是很愿意违背朋友的愿望，但是有时却还是受到了伤害，我一直在学习如何说不，人善被人欺，所以我一直也在不断学，学会说，学会做人，我希望能把身边所谓我认为应该学的品质学会，那么那时，我也可以大声说不，这也是小说最能打动我的话，但我很早之前以前明白了他的道理，只是，我没在履行。\n\n\n伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。\n\n\n今天做了什么\n\n\n写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。\n\n\n今天学到了什么\n\n\n今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我\n想当然\n的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行\nDouble check\n也使得问题迟迟没有被发现。所以，以后写代码\n不能想当然\n，只有\n通过Double check\n的逻辑，才是可以开始实现的逻辑。\n\n\nmac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。\n\n\n同样的错误不要犯两次。\n\n\n明天的计划\n1.继续找车型数据库。\n2.利用休息时间把mac上工作环境配置完善。\n3.尽力完成好mentor的每一个要求。","slug":"2017-08-06","published":1,"updated":"2017-11-04T09:51:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq5001hlvtlwi9asgoe","content":"<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxx中修改了xx方法。<br>当天的收获<br>1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。<br>可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的<br>，遇到问题后先要用MECE分析一遍，再开始执行。<br>明天的计划<br>1.继续熟悉xxxxxx的架构。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.写了一个xxxxxapi。<br>当天的收获<br>1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。<br>2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。<br>明天的计划<br>1.继续熟悉avatar的架构。<br>提出疑问或寻求帮助<br>无。<br>今天感觉好疲惫，daily report没有用心写了QAQ</p>\n<p>当天完成的工作内容<br>1.修复了xxxx前端和后端的几个小bug。<br>当天的收获<br>1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。<br>明天的计划<br>1.继续熟悉avatar数据处理部分的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n<p>title: 《教父》摘录</p>\n<p>date: 2017-06-10 00:11:12</p>\n<p>tags:书中的一些笔记</p>\n<p>他已经学会从不出言威胁，唐教会了他这一点，但卡洛完全明白了他的意思：他离死只差半步。 </p>\n<p>就在这时，唐· 柯里昂发表了将被长久纪念的演说，巩固了他在众人中最具远见的领袖地位，演说充满逻辑常理，发自肺腑，切中要害。他在演说中创造了一个短语，日后像丘吉尔的“ 铁幕” 一样变得人尽皆知，但到十年后才进入公众视线。他第一次起身对委员会说话。他个子不高，因为“ 病况” 有点消瘦，六十岁的年龄终究显出了几分老态，但无疑已经恢复了过去的全部力量，仍旧拥有过去的所有智慧。“我们如果失去理性，那算是什么样的人啊，” 他说，“ 没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。重新挑起所有争端，诉诸暴力和混战，能够满足我的什么目标呢？我的儿子死了，这是不幸，我必须承受，不能让我周围的世界随我一同受苦。因此，我今天说，我以名誉发誓，我不会寻求复仇，不会追查往事的前因后果。我将胸怀坦荡离开这里。“有一点我想说的是，我们必须看顾自己的利益。我们这些人都拒绝当傻瓜，拒绝当傀儡，被高处的人扯着线蹦蹦跳跳。我们在这个国家运气不错。我们的大部分子女已经过上了更好的生活。你们有些人的儿子是教授、科学家、音乐家—— 真是走运。你们的孙子也许会成为新的首领。我们谁都不希望见到儿孙走上我们的老路，那样过日子太艰难了。他们可以和其他人一样，我们的勇气赢来了他们的地位和安稳。我已经有了孙子，希望他们的孩子有朝一日能成为—— 谁知道呢？—— 州长？总统？在美国一切皆有可能。可是，我们必须跟着时代向前走。刀枪刺杀的年月已经过去。我们要像商人一样狡猾，从商的钱更多，对我们的儿孙更好。“至于我们的行为，我们不需要对那些炮筒子、那些首领负责，他们擅自决定我们该怎么处理我们的生命，他们宣战，希望我们用血肉保护他们的战果。我们凭什么为了保护他人的利益而伤害自己？而我们看顾我们自己的利益，他们凭什么插手？这是我们的事业12。” 唐· 柯里昂说，“ 这是我们自己的事业。我们管理自己的世界，因为这就是我们的世界，我们的事业。我们必须紧密团结，抵抗外来的干涉。否则他们就会给我们套上鼻环，就像他们已经给美国的另外几百万那不勒斯人和意大利人套上了鼻环一样。“为了这个原因，我愿意为儿子报仇，这是为了大家的利益。我现在发誓，只要我还负责指挥家族的行动，若是没有正当理由和遇到最激烈的挑衅，就连一个指头也不会举起来反对在座各位。我愿意为了共同利益牺牲我的商业利益。我发誓保证，以名誉保证，你们都清楚我从没有违背过誓言和名誉。“不过，我也有个自私的目的。因为受到索洛佐和那位警长的凶杀指控，我最小的儿子不得不逃跑。我必须安排他安全回国，洗清污名。这是我个人的事情，我会自己做些安排。也许我必须找到真凶，或者向政府证明他的无辜，也许证人和线人会撤回他们的谎言。可是，我还是要说，这是我个人的事情，我相信我能把我的儿子带回家。“但是，有句话我得说在前头。我是个迷信的人，这个毛病多么可笑，但我不得不说，要是什么倒霉的变故落在我的小儿子头上，要是某个警察不小心开枪打死他，要是他在牢房里上吊自杀，要是什么新证人冒出来证明他有罪，那迷信就会让我觉得这是因为在座有人还对我心怀恶意。再进一步说，假如我的儿子被雷劈了，我都会怪罪在座的某些人。要是他乘的飞机坠海，乘的船只沉入滚滚波涛，他得上致命的热病，汽车被火车撞了，迷信同样会让我归咎于在座某些人的恶意。各位先生，这种恶意，这种厄运，我可永远不会原谅。但除此之外，我愿意拿我孙子辈的灵魂起誓，我绝对不会打破我们缔结的和平。说到底，我们毕竟比那些双手沾满无数人类鲜血的领袖要好，不是吗？” 说完这些，唐· 柯里昂从他的位置顺着会议桌走向唐· 塔塔利亚的座位。塔塔利亚起身迎接他，两人拥抱，彼此亲吻面颊。房间里的其他唐鼓掌，见到谁都使劲握手，祝贺唐· 柯里昂和唐· 塔塔利亚新建立的友谊。这恐怕不是全世界最美好的友谊，他们不会互送圣诞礼物，但他们也不会彼此仇杀。在他们的世界里，这样的友谊就足够了，需要的也只是这样的友谊。</p>\n<p>唉，老天应该允许每个人一辈子犯一次傻。</p>\n<p>女人和孩子能够承担粗心大意的后果，男人却不行。</p>\n<p>他的手底下是个活生生的器官，活生生的器官需要另外一个活生生的器官。</p>\n<p>他第一次理解了意大利男人那闻名遐迩的嫉妒。此时此刻，要是有谁敢碰一下这女孩，妄图宣称拥有她，从他手里夺走她，他就会毫不犹豫杀死对方。他想占有她，就像吝啬鬼想占有金币那样疯狂，就像小佃农想拥有一片土地那样饥渴，想把她锁在房间里，囚禁她，只有他一个人能碰。</p>\n<p>让朋友低估你的优点，让敌人高估你的缺点。</p>\n<p>履行职责的人能获得恰当的奖赏。</p>\n<p>你对你所爱的人不能随便说‘不’字，也不能常常说，这就是诀窍。当你说‘不’字时，你得把‘不’字说得听上去就像‘是’字一样悦耳。另一个办法就是你得设法让他们说‘不’字。你得耐心，还得不怕麻烦。不过，我是个老朽，你是新的时髦的一代，你不必听我这老一套。” 这就是说话的艺术，如同上面，你要跟他讲道理，让他无法拒绝，我想我的生命中缺少这个勇气，我不是很愿意违背朋友的愿望，但是有时却还是受到了伤害，我一直在学习如何说不，人善被人欺，所以我一直也在不断学，学会说，学会做人，我希望能把身边所谓我认为应该学的品质学会，那么那时，我也可以大声说不，这也是小说最能打动我的话，但我很早之前以前明白了他的道理，只是，我没在履行。</p>\n<p>伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。</p>\n<p>今天做了什么</p>\n<p>写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。</p>\n<p>今天学到了什么</p>\n<p>今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我<br>想当然<br>的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行<br>Double check<br>也使得问题迟迟没有被发现。所以，以后写代码<br>不能想当然<br>，只有<br>通过Double check<br>的逻辑，才是可以开始实现的逻辑。</p>\n<p>mac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。</p>\n<p>同样的错误不要犯两次。</p>\n<p>明天的计划<br>1.继续找车型数据库。<br>2.利用休息时间把mac上工作环境配置完善。<br>3.尽力完成好mentor的每一个要求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxx中修改了xx方法。<br>当天的收获<br>1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。<br>可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的<br>，遇到问题后先要用MECE分析一遍，再开始执行。<br>明天的计划<br>1.继续熟悉xxxxxx的架构。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.写了一个xxxxxapi。<br>当天的收获<br>1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。<br>2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。<br>明天的计划<br>1.继续熟悉avatar的架构。<br>提出疑问或寻求帮助<br>无。<br>今天感觉好疲惫，daily report没有用心写了QAQ</p>\n<p>当天完成的工作内容<br>1.修复了xxxx前端和后端的几个小bug。<br>当天的收获<br>1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。<br>明天的计划<br>1.继续熟悉avatar数据处理部分的逻辑。<br>提出疑问或寻求帮助<br>无。</p>\n<p>title: 《教父》摘录</p>\n<p>date: 2017-06-10 00:11:12</p>\n<p>tags:书中的一些笔记</p>\n<p>他已经学会从不出言威胁，唐教会了他这一点，但卡洛完全明白了他的意思：他离死只差半步。 </p>\n<p>就在这时，唐· 柯里昂发表了将被长久纪念的演说，巩固了他在众人中最具远见的领袖地位，演说充满逻辑常理，发自肺腑，切中要害。他在演说中创造了一个短语，日后像丘吉尔的“ 铁幕” 一样变得人尽皆知，但到十年后才进入公众视线。他第一次起身对委员会说话。他个子不高，因为“ 病况” 有点消瘦，六十岁的年龄终究显出了几分老态，但无疑已经恢复了过去的全部力量，仍旧拥有过去的所有智慧。“我们如果失去理性，那算是什么样的人啊，” 他说，“ 没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。重新挑起所有争端，诉诸暴力和混战，能够满足我的什么目标呢？我的儿子死了，这是不幸，我必须承受，不能让我周围的世界随我一同受苦。因此，我今天说，我以名誉发誓，我不会寻求复仇，不会追查往事的前因后果。我将胸怀坦荡离开这里。“有一点我想说的是，我们必须看顾自己的利益。我们这些人都拒绝当傻瓜，拒绝当傀儡，被高处的人扯着线蹦蹦跳跳。我们在这个国家运气不错。我们的大部分子女已经过上了更好的生活。你们有些人的儿子是教授、科学家、音乐家—— 真是走运。你们的孙子也许会成为新的首领。我们谁都不希望见到儿孙走上我们的老路，那样过日子太艰难了。他们可以和其他人一样，我们的勇气赢来了他们的地位和安稳。我已经有了孙子，希望他们的孩子有朝一日能成为—— 谁知道呢？—— 州长？总统？在美国一切皆有可能。可是，我们必须跟着时代向前走。刀枪刺杀的年月已经过去。我们要像商人一样狡猾，从商的钱更多，对我们的儿孙更好。“至于我们的行为，我们不需要对那些炮筒子、那些首领负责，他们擅自决定我们该怎么处理我们的生命，他们宣战，希望我们用血肉保护他们的战果。我们凭什么为了保护他人的利益而伤害自己？而我们看顾我们自己的利益，他们凭什么插手？这是我们的事业12。” 唐· 柯里昂说，“ 这是我们自己的事业。我们管理自己的世界，因为这就是我们的世界，我们的事业。我们必须紧密团结，抵抗外来的干涉。否则他们就会给我们套上鼻环，就像他们已经给美国的另外几百万那不勒斯人和意大利人套上了鼻环一样。“为了这个原因，我愿意为儿子报仇，这是为了大家的利益。我现在发誓，只要我还负责指挥家族的行动，若是没有正当理由和遇到最激烈的挑衅，就连一个指头也不会举起来反对在座各位。我愿意为了共同利益牺牲我的商业利益。我发誓保证，以名誉保证，你们都清楚我从没有违背过誓言和名誉。“不过，我也有个自私的目的。因为受到索洛佐和那位警长的凶杀指控，我最小的儿子不得不逃跑。我必须安排他安全回国，洗清污名。这是我个人的事情，我会自己做些安排。也许我必须找到真凶，或者向政府证明他的无辜，也许证人和线人会撤回他们的谎言。可是，我还是要说，这是我个人的事情，我相信我能把我的儿子带回家。“但是，有句话我得说在前头。我是个迷信的人，这个毛病多么可笑，但我不得不说，要是什么倒霉的变故落在我的小儿子头上，要是某个警察不小心开枪打死他，要是他在牢房里上吊自杀，要是什么新证人冒出来证明他有罪，那迷信就会让我觉得这是因为在座有人还对我心怀恶意。再进一步说，假如我的儿子被雷劈了，我都会怪罪在座的某些人。要是他乘的飞机坠海，乘的船只沉入滚滚波涛，他得上致命的热病，汽车被火车撞了，迷信同样会让我归咎于在座某些人的恶意。各位先生，这种恶意，这种厄运，我可永远不会原谅。但除此之外，我愿意拿我孙子辈的灵魂起誓，我绝对不会打破我们缔结的和平。说到底，我们毕竟比那些双手沾满无数人类鲜血的领袖要好，不是吗？” 说完这些，唐· 柯里昂从他的位置顺着会议桌走向唐· 塔塔利亚的座位。塔塔利亚起身迎接他，两人拥抱，彼此亲吻面颊。房间里的其他唐鼓掌，见到谁都使劲握手，祝贺唐· 柯里昂和唐· 塔塔利亚新建立的友谊。这恐怕不是全世界最美好的友谊，他们不会互送圣诞礼物，但他们也不会彼此仇杀。在他们的世界里，这样的友谊就足够了，需要的也只是这样的友谊。</p>\n<p>唉，老天应该允许每个人一辈子犯一次傻。</p>\n<p>女人和孩子能够承担粗心大意的后果，男人却不行。</p>\n<p>他的手底下是个活生生的器官，活生生的器官需要另外一个活生生的器官。</p>\n<p>他第一次理解了意大利男人那闻名遐迩的嫉妒。此时此刻，要是有谁敢碰一下这女孩，妄图宣称拥有她，从他手里夺走她，他就会毫不犹豫杀死对方。他想占有她，就像吝啬鬼想占有金币那样疯狂，就像小佃农想拥有一片土地那样饥渴，想把她锁在房间里，囚禁她，只有他一个人能碰。</p>\n<p>让朋友低估你的优点，让敌人高估你的缺点。</p>\n<p>履行职责的人能获得恰当的奖赏。</p>\n<p>你对你所爱的人不能随便说‘不’字，也不能常常说，这就是诀窍。当你说‘不’字时，你得把‘不’字说得听上去就像‘是’字一样悦耳。另一个办法就是你得设法让他们说‘不’字。你得耐心，还得不怕麻烦。不过，我是个老朽，你是新的时髦的一代，你不必听我这老一套。” 这就是说话的艺术，如同上面，你要跟他讲道理，让他无法拒绝，我想我的生命中缺少这个勇气，我不是很愿意违背朋友的愿望，但是有时却还是受到了伤害，我一直在学习如何说不，人善被人欺，所以我一直也在不断学，学会说，学会做人，我希望能把身边所谓我认为应该学的品质学会，那么那时，我也可以大声说不，这也是小说最能打动我的话，但我很早之前以前明白了他的道理，只是，我没在履行。</p>\n<p>伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。</p>\n<p>今天做了什么</p>\n<p>写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。</p>\n<p>今天学到了什么</p>\n<p>今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我<br>想当然<br>的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行<br>Double check<br>也使得问题迟迟没有被发现。所以，以后写代码<br>不能想当然<br>，只有<br>通过Double check<br>的逻辑，才是可以开始实现的逻辑。</p>\n<p>mac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。</p>\n<p>同样的错误不要犯两次。</p>\n<p>明天的计划<br>1.继续找车型数据库。<br>2.利用休息时间把mac上工作环境配置完善。<br>3.尽力完成好mentor的每一个要求。</p>\n"},{"title":"2017-08-09 Report","date":"2017-08-09T07:27:45.000Z","_content":"当天完成的工作内容\n1.爬取了firestone上的胎压数据。\n2.合并了部分胎压数据到 edmunds的车型数据库中。\n当天的收获\n1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）\n2.陈述：这个问题在之前的daily report中也有过总结，但是从实践来看，效果并不好。之前总结的是先拆分–>思考方案–>验证方案–>反馈–>确认结果–>问题解决。\n3.目标： 我要做到快速有效的解决问题，而不是仅仅是解决问题。\n4.反思： 之前总结的方案，从流程上来说解决问题确实是这些步骤，但是为什么效果不好呢？ ——> 因为这些流程中每个步骤的细节没有总结 –> 不总结到明确每个步骤做什么，那么总结的可行性会大大降低。 –> 把这个流程中的步骤，都单独总结。 –> 今天总结如何拆分问题。\n5.总结： 面对问题时，比如今天的任务是合并两个部分兼容的车型数据库。 ——> 先从目标考虑，目标是合并数据库。 ——> 那么现在是否可以直接合并？如果是，那么直接合并了；如果不能合并，要怎么做才可以合并呢？ –> 从目标上，把问题做了一次拆分。现在进入的是不可以直接合并模块 –> 既然不可以合并，那是所有的数据都不可以合并，还是部分不可以合并？ –> 是部分不可以直接合并，那么对于直接可以合并的数据也不要着急合并，继续进入部分数据不可以直接合并的思考 –> 是什么导致了这部分的数据不可以直接合并呢？ ——> 因为二者都有一部分数据是互不包含的，只有部分数据是二者的交集。 –> 那么不包含意味着不能直接合并，那么交集中数据是不是已经可以直接合并了？ ——> 交集中因为两个车型数据库的车型匹配规则不同，所以有部分数据虽然在交集内，但是仍然不能直接合并 –> 规则相同或者不受规则影响的那部分是可以直接合并的，那么受到规则影响的数据是不是全部不可以直接合并？ –> 思考到这一步的时候，需要开始实践才可以继续往下，此时才算把问题拆分到自己能考虑到的全部。\n5.简述：总结的方法是对如何拆分问题做的实践，这个过程中，每一次的拆分都要先问此时能不能达到目标了，如果可以就开始思考方案和实践方案，如果仍然不能解决那么继续拆分并且之前的过程。\n明天的计划\n1.将firestone和edmunds二者可以合并的数据，合并完整。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe exponential powers of the positions are critical for understanding numbers in other numbering systems. The position to the left of the radix (number base) point, called a decimal point only in the decimal system, is always the units position in any number system. For example, the position to the left of the binary point is always 20 or 1; the position to the left of the octal point is 80 or 1. In any case, any number raised to its zero power is always 1, or the units position.\n我的翻译\n指数的位置幂可以被理解其他数值系统中的数字所借鉴。基数左边的位置的点被称为十进制点，只在十进制系统中有。个位总是在任何数值系统中。举个例子，二进制左边的位置总是20或者1，八进制左边的位置是80或者1。在任何地方，任意数字上方有0都表示1，或者个位位置。\n正确翻译\n位的指数幂在理解其他计数制中的数时是个关键。基数小数点，在十进制中称为十进制小数点，其左边的位在任何数制中都是个位。例如，二进制小数点左边的位是20或1。而八进制小数点左边的位是80或1。在任何情况下，任何数的零次幂总是1，或1个单位。","source":"_posts/2017-08-09.md","raw":"---\ntitle: 2017-08-09 Report\ndate: 2017-08-09 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.爬取了firestone上的胎压数据。\n2.合并了部分胎压数据到 edmunds的车型数据库中。\n当天的收获\n1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）\n2.陈述：这个问题在之前的daily report中也有过总结，但是从实践来看，效果并不好。之前总结的是先拆分–>思考方案–>验证方案–>反馈–>确认结果–>问题解决。\n3.目标： 我要做到快速有效的解决问题，而不是仅仅是解决问题。\n4.反思： 之前总结的方案，从流程上来说解决问题确实是这些步骤，但是为什么效果不好呢？ ——> 因为这些流程中每个步骤的细节没有总结 –> 不总结到明确每个步骤做什么，那么总结的可行性会大大降低。 –> 把这个流程中的步骤，都单独总结。 –> 今天总结如何拆分问题。\n5.总结： 面对问题时，比如今天的任务是合并两个部分兼容的车型数据库。 ——> 先从目标考虑，目标是合并数据库。 ——> 那么现在是否可以直接合并？如果是，那么直接合并了；如果不能合并，要怎么做才可以合并呢？ –> 从目标上，把问题做了一次拆分。现在进入的是不可以直接合并模块 –> 既然不可以合并，那是所有的数据都不可以合并，还是部分不可以合并？ –> 是部分不可以直接合并，那么对于直接可以合并的数据也不要着急合并，继续进入部分数据不可以直接合并的思考 –> 是什么导致了这部分的数据不可以直接合并呢？ ——> 因为二者都有一部分数据是互不包含的，只有部分数据是二者的交集。 –> 那么不包含意味着不能直接合并，那么交集中数据是不是已经可以直接合并了？ ——> 交集中因为两个车型数据库的车型匹配规则不同，所以有部分数据虽然在交集内，但是仍然不能直接合并 –> 规则相同或者不受规则影响的那部分是可以直接合并的，那么受到规则影响的数据是不是全部不可以直接合并？ –> 思考到这一步的时候，需要开始实践才可以继续往下，此时才算把问题拆分到自己能考虑到的全部。\n5.简述：总结的方法是对如何拆分问题做的实践，这个过程中，每一次的拆分都要先问此时能不能达到目标了，如果可以就开始思考方案和实践方案，如果仍然不能解决那么继续拆分并且之前的过程。\n明天的计划\n1.将firestone和edmunds二者可以合并的数据，合并完整。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe exponential powers of the positions are critical for understanding numbers in other numbering systems. The position to the left of the radix (number base) point, called a decimal point only in the decimal system, is always the units position in any number system. For example, the position to the left of the binary point is always 20 or 1; the position to the left of the octal point is 80 or 1. In any case, any number raised to its zero power is always 1, or the units position.\n我的翻译\n指数的位置幂可以被理解其他数值系统中的数字所借鉴。基数左边的位置的点被称为十进制点，只在十进制系统中有。个位总是在任何数值系统中。举个例子，二进制左边的位置总是20或者1，八进制左边的位置是80或者1。在任何地方，任意数字上方有0都表示1，或者个位位置。\n正确翻译\n位的指数幂在理解其他计数制中的数时是个关键。基数小数点，在十进制中称为十进制小数点，其左边的位在任何数制中都是个位。例如，二进制小数点左边的位是20或1。而八进制小数点左边的位是80或1。在任何情况下，任何数的零次幂总是1，或1个单位。","slug":"2017-08-09","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq6001jlvtlwf59i37k","content":"<p>当天完成的工作内容<br>1.爬取了firestone上的胎压数据。<br>2.合并了部分胎压数据到 edmunds的车型数据库中。<br>当天的收获<br>1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）<br>2.陈述：这个问题在之前的daily report中也有过总结，但是从实践来看，效果并不好。之前总结的是先拆分–&gt;思考方案–&gt;验证方案–&gt;反馈–&gt;确认结果–&gt;问题解决。<br>3.目标： 我要做到快速有效的解决问题，而不是仅仅是解决问题。<br>4.反思： 之前总结的方案，从流程上来说解决问题确实是这些步骤，但是为什么效果不好呢？ ——&gt; 因为这些流程中每个步骤的细节没有总结 –&gt; 不总结到明确每个步骤做什么，那么总结的可行性会大大降低。 –&gt; 把这个流程中的步骤，都单独总结。 –&gt; 今天总结如何拆分问题。<br>5.总结： 面对问题时，比如今天的任务是合并两个部分兼容的车型数据库。 ——&gt; 先从目标考虑，目标是合并数据库。 ——&gt; 那么现在是否可以直接合并？如果是，那么直接合并了；如果不能合并，要怎么做才可以合并呢？ –&gt; 从目标上，把问题做了一次拆分。现在进入的是不可以直接合并模块 –&gt; 既然不可以合并，那是所有的数据都不可以合并，还是部分不可以合并？ –&gt; 是部分不可以直接合并，那么对于直接可以合并的数据也不要着急合并，继续进入部分数据不可以直接合并的思考 –&gt; 是什么导致了这部分的数据不可以直接合并呢？ ——&gt; 因为二者都有一部分数据是互不包含的，只有部分数据是二者的交集。 –&gt; 那么不包含意味着不能直接合并，那么交集中数据是不是已经可以直接合并了？ ——&gt; 交集中因为两个车型数据库的车型匹配规则不同，所以有部分数据虽然在交集内，但是仍然不能直接合并 –&gt; 规则相同或者不受规则影响的那部分是可以直接合并的，那么受到规则影响的数据是不是全部不可以直接合并？ –&gt; 思考到这一步的时候，需要开始实践才可以继续往下，此时才算把问题拆分到自己能考虑到的全部。<br>5.简述：总结的方法是对如何拆分问题做的实践，这个过程中，每一次的拆分都要先问此时能不能达到目标了，如果可以就开始思考方案和实践方案，如果仍然不能解决那么继续拆分并且之前的过程。<br>明天的计划<br>1.将firestone和edmunds二者可以合并的数据，合并完整。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The exponential powers of the positions are critical for understanding numbers in other numbering systems. The position to the left of the radix (number base) point, called a decimal point only in the decimal system, is always the units position in any number system. For example, the position to the left of the binary point is always 20 or 1; the position to the left of the octal point is 80 or 1. In any case, any number raised to its zero power is always 1, or the units position.<br>我的翻译<br>指数的位置幂可以被理解其他数值系统中的数字所借鉴。基数左边的位置的点被称为十进制点，只在十进制系统中有。个位总是在任何数值系统中。举个例子，二进制左边的位置总是20或者1，八进制左边的位置是80或者1。在任何地方，任意数字上方有0都表示1，或者个位位置。<br>正确翻译<br>位的指数幂在理解其他计数制中的数时是个关键。基数小数点，在十进制中称为十进制小数点，其左边的位在任何数制中都是个位。例如，二进制小数点左边的位是20或1。而八进制小数点左边的位是80或1。在任何情况下，任何数的零次幂总是1，或1个单位。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.爬取了firestone上的胎压数据。<br>2.合并了部分胎压数据到 edmunds的车型数据库中。<br>当天的收获<br>1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）<br>2.陈述：这个问题在之前的daily report中也有过总结，但是从实践来看，效果并不好。之前总结的是先拆分–&gt;思考方案–&gt;验证方案–&gt;反馈–&gt;确认结果–&gt;问题解决。<br>3.目标： 我要做到快速有效的解决问题，而不是仅仅是解决问题。<br>4.反思： 之前总结的方案，从流程上来说解决问题确实是这些步骤，但是为什么效果不好呢？ ——&gt; 因为这些流程中每个步骤的细节没有总结 –&gt; 不总结到明确每个步骤做什么，那么总结的可行性会大大降低。 –&gt; 把这个流程中的步骤，都单独总结。 –&gt; 今天总结如何拆分问题。<br>5.总结： 面对问题时，比如今天的任务是合并两个部分兼容的车型数据库。 ——&gt; 先从目标考虑，目标是合并数据库。 ——&gt; 那么现在是否可以直接合并？如果是，那么直接合并了；如果不能合并，要怎么做才可以合并呢？ –&gt; 从目标上，把问题做了一次拆分。现在进入的是不可以直接合并模块 –&gt; 既然不可以合并，那是所有的数据都不可以合并，还是部分不可以合并？ –&gt; 是部分不可以直接合并，那么对于直接可以合并的数据也不要着急合并，继续进入部分数据不可以直接合并的思考 –&gt; 是什么导致了这部分的数据不可以直接合并呢？ ——&gt; 因为二者都有一部分数据是互不包含的，只有部分数据是二者的交集。 –&gt; 那么不包含意味着不能直接合并，那么交集中数据是不是已经可以直接合并了？ ——&gt; 交集中因为两个车型数据库的车型匹配规则不同，所以有部分数据虽然在交集内，但是仍然不能直接合并 –&gt; 规则相同或者不受规则影响的那部分是可以直接合并的，那么受到规则影响的数据是不是全部不可以直接合并？ –&gt; 思考到这一步的时候，需要开始实践才可以继续往下，此时才算把问题拆分到自己能考虑到的全部。<br>5.简述：总结的方法是对如何拆分问题做的实践，这个过程中，每一次的拆分都要先问此时能不能达到目标了，如果可以就开始思考方案和实践方案，如果仍然不能解决那么继续拆分并且之前的过程。<br>明天的计划<br>1.将firestone和edmunds二者可以合并的数据，合并完整。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The exponential powers of the positions are critical for understanding numbers in other numbering systems. The position to the left of the radix (number base) point, called a decimal point only in the decimal system, is always the units position in any number system. For example, the position to the left of the binary point is always 20 or 1; the position to the left of the octal point is 80 or 1. In any case, any number raised to its zero power is always 1, or the units position.<br>我的翻译<br>指数的位置幂可以被理解其他数值系统中的数字所借鉴。基数左边的位置的点被称为十进制点，只在十进制系统中有。个位总是在任何数值系统中。举个例子，二进制左边的位置总是20或者1，八进制左边的位置是80或者1。在任何地方，任意数字上方有0都表示1，或者个位位置。<br>正确翻译<br>位的指数幂在理解其他计数制中的数时是个关键。基数小数点，在十进制中称为十进制小数点，其左边的位在任何数制中都是个位。例如，二进制小数点左边的位是20或1。而八进制小数点左边的位是80或1。在任何情况下，任何数的零次幂总是1，或1个单位。</p>\n"},{"title":"2017-08-16 Report","date":"2017-08-16T07:27:45.000Z","_content":"当天完成的工作内容\n1.update 合并数据的自动化脚本。\n2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。\n当天的收获\n1.问题： 不记录日志带来的麻烦\n2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。\n3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。\n明天的计划\n1.用日志确认Edmunds和Firestone的爬虫功能是否完善。\n提出疑问或寻求帮助\n无。\n今日翻译\nNotice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.\n我的翻译\n注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。","source":"_posts/2017-08-16.md","raw":"---\ntitle: 2017-08-16 Report\ndate: 2017-08-16 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.update 合并数据的自动化脚本。\n2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。\n当天的收获\n1.问题： 不记录日志带来的麻烦\n2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。\n3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。\n明天的计划\n1.用日志确认Edmunds和Firestone的爬虫功能是否完善。\n提出疑问或寻求帮助\n无。\n今日翻译\nNotice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.\n我的翻译\n注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。","slug":"2017-08-16","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq7001llvtluwk5d1vt","content":"<p>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。</p>\n"},{"title":"2017-08-10 Report","date":"2017-08-10T07:27:45.000Z","_content":"今晚耽误了很久，今天的总结并不好。\n当天完成的工作内容\n1.继续合并firestone和edmunds的数据库。\n当天的收获\n1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。\n2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。\n3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –>  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –> 为什么当时问题没有归类正确？ ——> 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –> 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——> 所以将它们放到了一个不是最匹配的类目下。\n4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –> 避免时间间隔久了，再碰到相似问题会重新定义。 –> 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。 \n明天的计划\n1.完成三张数据表完整的合并。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-08-10.md","raw":"---\ntitle: 2017-08-10 Report\ndate: 2017-08-10 15:27:45\ntags: daily report\n---\n今晚耽误了很久，今天的总结并不好。\n当天完成的工作内容\n1.继续合并firestone和edmunds的数据库。\n当天的收获\n1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。\n2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。\n3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –>  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –> 为什么当时问题没有归类正确？ ——> 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –> 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——> 所以将它们放到了一个不是最匹配的类目下。\n4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –> 避免时间间隔久了，再碰到相似问题会重新定义。 –> 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。 \n明天的计划\n1.完成三张数据表完整的合并。\n提出疑问或寻求帮助\n无。","slug":"2017-08-10","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq7001nlvtl2shdz0sg","content":"<p>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"2017-08-08 Report","date":"2017-08-08T07:27:45.000Z","_content":"当天完成的工作内容\n1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。\n当天的收获\n1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。\n2.反思： 每天总是想看的太多，比如想看python数据相关的包，又想看一些数据结构的教程，每天又有Github新的star，又把当天工作中遇到的代码问题弄懂…. –> 总是觉得这些方方面面都挺重要，但是又不能兼顾。这些想的太多，不仅看不全而且还很焦虑。导致每天晚上每个部分只弄了一点，然后第二天起来又忘了，这样更加焦虑。最近心里越来越烦，越来越焦虑。 –> 我也花了时间，但是效率非常低。 –> 对学习计划，规划不清晰 –> 把目标定的太长远了，没有规划好每天的计划。 –> 应该用天来规划，而不是用周或者是月，因为工作期间的时间太碎片了，如果还按照学校那样一周一个安排，那这一周基本上什么也做不出来。 –> 要把计划迭代的周期缩短，同时把想做的事情按照重要性来排序。\n3.方法： 先把想做的事情按重要性做个排序。权衡了一番。\n解决与思考工作上遇到的问题 >>  看scrapy的源码（每天只看一章） >> 看github里的star，技术博客等。 –> 每天晚上就做这些简单清晰的事情，想做的太多反而焦虑。 –> 任何没有反馈的学习是不可靠的 –> fork scrapy，每天在看完的代码里面写注释即可。  \n明天的计划\n1.把firestonecompleteautocare中的车型数据爬取下来。\n2.对应firestonecompleteautocare的车型数据，爬取其对应的胎压数据。\n提出疑问或寻求帮助\n无。\n今日翻译\nOnce the digits of a number system are understood, larger numbers are constructed by using positional notation. In grade school, we learned that the position to the left of the units position was the tens position, the position to the left of the tens position was the hundreds position, and so forth. (An example is the decimal number 132: This number has 1 hundred, 3 tens, and 2 units.) What probably was not learned was the exponential value of each position: The units position has a weight of 100 or 1; the tens position has weight of 101, or 10; and the hundreds position has a weight of 102, or 100.\n我的翻译\n一旦明白了数字的计数系统，就可以通过位置表示构造出更大的数字。在高中，我们学过个位的左边是十位，十位的左边是百位，以此类推。（举个十进制的132的例子，这个数字有1个百位，3个十位，2个个位）。可能没有学过指数的每个位置：个位的有一个重量10的0次方为1，十位有一个重量10的1一次方为10，百位的有一个重量10的2次方为100。\n正确翻译\n一旦我们理解了计数制的数字后，就可用位计数法构造更大的数值。在小学时我们都学过个位的左边一位是十位，十位左边一位是百位，以此类推(例如十进制数132,这个数字有—个百，三个十和两个一)。或许我们没有学过每个位的指数值：个位的权为l00，即1；十位的权为101或10；而百位的权为102或100。","source":"_posts/2017-08-08.md","raw":"---\ntitle: 2017-08-08 Report\ndate: 2017-08-08 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。\n当天的收获\n1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。\n2.反思： 每天总是想看的太多，比如想看python数据相关的包，又想看一些数据结构的教程，每天又有Github新的star，又把当天工作中遇到的代码问题弄懂…. –> 总是觉得这些方方面面都挺重要，但是又不能兼顾。这些想的太多，不仅看不全而且还很焦虑。导致每天晚上每个部分只弄了一点，然后第二天起来又忘了，这样更加焦虑。最近心里越来越烦，越来越焦虑。 –> 我也花了时间，但是效率非常低。 –> 对学习计划，规划不清晰 –> 把目标定的太长远了，没有规划好每天的计划。 –> 应该用天来规划，而不是用周或者是月，因为工作期间的时间太碎片了，如果还按照学校那样一周一个安排，那这一周基本上什么也做不出来。 –> 要把计划迭代的周期缩短，同时把想做的事情按照重要性来排序。\n3.方法： 先把想做的事情按重要性做个排序。权衡了一番。\n解决与思考工作上遇到的问题 >>  看scrapy的源码（每天只看一章） >> 看github里的star，技术博客等。 –> 每天晚上就做这些简单清晰的事情，想做的太多反而焦虑。 –> 任何没有反馈的学习是不可靠的 –> fork scrapy，每天在看完的代码里面写注释即可。  \n明天的计划\n1.把firestonecompleteautocare中的车型数据爬取下来。\n2.对应firestonecompleteautocare的车型数据，爬取其对应的胎压数据。\n提出疑问或寻求帮助\n无。\n今日翻译\nOnce the digits of a number system are understood, larger numbers are constructed by using positional notation. In grade school, we learned that the position to the left of the units position was the tens position, the position to the left of the tens position was the hundreds position, and so forth. (An example is the decimal number 132: This number has 1 hundred, 3 tens, and 2 units.) What probably was not learned was the exponential value of each position: The units position has a weight of 100 or 1; the tens position has weight of 101, or 10; and the hundreds position has a weight of 102, or 100.\n我的翻译\n一旦明白了数字的计数系统，就可以通过位置表示构造出更大的数字。在高中，我们学过个位的左边是十位，十位的左边是百位，以此类推。（举个十进制的132的例子，这个数字有1个百位，3个十位，2个个位）。可能没有学过指数的每个位置：个位的有一个重量10的0次方为1，十位有一个重量10的1一次方为10，百位的有一个重量10的2次方为100。\n正确翻译\n一旦我们理解了计数制的数字后，就可用位计数法构造更大的数值。在小学时我们都学过个位的左边一位是十位，十位左边一位是百位，以此类推(例如十进制数132,这个数字有—个百，三个十和两个一)。或许我们没有学过每个位的指数值：个位的权为l00，即1；十位的权为101或10；而百位的权为102或100。","slug":"2017-08-08","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq8001plvtl0sr0m88v","content":"<p>当天完成的工作内容<br>1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。<br>当天的收获<br>1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。<br>2.反思： 每天总是想看的太多，比如想看python数据相关的包，又想看一些数据结构的教程，每天又有Github新的star，又把当天工作中遇到的代码问题弄懂…. –&gt; 总是觉得这些方方面面都挺重要，但是又不能兼顾。这些想的太多，不仅看不全而且还很焦虑。导致每天晚上每个部分只弄了一点，然后第二天起来又忘了，这样更加焦虑。最近心里越来越烦，越来越焦虑。 –&gt; 我也花了时间，但是效率非常低。 –&gt; 对学习计划，规划不清晰 –&gt; 把目标定的太长远了，没有规划好每天的计划。 –&gt; 应该用天来规划，而不是用周或者是月，因为工作期间的时间太碎片了，如果还按照学校那样一周一个安排，那这一周基本上什么也做不出来。 –&gt; 要把计划迭代的周期缩短，同时把想做的事情按照重要性来排序。<br>3.方法： 先把想做的事情按重要性做个排序。权衡了一番。<br>解决与思考工作上遇到的问题 &gt;&gt;  看scrapy的源码（每天只看一章） &gt;&gt; 看github里的star，技术博客等。 –&gt; 每天晚上就做这些简单清晰的事情，想做的太多反而焦虑。 –&gt; 任何没有反馈的学习是不可靠的 –&gt; fork scrapy，每天在看完的代码里面写注释即可。<br>明天的计划<br>1.把firestonecompleteautocare中的车型数据爬取下来。<br>2.对应firestonecompleteautocare的车型数据，爬取其对应的胎压数据。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Once the digits of a number system are understood, larger numbers are constructed by using positional notation. In grade school, we learned that the position to the left of the units position was the tens position, the position to the left of the tens position was the hundreds position, and so forth. (An example is the decimal number 132: This number has 1 hundred, 3 tens, and 2 units.) What probably was not learned was the exponential value of each position: The units position has a weight of 100 or 1; the tens position has weight of 101, or 10; and the hundreds position has a weight of 102, or 100.<br>我的翻译<br>一旦明白了数字的计数系统，就可以通过位置表示构造出更大的数字。在高中，我们学过个位的左边是十位，十位的左边是百位，以此类推。（举个十进制的132的例子，这个数字有1个百位，3个十位，2个个位）。可能没有学过指数的每个位置：个位的有一个重量10的0次方为1，十位有一个重量10的1一次方为10，百位的有一个重量10的2次方为100。<br>正确翻译<br>一旦我们理解了计数制的数字后，就可用位计数法构造更大的数值。在小学时我们都学过个位的左边一位是十位，十位左边一位是百位，以此类推(例如十进制数132,这个数字有—个百，三个十和两个一)。或许我们没有学过每个位的指数值：个位的权为l00，即1；十位的权为101或10；而百位的权为102或100。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。<br>当天的收获<br>1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。<br>2.反思： 每天总是想看的太多，比如想看python数据相关的包，又想看一些数据结构的教程，每天又有Github新的star，又把当天工作中遇到的代码问题弄懂…. –&gt; 总是觉得这些方方面面都挺重要，但是又不能兼顾。这些想的太多，不仅看不全而且还很焦虑。导致每天晚上每个部分只弄了一点，然后第二天起来又忘了，这样更加焦虑。最近心里越来越烦，越来越焦虑。 –&gt; 我也花了时间，但是效率非常低。 –&gt; 对学习计划，规划不清晰 –&gt; 把目标定的太长远了，没有规划好每天的计划。 –&gt; 应该用天来规划，而不是用周或者是月，因为工作期间的时间太碎片了，如果还按照学校那样一周一个安排，那这一周基本上什么也做不出来。 –&gt; 要把计划迭代的周期缩短，同时把想做的事情按照重要性来排序。<br>3.方法： 先把想做的事情按重要性做个排序。权衡了一番。<br>解决与思考工作上遇到的问题 &gt;&gt;  看scrapy的源码（每天只看一章） &gt;&gt; 看github里的star，技术博客等。 –&gt; 每天晚上就做这些简单清晰的事情，想做的太多反而焦虑。 –&gt; 任何没有反馈的学习是不可靠的 –&gt; fork scrapy，每天在看完的代码里面写注释即可。<br>明天的计划<br>1.把firestonecompleteautocare中的车型数据爬取下来。<br>2.对应firestonecompleteautocare的车型数据，爬取其对应的胎压数据。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Once the digits of a number system are understood, larger numbers are constructed by using positional notation. In grade school, we learned that the position to the left of the units position was the tens position, the position to the left of the tens position was the hundreds position, and so forth. (An example is the decimal number 132: This number has 1 hundred, 3 tens, and 2 units.) What probably was not learned was the exponential value of each position: The units position has a weight of 100 or 1; the tens position has weight of 101, or 10; and the hundreds position has a weight of 102, or 100.<br>我的翻译<br>一旦明白了数字的计数系统，就可以通过位置表示构造出更大的数字。在高中，我们学过个位的左边是十位，十位的左边是百位，以此类推。（举个十进制的132的例子，这个数字有1个百位，3个十位，2个个位）。可能没有学过指数的每个位置：个位的有一个重量10的0次方为1，十位有一个重量10的1一次方为10，百位的有一个重量10的2次方为100。<br>正确翻译<br>一旦我们理解了计数制的数字后，就可用位计数法构造更大的数值。在小学时我们都学过个位的左边一位是十位，十位左边一位是百位，以此类推(例如十进制数132,这个数字有—个百，三个十和两个一)。或许我们没有学过每个位的指数值：个位的权为l00，即1；十位的权为101或10；而百位的权为102或100。</p>\n"},{"title":"2017-08-14 Report","date":"2017-08-14T07:27:45.000Z","_content":"当天完成的工作内容\n1.看avatar爬虫部分的源码。\n当天的收获\n1.当问题拆分后，如何思考解决方案？\n总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。\n明天的计划\n1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.\n我的翻译\n在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。\n正确翻译\n个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。","source":"_posts/2017-08-14.md","raw":"---\ntitle: 2017-08-14 Report\ndate: 2017-08-14 15:27:45\ntags: daily report\n---\n当天完成的工作内容\n1.看avatar爬虫部分的源码。\n当天的收获\n1.当问题拆分后，如何思考解决方案？\n总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。\n明天的计划\n1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.\n我的翻译\n在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。\n正确翻译\n个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。","slug":"2017-08-14","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq9001rlvtle2wg9oa7","content":"<p>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。</p>\n"},{"title":"2017-08-20 Report","date":"2017-08-20T07:27:45.000Z","_content":"补交8月18日Daily Report\n当天完成的工作内容\n1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。\n当天的收获\n1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？\n2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。\n3.总结:\n首先，\n1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！\n2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。 \n明天的计划\n1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。\n提出疑问或寻求帮助\n1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？\n今日翻译\n“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”\n我的翻译\nJones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。\n正确翻译\n故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   ","source":"_posts/2017-08-20.md","raw":"---\ntitle: 2017-08-20 Report\ndate: 2017-08-20 15:27:45\ntags: daily report\n---\n补交8月18日Daily Report\n当天完成的工作内容\n1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。\n当天的收获\n1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？\n2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。\n3.总结:\n首先，\n1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！\n2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。 \n明天的计划\n1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。\n提出疑问或寻求帮助\n1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？\n今日翻译\n“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”\n我的翻译\nJones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。\n正确翻译\n故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   ","slug":"2017-08-20","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oq9001tlvtlgqyv6jmm","content":"<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   </p>\n"},{"title":"2017-08-18 Report","date":"2017-08-18T07:27:45.000Z","_content":"补交8月18日Daily Report\n当天完成的工作内容\n1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。\n当天的收获\n1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？\n2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。\n3.总结:\n首先，\n1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！\n2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。 \n明天的计划\n1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。\n提出疑问或寻求帮助\n1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？\n今日翻译\n“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”\n我的翻译\nJones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。\n正确翻译\n故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   \n当天完成的工作内容\n1.update 合并数据的自动化脚本。\n2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。\n当天的收获\n1.问题： 不记录日志带来的麻烦\n2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。\n3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。\n明天的计划\n1.用日志确认Edmunds和Firestone的爬虫功能是否完善。\n提出疑问或寻求帮助\n无。\n今日翻译\nNotice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.\n我的翻译\n注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。\n当天完成的工作内容\n1.看avatar爬虫部分的源码。\n当天的收获\n1.当问题拆分后，如何思考解决方案？\n总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。\n明天的计划\n1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.\n我的翻译\n在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。\n正确翻译\n个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。\n函数式编程\n不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你\n1）代码更简单了。\n2）数据集，操作，返回值都放到了一起。\n3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。\n4）你的代码变成了在描述你要干什么，而不是怎么去干\n今晚耽误了很久，今天的总结并不好。\n当天完成的工作内容\n1.继续合并firestone和edmunds的数据库。\n当天的收获\n1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。\n2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。\n3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –>  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –> 为什么当时问题没有归类正确？ ——> 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –> 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——> 所以将它们放到了一个不是最匹配的类目下。\n4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –> 避免时间间隔久了，再碰到相似问题会重新定义。 –> 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。 \n明天的计划\n1.完成三张数据表完整的合并。\n提出疑问或寻求帮助\n无。","source":"_posts/2017-08-18.md","raw":"---\ntitle: 2017-08-18 Report\ndate: 2017-08-18 15:27:45\ntags: daily report\n---\n补交8月18日Daily Report\n当天完成的工作内容\n1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。\n当天的收获\n1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？\n2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。\n3.总结:\n首先，\n1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！\n2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。 \n明天的计划\n1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。\n提出疑问或寻求帮助\n1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？\n今日翻译\n“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”\n我的翻译\nJones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。\n正确翻译\n故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   \n当天完成的工作内容\n1.update 合并数据的自动化脚本。\n2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。\n当天的收获\n1.问题： 不记录日志带来的麻烦\n2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。\n3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。\n明天的计划\n1.用日志确认Edmunds和Firestone的爬虫功能是否完善。\n提出疑问或寻求帮助\n无。\n今日翻译\nNotice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.\n我的翻译\n注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。\n当天完成的工作内容\n1.看avatar爬虫部分的源码。\n当天的收获\n1.当问题拆分后，如何思考解决方案？\n总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。\n明天的计划\n1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。\n提出疑问或寻求帮助\n无。\n今日翻译\nThe position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.\n我的翻译\n在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。\n正确翻译\n个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。\n函数式编程\n不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你\n1）代码更简单了。\n2）数据集，操作，返回值都放到了一起。\n3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。\n4）你的代码变成了在描述你要干什么，而不是怎么去干\n今晚耽误了很久，今天的总结并不好。\n当天完成的工作内容\n1.继续合并firestone和edmunds的数据库。\n当天的收获\n1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。\n2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。\n3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –>  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –> 为什么当时问题没有归类正确？ ——> 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –> 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——> 所以将它们放到了一个不是最匹配的类目下。\n4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –> 避免时间间隔久了，再碰到相似问题会重新定义。 –> 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。 \n明天的计划\n1.完成三张数据表完整的合并。\n提出疑问或寻求帮助\n无。","slug":"2017-08-18","published":1,"updated":"2017-11-04T09:19:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqa001vlvtlb8de9xzt","content":"<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。<br>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。<br>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。<br>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干<br>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。<br>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。<br>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。<br>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干<br>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>\n"},{"title":"Python concurrency with futures","date":"2017-12-13T03:42:48.000Z","_content":"## Preface\n\n当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。\n\n\n## Sequential \n```\nimport os\nimport time\nimport sys\n\nimport requests  # It's not the standard library, so separate it from top with a blank line.\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    resp = requests.get(url)\n    return resp.content\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()  # flush stdout buffter.\n\n\ndef download_many(cc_list):\n    for cc in sorted(cc_list):\n        image = get_flag(cc)\n        show(cc)\n        save_flags(image, cc.lower() + '.gif')\n\n    return len(cc_list)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\n\n\nif __name__ == '__main__':\n    main(download_many)\n\nBD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN \n19 flags download in 21.66s\n```\n\n\n## Concurrent.futures\n\n主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。\n\n```\nfrom concurrent import futures\n\nfrom Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main\n\nMAX_WORKERS = 20\n\ndef download_one(cc):\n    image = get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))\n    with futures.ThreadPoolExecutor(workers) as executor:\n        res = executor.map(download_one, sorted(cc_list))\n\n    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。\n\nif __name__ == '__main__':\n    main(download_many)\n    \nTR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD \n19 flags download in 1.69s\n\n```\n1. 在上下文管理器中，executor的__exit__方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。\n2. 注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。\n\n\n看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？\n\n* future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。\n* 它是Future class的实例，表示已经结束或者还未结束的计算的延时。\n* Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。\n* 虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。\n* 只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。\n\n\n接下来我们用concurrency.futures.as_completed()修改上面写过的代码。\n\n```\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=3) as executor:\n        to_do = []\n        for cc in sorted(cc_list):\n            future = executor.submit(download_one, cc)\n            to_do.append(future)\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n\n        results = []\n        for future in futures.as_completed(to_do):\n            res = future.result()\n            msg = '{} result: {!r}'\n            print(msg.format(future, res))\n            results.append(res)\n\n    return len(results)\n\nScheduled for BR: <Future at 0x1020f2080 state=running>\nScheduled for CN: <Future at 0x1020f27f0 state=running>\nScheduled for ID: <Future at 0x1020f27b8 state=running>\nScheduled for IN: <Future at 0x1020fe320 state=pending>\nScheduled for US: <Future at 0x1020fe3c8 state=pending>\nBR <Future at 0x1020f2080 state=finished returned str> result: 'BR'\nID <Future at 0x1020f27b8 state=finished returned str> result: 'ID'\nIN <Future at 0x1020fe320 state=finished returned str> result: 'IN'\nUS <Future at 0x1020fe3c8 state=finished returned str> result: 'US'\nCN <Future at 0x1020f27f0 state=finished returned str> result: 'CN'\n\n5 flags download in 3.39s\n```\n\nexecutor.submit(download_one, cc)安排download _one被执行，它会返回future。\n注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。\n\n\n\n##### Experimenting with Executor.map\n\n```\nfrom time import sleep, strftime\nfrom concurrent import futures\n\n\ndef display(*args):\n    print(strftime('[%H:%M:%S]'), end=' ')\n    print(*args)\n\n\ndef loiter(n):\n    msg = '{}loiter({}): doing nothing for {}s...'\n    display(msg.format('\\t' * n, n, n))\n    sleep(n)\n    msg = '{}loiter({}): done'\n    display(msg.format('\\t' * n, n))\n    return n * 10\n\n\ndef main():\n    display('Script starting.')\n    executor = futures.ThreadPoolExecutor(max_workers=3)\n    results = executor.map(loiter, range(5))\n    display('results:', results)\n    display('Wating for individual results:')\n    for i, result in enumerate(results):\n        display('result {}: {}'.format(i, result))\nif __name__ == '__main__':\n    main()\n[10:08:03] Script starting.\n[10:08:03] loiter(0): doing nothing for 0s...\n[10:08:03] loiter(0): done\n[10:08:03] \tloiter(1): doing nothing for 1s...\n[10:08:03] \t\tloiter(2): doing nothing for 2s...\n[10:08:03] results: <generator object Executor.map.<locals>.result_iterator at 0x10d6ef468>\n[10:08:03] Wating for individual results:\n[10:08:03] result 0: 0\n[10:08:03] \t\t\tloiter(3): doing nothing for 3s...\n[10:08:04] \tloiter(1): done\n[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...\n[10:08:04] result 1: 10\n[10:08:05] \t\tloiter(2): done\n[10:08:05] result 2: 20\n[10:08:06] \t\t\tloiter(3): done\n[10:08:06] result 3: 30\n[10:08:08] \t\t\t\tloiter(4): done\n[10:08:08] result 4: 40\n注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。\n```\n\n推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。\n\n这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。\n\n\n## Downloads with progress display and error handing\n\n我们先介绍python中一个有趣的库**tqdm**，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。\n\n```\nimport time\nfrom tqdm import tqdm\n    for i in tqdm(range(100)):\n        time.sleep(0.1)\n100%|██████████| 100/100 [00:10<00:00,  9.70it/s]\n```\n\n先看sequentially download\n\n```\n\ndef get_flag(base_url, cc):\n    url = '{}/{cc}/{cc}.gif'.format(base_url, cc=cc.lower())\n    resp = requests.get(url)\n    if resp.status_code != 200:\n        resp.raise_for_status()\n    return resp.content\n\n\ndef download_one(cc, base_url, verbose=False):\n    try:\n        image = get_flag(base_url, cc)\n    except requests.exceptions.HTTPError as exc:\n        res = exc.response\n        if res.status_code == 404:\n            status = HTTPStatus.NOT_FOUND\n            msg = 'not found'\n        else:\n            raise\n\n    else:\n        save_flags(image, cc.lower() + '.gif')\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose:\n        print(cc, msg)\n\n    return Result(status, cc)\n\n\ndef download_many(cc_list, base_url, verbose, max_req):\n    counter = Counter()\n    cc_iter = sorted(cc_list)\n    if not verbose:\n        cc_iter = tqdm(cc_iter)\n    for cc in cc_iter:\n        try:\n            res = download_one(cc, base_url, verbose)\n        except requests.exceptions.HTTPError as exc:\n            error_msg = 'HTTP error {res.status_code} - {res.reason}'\n            error_msg = error_msg.format(res=exc.response)\n        except requests.exceptions.ConnectionError as exc:\n            error_msg = 'Connection error'\n        else:\n            error_msg = ''\n            status = res.status\n\n    if error_msg:\n        status = HTTPStatus.error\n\n    counter[status] += 1\n    if verbose and error_msg:\n        print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n我们用futures.as_completed来做thread error handling。\n\n\n```\ndef download_many(cc_list, base_url, verbose, concur_req):\n    counter = collections.Counter()\n    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:\n        to_do_map = {}\n        for cc in sorted(cc_list):\n            future = executor.submit(\n                download_one,\n                cc, base_url, verbose\n            )\n            to_do_map[future] = cc\n\n        done_iter = futures.as_completed(to_do_map)\n\n        if not verbose:\n            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))\n\n        for future in done_iter:\n            try:\n                res = future.result()\n            except requests.exceptions.HTTPError as exc:\n                error_msg = 'HTTP error {res.status_code} - {res.reason}'\n                error_msg = error_msg.format(res=exc.response)\n            except requests.exceptions.ConnectionError as exc:\n                error_msg = 'Connection error'\n            else:\n                error_msg = ''\n                status = res.status\n\n            if error_msg:\n                status = HTTPStatus.error\n\n            counter[status] += 1\n\n            if verbose and error_msg:\n                cc = to_do_map[future]\n                print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n## Blocking I/O and the GIL\n\n\n尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是**并行的**。这是因为CPython解释器中的GIL模式导致的。\n\n**为什么要有GIL呢？**因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程**通常**无法同时使用CPU的多核。\n\n当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。\n\n然而，所有的标准库在等待从OS返回阻塞的I/O结果时，**都可以释放GIL\n！**这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。*Tips: time.sleep()函数也会释放GIL.* \n\n\nProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。\n\n\n## 最后\n感谢阅读。\n\n本文代码地址：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo)\n\n","source":"_posts/Python-concurrency-with-futures.md","raw":"---\ntitle: Python concurrency with futures\ndate: 2017-12-13 11:42:48\ntags: Python\n\n---\n## Preface\n\n当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。\n\n\n## Sequential \n```\nimport os\nimport time\nimport sys\n\nimport requests  # It's not the standard library, so separate it from top with a blank line.\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\n\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    resp = requests.get(url)\n    return resp.content\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()  # flush stdout buffter.\n\n\ndef download_many(cc_list):\n    for cc in sorted(cc_list):\n        image = get_flag(cc)\n        show(cc)\n        save_flags(image, cc.lower() + '.gif')\n\n    return len(cc_list)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\n\n\nif __name__ == '__main__':\n    main(download_many)\n\nBD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN \n19 flags download in 21.66s\n```\n\n\n## Concurrent.futures\n\n主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。\n\n```\nfrom concurrent import futures\n\nfrom Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main\n\nMAX_WORKERS = 20\n\ndef download_one(cc):\n    image = get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))\n    with futures.ThreadPoolExecutor(workers) as executor:\n        res = executor.map(download_one, sorted(cc_list))\n\n    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。\n\nif __name__ == '__main__':\n    main(download_many)\n    \nTR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD \n19 flags download in 1.69s\n\n```\n1. 在上下文管理器中，executor的__exit__方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。\n2. 注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。\n\n\n看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？\n\n* future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。\n* 它是Future class的实例，表示已经结束或者还未结束的计算的延时。\n* Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。\n* 虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。\n* 只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。\n\n\n接下来我们用concurrency.futures.as_completed()修改上面写过的代码。\n\n```\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=3) as executor:\n        to_do = []\n        for cc in sorted(cc_list):\n            future = executor.submit(download_one, cc)\n            to_do.append(future)\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n\n        results = []\n        for future in futures.as_completed(to_do):\n            res = future.result()\n            msg = '{} result: {!r}'\n            print(msg.format(future, res))\n            results.append(res)\n\n    return len(results)\n\nScheduled for BR: <Future at 0x1020f2080 state=running>\nScheduled for CN: <Future at 0x1020f27f0 state=running>\nScheduled for ID: <Future at 0x1020f27b8 state=running>\nScheduled for IN: <Future at 0x1020fe320 state=pending>\nScheduled for US: <Future at 0x1020fe3c8 state=pending>\nBR <Future at 0x1020f2080 state=finished returned str> result: 'BR'\nID <Future at 0x1020f27b8 state=finished returned str> result: 'ID'\nIN <Future at 0x1020fe320 state=finished returned str> result: 'IN'\nUS <Future at 0x1020fe3c8 state=finished returned str> result: 'US'\nCN <Future at 0x1020f27f0 state=finished returned str> result: 'CN'\n\n5 flags download in 3.39s\n```\n\nexecutor.submit(download_one, cc)安排download _one被执行，它会返回future。\n注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。\n\n\n\n##### Experimenting with Executor.map\n\n```\nfrom time import sleep, strftime\nfrom concurrent import futures\n\n\ndef display(*args):\n    print(strftime('[%H:%M:%S]'), end=' ')\n    print(*args)\n\n\ndef loiter(n):\n    msg = '{}loiter({}): doing nothing for {}s...'\n    display(msg.format('\\t' * n, n, n))\n    sleep(n)\n    msg = '{}loiter({}): done'\n    display(msg.format('\\t' * n, n))\n    return n * 10\n\n\ndef main():\n    display('Script starting.')\n    executor = futures.ThreadPoolExecutor(max_workers=3)\n    results = executor.map(loiter, range(5))\n    display('results:', results)\n    display('Wating for individual results:')\n    for i, result in enumerate(results):\n        display('result {}: {}'.format(i, result))\nif __name__ == '__main__':\n    main()\n[10:08:03] Script starting.\n[10:08:03] loiter(0): doing nothing for 0s...\n[10:08:03] loiter(0): done\n[10:08:03] \tloiter(1): doing nothing for 1s...\n[10:08:03] \t\tloiter(2): doing nothing for 2s...\n[10:08:03] results: <generator object Executor.map.<locals>.result_iterator at 0x10d6ef468>\n[10:08:03] Wating for individual results:\n[10:08:03] result 0: 0\n[10:08:03] \t\t\tloiter(3): doing nothing for 3s...\n[10:08:04] \tloiter(1): done\n[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...\n[10:08:04] result 1: 10\n[10:08:05] \t\tloiter(2): done\n[10:08:05] result 2: 20\n[10:08:06] \t\t\tloiter(3): done\n[10:08:06] result 3: 30\n[10:08:08] \t\t\t\tloiter(4): done\n[10:08:08] result 4: 40\n注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。\n```\n\n推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。\n\n这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。\n\n\n## Downloads with progress display and error handing\n\n我们先介绍python中一个有趣的库**tqdm**，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。\n\n```\nimport time\nfrom tqdm import tqdm\n    for i in tqdm(range(100)):\n        time.sleep(0.1)\n100%|██████████| 100/100 [00:10<00:00,  9.70it/s]\n```\n\n先看sequentially download\n\n```\n\ndef get_flag(base_url, cc):\n    url = '{}/{cc}/{cc}.gif'.format(base_url, cc=cc.lower())\n    resp = requests.get(url)\n    if resp.status_code != 200:\n        resp.raise_for_status()\n    return resp.content\n\n\ndef download_one(cc, base_url, verbose=False):\n    try:\n        image = get_flag(base_url, cc)\n    except requests.exceptions.HTTPError as exc:\n        res = exc.response\n        if res.status_code == 404:\n            status = HTTPStatus.NOT_FOUND\n            msg = 'not found'\n        else:\n            raise\n\n    else:\n        save_flags(image, cc.lower() + '.gif')\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose:\n        print(cc, msg)\n\n    return Result(status, cc)\n\n\ndef download_many(cc_list, base_url, verbose, max_req):\n    counter = Counter()\n    cc_iter = sorted(cc_list)\n    if not verbose:\n        cc_iter = tqdm(cc_iter)\n    for cc in cc_iter:\n        try:\n            res = download_one(cc, base_url, verbose)\n        except requests.exceptions.HTTPError as exc:\n            error_msg = 'HTTP error {res.status_code} - {res.reason}'\n            error_msg = error_msg.format(res=exc.response)\n        except requests.exceptions.ConnectionError as exc:\n            error_msg = 'Connection error'\n        else:\n            error_msg = ''\n            status = res.status\n\n    if error_msg:\n        status = HTTPStatus.error\n\n    counter[status] += 1\n    if verbose and error_msg:\n        print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n我们用futures.as_completed来做thread error handling。\n\n\n```\ndef download_many(cc_list, base_url, verbose, concur_req):\n    counter = collections.Counter()\n    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:\n        to_do_map = {}\n        for cc in sorted(cc_list):\n            future = executor.submit(\n                download_one,\n                cc, base_url, verbose\n            )\n            to_do_map[future] = cc\n\n        done_iter = futures.as_completed(to_do_map)\n\n        if not verbose:\n            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))\n\n        for future in done_iter:\n            try:\n                res = future.result()\n            except requests.exceptions.HTTPError as exc:\n                error_msg = 'HTTP error {res.status_code} - {res.reason}'\n                error_msg = error_msg.format(res=exc.response)\n            except requests.exceptions.ConnectionError as exc:\n                error_msg = 'Connection error'\n            else:\n                error_msg = ''\n                status = res.status\n\n            if error_msg:\n                status = HTTPStatus.error\n\n            counter[status] += 1\n\n            if verbose and error_msg:\n                cc = to_do_map[future]\n                print('*** Error for {}: {}'.format(cc, error_msg))\n\n    return counter\n```\n\n\n## Blocking I/O and the GIL\n\n\n尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是**并行的**。这是因为CPython解释器中的GIL模式导致的。\n\n**为什么要有GIL呢？**因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程**通常**无法同时使用CPU的多核。\n\n当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。\n\n然而，所有的标准库在等待从OS返回阻塞的I/O结果时，**都可以释放GIL\n！**这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。*Tips: time.sleep()函数也会释放GIL.* \n\n\nProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。\n\n\n## 最后\n感谢阅读。\n\n本文代码地址：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo)\n\n","slug":"Python-concurrency-with-futures","published":1,"updated":"2017-12-13T04:04:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqb001xlvtl8nnpp8b6","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。</p>\n<h2 id=\"Sequential\"><a href=\"#Sequential\" class=\"headerlink\" title=\"Sequential\"></a>Sequential</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\">import time</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">import requests  # It&apos;s not the standard library, so separate it from top with a blank line.</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\"></div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()  # flush stdout buffter.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    for cc in sorted(cc_list):</div><div class=\"line\">        image = get_flag(cc)</div><div class=\"line\">        show(cc)</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\"></div><div class=\"line\">    return len(cc_list)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\"></div><div class=\"line\">BD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN </div><div class=\"line\">19 flags download in 21.66s</div></pre></td></tr></table></figure>\n<h2 id=\"Concurrent-futures\"><a href=\"#Concurrent-futures\" class=\"headerlink\" title=\"Concurrent.futures\"></a>Concurrent.futures</h2><p>主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main</div><div class=\"line\"></div><div class=\"line\">MAX_WORKERS = 20</div><div class=\"line\"></div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    workers = min(MAX_WORKERS, len(cc_list))</div><div class=\"line\">    with futures.ThreadPoolExecutor(workers) as executor:</div><div class=\"line\">        res = executor.map(download_one, sorted(cc_list))</div><div class=\"line\"></div><div class=\"line\">    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\">    </div><div class=\"line\">TR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD </div><div class=\"line\">19 flags download in 1.69s</div></pre></td></tr></table></figure>\n<ol>\n<li>在上下文管理器中，executor的<strong>exit</strong>方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。</li>\n<li>注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。</li>\n</ol>\n<p>看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？</p>\n<ul>\n<li>future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。</li>\n<li>它是Future class的实例，表示已经结束或者还未结束的计算的延时。</li>\n<li>Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。</li>\n<li>虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。</li>\n<li>只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。</li>\n</ul>\n<p>接下来我们用concurrency.futures.as_completed()修改上面写过的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    cc_list = cc_list[:5]</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=3) as executor:</div><div class=\"line\">        to_do = []</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(download_one, cc)</div><div class=\"line\">            to_do.append(future)</div><div class=\"line\">            msg = &apos;Scheduled for &#123;&#125;: &#123;&#125;&apos;</div><div class=\"line\">            print(msg.format(cc, future))</div><div class=\"line\"></div><div class=\"line\">        results = []</div><div class=\"line\">        for future in futures.as_completed(to_do):</div><div class=\"line\">            res = future.result()</div><div class=\"line\">            msg = &apos;&#123;&#125; result: &#123;!r&#125;&apos;</div><div class=\"line\">            print(msg.format(future, res))</div><div class=\"line\">            results.append(res)</div><div class=\"line\"></div><div class=\"line\">    return len(results)</div><div class=\"line\"></div><div class=\"line\">Scheduled for BR: &lt;Future at 0x1020f2080 state=running&gt;</div><div class=\"line\">Scheduled for CN: &lt;Future at 0x1020f27f0 state=running&gt;</div><div class=\"line\">Scheduled for ID: &lt;Future at 0x1020f27b8 state=running&gt;</div><div class=\"line\">Scheduled for IN: &lt;Future at 0x1020fe320 state=pending&gt;</div><div class=\"line\">Scheduled for US: &lt;Future at 0x1020fe3c8 state=pending&gt;</div><div class=\"line\">BR &lt;Future at 0x1020f2080 state=finished returned str&gt; result: &apos;BR&apos;</div><div class=\"line\">ID &lt;Future at 0x1020f27b8 state=finished returned str&gt; result: &apos;ID&apos;</div><div class=\"line\">IN &lt;Future at 0x1020fe320 state=finished returned str&gt; result: &apos;IN&apos;</div><div class=\"line\">US &lt;Future at 0x1020fe3c8 state=finished returned str&gt; result: &apos;US&apos;</div><div class=\"line\">CN &lt;Future at 0x1020f27f0 state=finished returned str&gt; result: &apos;CN&apos;</div><div class=\"line\"></div><div class=\"line\">5 flags download in 3.39s</div></pre></td></tr></table></figure>\n<p>executor.submit(download_one, cc)安排download _one被执行，它会返回future。<br>注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。</p>\n<h5 id=\"Experimenting-with-Executor-map\"><a href=\"#Experimenting-with-Executor-map\" class=\"headerlink\" title=\"Experimenting with Executor.map\"></a>Experimenting with Executor.map</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">from time import sleep, strftime</div><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def display(*args):</div><div class=\"line\">    print(strftime(&apos;[%H:%M:%S]&apos;), end=&apos; &apos;)</div><div class=\"line\">    print(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def loiter(n):</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n, n))</div><div class=\"line\">    sleep(n)</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): done&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n))</div><div class=\"line\">    return n * 10</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    display(&apos;Script starting.&apos;)</div><div class=\"line\">    executor = futures.ThreadPoolExecutor(max_workers=3)</div><div class=\"line\">    results = executor.map(loiter, range(5))</div><div class=\"line\">    display(&apos;results:&apos;, results)</div><div class=\"line\">    display(&apos;Wating for individual results:&apos;)</div><div class=\"line\">    for i, result in enumerate(results):</div><div class=\"line\">        display(&apos;result &#123;&#125;: &#123;&#125;&apos;.format(i, result))</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">[10:08:03] Script starting.</div><div class=\"line\">[10:08:03] loiter(0): doing nothing for 0s...</div><div class=\"line\">[10:08:03] loiter(0): done</div><div class=\"line\">[10:08:03] \tloiter(1): doing nothing for 1s...</div><div class=\"line\">[10:08:03] \t\tloiter(2): doing nothing for 2s...</div><div class=\"line\">[10:08:03] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d6ef468&gt;</div><div class=\"line\">[10:08:03] Wating for individual results:</div><div class=\"line\">[10:08:03] result 0: 0</div><div class=\"line\">[10:08:03] \t\t\tloiter(3): doing nothing for 3s...</div><div class=\"line\">[10:08:04] \tloiter(1): done</div><div class=\"line\">[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...</div><div class=\"line\">[10:08:04] result 1: 10</div><div class=\"line\">[10:08:05] \t\tloiter(2): done</div><div class=\"line\">[10:08:05] result 2: 20</div><div class=\"line\">[10:08:06] \t\t\tloiter(3): done</div><div class=\"line\">[10:08:06] result 3: 30</div><div class=\"line\">[10:08:08] \t\t\t\tloiter(4): done</div><div class=\"line\">[10:08:08] result 4: 40</div><div class=\"line\">注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。</div></pre></td></tr></table></figure>\n<p>推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。</p>\n<p>这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。</p>\n<h2 id=\"Downloads-with-progress-display-and-error-handing\"><a href=\"#Downloads-with-progress-display-and-error-handing\" class=\"headerlink\" title=\"Downloads with progress display and error handing\"></a>Downloads with progress display and error handing</h2><p>我们先介绍python中一个有趣的库<strong>tqdm</strong>，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\">from tqdm import tqdm</div><div class=\"line\">    for i in tqdm(range(100)):</div><div class=\"line\">        time.sleep(0.1)</div><div class=\"line\">100%|██████████| 100/100 [00:10&lt;00:00,  9.70it/s]</div></pre></td></tr></table></figure>\n<p>先看sequentially download</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def get_flag(base_url, cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(base_url, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    if resp.status_code != 200:</div><div class=\"line\">        resp.raise_for_status()</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_one(cc, base_url, verbose=False):</div><div class=\"line\">    try:</div><div class=\"line\">        image = get_flag(base_url, cc)</div><div class=\"line\">    except requests.exceptions.HTTPError as exc:</div><div class=\"line\">        res = exc.response</div><div class=\"line\">        if res.status_code == 404:</div><div class=\"line\">            status = HTTPStatus.NOT_FOUND</div><div class=\"line\">            msg = &apos;not found&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            raise</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list, base_url, verbose, max_req):</div><div class=\"line\">    counter = Counter()</div><div class=\"line\">    cc_iter = sorted(cc_list)</div><div class=\"line\">    if not verbose:</div><div class=\"line\">        cc_iter = tqdm(cc_iter)</div><div class=\"line\">    for cc in cc_iter:</div><div class=\"line\">        try:</div><div class=\"line\">            res = download_one(cc, base_url, verbose)</div><div class=\"line\">        except requests.exceptions.HTTPError as exc:</div><div class=\"line\">            error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">            error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">        except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">            error_msg = &apos;Connection error&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            error_msg = &apos;&apos;</div><div class=\"line\">            status = res.status</div><div class=\"line\"></div><div class=\"line\">    if error_msg:</div><div class=\"line\">        status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">    counter[status] += 1</div><div class=\"line\">    if verbose and error_msg:</div><div class=\"line\">        print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<p>我们用futures.as_completed来做thread error handling。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list, base_url, verbose, concur_req):</div><div class=\"line\">    counter = collections.Counter()</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:</div><div class=\"line\">        to_do_map = &#123;&#125;</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(</div><div class=\"line\">                download_one,</div><div class=\"line\">                cc, base_url, verbose</div><div class=\"line\">            )</div><div class=\"line\">            to_do_map[future] = cc</div><div class=\"line\"></div><div class=\"line\">        done_iter = futures.as_completed(to_do_map)</div><div class=\"line\"></div><div class=\"line\">        if not verbose:</div><div class=\"line\">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</div><div class=\"line\"></div><div class=\"line\">        for future in done_iter:</div><div class=\"line\">            try:</div><div class=\"line\">                res = future.result()</div><div class=\"line\">            except requests.exceptions.HTTPError as exc:</div><div class=\"line\">                error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">                error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">            except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">                error_msg = &apos;Connection error&apos;</div><div class=\"line\">            else:</div><div class=\"line\">                error_msg = &apos;&apos;</div><div class=\"line\">                status = res.status</div><div class=\"line\"></div><div class=\"line\">            if error_msg:</div><div class=\"line\">                status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">            counter[status] += 1</div><div class=\"line\"></div><div class=\"line\">            if verbose and error_msg:</div><div class=\"line\">                cc = to_do_map[future]</div><div class=\"line\">                print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<h2 id=\"Blocking-I-O-and-the-GIL\"><a href=\"#Blocking-I-O-and-the-GIL\" class=\"headerlink\" title=\"Blocking I/O and the GIL\"></a>Blocking I/O and the GIL</h2><p>尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是<strong>并行的</strong>。这是因为CPython解释器中的GIL模式导致的。</p>\n<p><strong>为什么要有GIL呢？</strong>因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程<strong>通常</strong>无法同时使用CPU的多核。</p>\n<p>当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。</p>\n<p>然而，所有的标准库在等待从OS返回阻塞的I/O结果时，<strong>都可以释放GIL<br>！</strong>这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。<em>Tips: time.sleep()函数也会释放GIL.</em> </p>\n<p>ProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>感谢阅读。</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。</p>\n<h2 id=\"Sequential\"><a href=\"#Sequential\" class=\"headerlink\" title=\"Sequential\"></a>Sequential</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\">import time</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">import requests  # It&apos;s not the standard library, so separate it from top with a blank line.</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\"></div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()  # flush stdout buffter.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    for cc in sorted(cc_list):</div><div class=\"line\">        image = get_flag(cc)</div><div class=\"line\">        show(cc)</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\"></div><div class=\"line\">    return len(cc_list)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\"></div><div class=\"line\">BD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN </div><div class=\"line\">19 flags download in 21.66s</div></pre></td></tr></table></figure>\n<h2 id=\"Concurrent-futures\"><a href=\"#Concurrent-futures\" class=\"headerlink\" title=\"Concurrent.futures\"></a>Concurrent.futures</h2><p>主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\">from Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main</div><div class=\"line\"></div><div class=\"line\">MAX_WORKERS = 20</div><div class=\"line\"></div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    workers = min(MAX_WORKERS, len(cc_list))</div><div class=\"line\">    with futures.ThreadPoolExecutor(workers) as executor:</div><div class=\"line\">        res = executor.map(download_one, sorted(cc_list))</div><div class=\"line\"></div><div class=\"line\">    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main(download_many)</div><div class=\"line\">    </div><div class=\"line\">TR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD </div><div class=\"line\">19 flags download in 1.69s</div></pre></td></tr></table></figure>\n<ol>\n<li>在上下文管理器中，executor的<strong>exit</strong>方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。</li>\n<li>注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。</li>\n</ol>\n<p>看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？</p>\n<ul>\n<li>future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。</li>\n<li>它是Future class的实例，表示已经结束或者还未结束的计算的延时。</li>\n<li>Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。</li>\n<li>虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。</li>\n<li>只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。</li>\n</ul>\n<p>接下来我们用concurrency.futures.as_completed()修改上面写过的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    cc_list = cc_list[:5]</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=3) as executor:</div><div class=\"line\">        to_do = []</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(download_one, cc)</div><div class=\"line\">            to_do.append(future)</div><div class=\"line\">            msg = &apos;Scheduled for &#123;&#125;: &#123;&#125;&apos;</div><div class=\"line\">            print(msg.format(cc, future))</div><div class=\"line\"></div><div class=\"line\">        results = []</div><div class=\"line\">        for future in futures.as_completed(to_do):</div><div class=\"line\">            res = future.result()</div><div class=\"line\">            msg = &apos;&#123;&#125; result: &#123;!r&#125;&apos;</div><div class=\"line\">            print(msg.format(future, res))</div><div class=\"line\">            results.append(res)</div><div class=\"line\"></div><div class=\"line\">    return len(results)</div><div class=\"line\"></div><div class=\"line\">Scheduled for BR: &lt;Future at 0x1020f2080 state=running&gt;</div><div class=\"line\">Scheduled for CN: &lt;Future at 0x1020f27f0 state=running&gt;</div><div class=\"line\">Scheduled for ID: &lt;Future at 0x1020f27b8 state=running&gt;</div><div class=\"line\">Scheduled for IN: &lt;Future at 0x1020fe320 state=pending&gt;</div><div class=\"line\">Scheduled for US: &lt;Future at 0x1020fe3c8 state=pending&gt;</div><div class=\"line\">BR &lt;Future at 0x1020f2080 state=finished returned str&gt; result: &apos;BR&apos;</div><div class=\"line\">ID &lt;Future at 0x1020f27b8 state=finished returned str&gt; result: &apos;ID&apos;</div><div class=\"line\">IN &lt;Future at 0x1020fe320 state=finished returned str&gt; result: &apos;IN&apos;</div><div class=\"line\">US &lt;Future at 0x1020fe3c8 state=finished returned str&gt; result: &apos;US&apos;</div><div class=\"line\">CN &lt;Future at 0x1020f27f0 state=finished returned str&gt; result: &apos;CN&apos;</div><div class=\"line\"></div><div class=\"line\">5 flags download in 3.39s</div></pre></td></tr></table></figure>\n<p>executor.submit(download_one, cc)安排download _one被执行，它会返回future。<br>注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。</p>\n<h5 id=\"Experimenting-with-Executor-map\"><a href=\"#Experimenting-with-Executor-map\" class=\"headerlink\" title=\"Experimenting with Executor.map\"></a>Experimenting with Executor.map</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">from time import sleep, strftime</div><div class=\"line\">from concurrent import futures</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def display(*args):</div><div class=\"line\">    print(strftime(&apos;[%H:%M:%S]&apos;), end=&apos; &apos;)</div><div class=\"line\">    print(*args)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def loiter(n):</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n, n))</div><div class=\"line\">    sleep(n)</div><div class=\"line\">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): done&apos;</div><div class=\"line\">    display(msg.format(&apos;\\t&apos; * n, n))</div><div class=\"line\">    return n * 10</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    display(&apos;Script starting.&apos;)</div><div class=\"line\">    executor = futures.ThreadPoolExecutor(max_workers=3)</div><div class=\"line\">    results = executor.map(loiter, range(5))</div><div class=\"line\">    display(&apos;results:&apos;, results)</div><div class=\"line\">    display(&apos;Wating for individual results:&apos;)</div><div class=\"line\">    for i, result in enumerate(results):</div><div class=\"line\">        display(&apos;result &#123;&#125;: &#123;&#125;&apos;.format(i, result))</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">[10:08:03] Script starting.</div><div class=\"line\">[10:08:03] loiter(0): doing nothing for 0s...</div><div class=\"line\">[10:08:03] loiter(0): done</div><div class=\"line\">[10:08:03] \tloiter(1): doing nothing for 1s...</div><div class=\"line\">[10:08:03] \t\tloiter(2): doing nothing for 2s...</div><div class=\"line\">[10:08:03] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d6ef468&gt;</div><div class=\"line\">[10:08:03] Wating for individual results:</div><div class=\"line\">[10:08:03] result 0: 0</div><div class=\"line\">[10:08:03] \t\t\tloiter(3): doing nothing for 3s...</div><div class=\"line\">[10:08:04] \tloiter(1): done</div><div class=\"line\">[10:08:04] \t\t\t\tloiter(4): doing nothing for 4s...</div><div class=\"line\">[10:08:04] result 1: 10</div><div class=\"line\">[10:08:05] \t\tloiter(2): done</div><div class=\"line\">[10:08:05] result 2: 20</div><div class=\"line\">[10:08:06] \t\t\tloiter(3): done</div><div class=\"line\">[10:08:06] result 3: 30</div><div class=\"line\">[10:08:08] \t\t\t\tloiter(4): done</div><div class=\"line\">[10:08:08] result 4: 40</div><div class=\"line\">注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。</div></pre></td></tr></table></figure>\n<p>推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。</p>\n<p>这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。</p>\n<h2 id=\"Downloads-with-progress-display-and-error-handing\"><a href=\"#Downloads-with-progress-display-and-error-handing\" class=\"headerlink\" title=\"Downloads with progress display and error handing\"></a>Downloads with progress display and error handing</h2><p>我们先介绍python中一个有趣的库<strong>tqdm</strong>，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\">from tqdm import tqdm</div><div class=\"line\">    for i in tqdm(range(100)):</div><div class=\"line\">        time.sleep(0.1)</div><div class=\"line\">100%|██████████| 100/100 [00:10&lt;00:00,  9.70it/s]</div></pre></td></tr></table></figure>\n<p>先看sequentially download</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def get_flag(base_url, cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(base_url, cc=cc.lower())</div><div class=\"line\">    resp = requests.get(url)</div><div class=\"line\">    if resp.status_code != 200:</div><div class=\"line\">        resp.raise_for_status()</div><div class=\"line\">    return resp.content</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_one(cc, base_url, verbose=False):</div><div class=\"line\">    try:</div><div class=\"line\">        image = get_flag(base_url, cc)</div><div class=\"line\">    except requests.exceptions.HTTPError as exc:</div><div class=\"line\">        res = exc.response</div><div class=\"line\">        if res.status_code == 404:</div><div class=\"line\">            status = HTTPStatus.NOT_FOUND</div><div class=\"line\">            msg = &apos;not found&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            raise</div><div class=\"line\"></div><div class=\"line\">    else:</div><div class=\"line\">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">        status = HTTPStatus.OK</div><div class=\"line\">        msg = &apos;OK&apos;</div><div class=\"line\"></div><div class=\"line\">    if verbose:</div><div class=\"line\">        print(cc, msg)</div><div class=\"line\"></div><div class=\"line\">    return Result(status, cc)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def download_many(cc_list, base_url, verbose, max_req):</div><div class=\"line\">    counter = Counter()</div><div class=\"line\">    cc_iter = sorted(cc_list)</div><div class=\"line\">    if not verbose:</div><div class=\"line\">        cc_iter = tqdm(cc_iter)</div><div class=\"line\">    for cc in cc_iter:</div><div class=\"line\">        try:</div><div class=\"line\">            res = download_one(cc, base_url, verbose)</div><div class=\"line\">        except requests.exceptions.HTTPError as exc:</div><div class=\"line\">            error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">            error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">        except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">            error_msg = &apos;Connection error&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            error_msg = &apos;&apos;</div><div class=\"line\">            status = res.status</div><div class=\"line\"></div><div class=\"line\">    if error_msg:</div><div class=\"line\">        status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">    counter[status] += 1</div><div class=\"line\">    if verbose and error_msg:</div><div class=\"line\">        print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<p>我们用futures.as_completed来做thread error handling。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def download_many(cc_list, base_url, verbose, concur_req):</div><div class=\"line\">    counter = collections.Counter()</div><div class=\"line\">    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:</div><div class=\"line\">        to_do_map = &#123;&#125;</div><div class=\"line\">        for cc in sorted(cc_list):</div><div class=\"line\">            future = executor.submit(</div><div class=\"line\">                download_one,</div><div class=\"line\">                cc, base_url, verbose</div><div class=\"line\">            )</div><div class=\"line\">            to_do_map[future] = cc</div><div class=\"line\"></div><div class=\"line\">        done_iter = futures.as_completed(to_do_map)</div><div class=\"line\"></div><div class=\"line\">        if not verbose:</div><div class=\"line\">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</div><div class=\"line\"></div><div class=\"line\">        for future in done_iter:</div><div class=\"line\">            try:</div><div class=\"line\">                res = future.result()</div><div class=\"line\">            except requests.exceptions.HTTPError as exc:</div><div class=\"line\">                error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class=\"line\">                error_msg = error_msg.format(res=exc.response)</div><div class=\"line\">            except requests.exceptions.ConnectionError as exc:</div><div class=\"line\">                error_msg = &apos;Connection error&apos;</div><div class=\"line\">            else:</div><div class=\"line\">                error_msg = &apos;&apos;</div><div class=\"line\">                status = res.status</div><div class=\"line\"></div><div class=\"line\">            if error_msg:</div><div class=\"line\">                status = HTTPStatus.error</div><div class=\"line\"></div><div class=\"line\">            counter[status] += 1</div><div class=\"line\"></div><div class=\"line\">            if verbose and error_msg:</div><div class=\"line\">                cc = to_do_map[future]</div><div class=\"line\">                print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class=\"line\"></div><div class=\"line\">    return counter</div></pre></td></tr></table></figure>\n<h2 id=\"Blocking-I-O-and-the-GIL\"><a href=\"#Blocking-I-O-and-the-GIL\" class=\"headerlink\" title=\"Blocking I/O and the GIL\"></a>Blocking I/O and the GIL</h2><p>尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是<strong>并行的</strong>。这是因为CPython解释器中的GIL模式导致的。</p>\n<p><strong>为什么要有GIL呢？</strong>因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程<strong>通常</strong>无法同时使用CPU的多核。</p>\n<p>当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。</p>\n<p>然而，所有的标准库在等待从OS返回阻塞的I/O结果时，<strong>都可以释放GIL<br>！</strong>这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。<em>Tips: time.sleep()函数也会释放GIL.</em> </p>\n<p>ProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>感谢阅读。</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo</a></p>\n"},{"title":"Python Iterators and Iterables介绍","date":"2017-12-02T07:02:24.000Z","_content":"## Concept\nIteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行**惰性**读取，意味着每次操作只读取一条数据-----而这就是Iterator模式。\n\n\n## Iterables\n`iterable `  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了__ iter__方法并且返回一个iterator，那么称对象是iterable.\n\n在Python里所有的集合都是可迭代的，例如：\n\n* for 循环\n* 集合类型和其扩展\n* list, dict, set类型的解析式\n* tuple类型的unpack\n* 对函数的*args形参进行unpack\n\n诸如此类的操作，都是iterable.\n\n通过例子我们再来探索一下\n\n```\nRE_WORD = re.compile(r'\\w+')\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __len__(self):\n        return len(self.words)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。\n```\n\n\n## How the iter(...) built-in function is used to internally to hanlde iterable objects.\n\n每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？\n这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。\n\niter()方法的使用规则：\n\n1. 检查对象是否实现了__ iter__方法，如果有，则调用得到一个iterator.\n2. 如果__ iter__ 方法没有被实现，但是对象实现了__ getitem__方法，那么Python会创建一个Iterator并按照顺序从0开始索引.\n3. 如果没有实现以上方法，或者操作失败。Python会抛出**TypeError**， 如：TypeError: 'Sentence' object is not iterable.\n\n而正是Python的序列对象都实现了 __ getitem__方法，所以它们都是可迭代的。（通常标准的sequences也会实现 __ iter__方法）\n\n\n## How to implement the classic Iterator pattern in Python.\niterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:\n\n```\ns = 'ABC'\nfor char in s:\n    print(char)\nA\nB\nC\n这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。\n\ns = 'ABC'\nit = iter(s)\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        del it\n        break\n```\n**StopIteration** 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。\n\n标准的iterator接口有两个方法：\n\n1.  __ next__  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。\n2.  __ iter__  返回自身；这样可用于for循环操作。\n\n当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了__ iter__ 方法，调用它也只能获得它本身，所以不可能进行重设操作。\n\n`iterator` 是指实现了__ next__ 和__ iter__方法的对象, __ next__ 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了__ iter__方法，所以iterator同时也是iterable。\n\n接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n    def __iter__(self):\n        return SentenceIterator(self.words)\n\n\nclass SentenceIterator(object):\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n```\n通过这个例子，可以看到： iterable实现了 __ iter__方法，每次调用会返回一个iterator实例。iterator对象实现了 __ next__ 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), __ iter__ 方法每次返回自身。\n因此，我们可以说**iterator是iterable，但是iterable不是iterator.**\n\n\n最后我们作出一个猜想： 我们可不可以在Sentence类里实现__ next__方法呢，使Sentence既是iterator也是iterable，岂不美哉？\n\n答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。\n\n**Iterator Pattern**里有一点：to support multiple traversals of aggregate objects.\n如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了__ next__方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。\n\n\n## Summary\n感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。\n\n本文代码链接:[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。\n\n值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念**generator**也与其有关。因为篇幅原因，我将其拆分为另一篇文章[a](a)，打铁要趁热！！！快来学习一下！！！\n\n\n","source":"_posts/Python-Iterators-and-Iterables介绍.md","raw":"---\ntitle: Python Iterators and Iterables介绍\ndate: 2017-12-02 15:02:24\ntags: Python\n\n---\n## Concept\nIteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行**惰性**读取，意味着每次操作只读取一条数据-----而这就是Iterator模式。\n\n\n## Iterables\n`iterable `  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了__ iter__方法并且返回一个iterator，那么称对象是iterable.\n\n在Python里所有的集合都是可迭代的，例如：\n\n* for 循环\n* 集合类型和其扩展\n* list, dict, set类型的解析式\n* tuple类型的unpack\n* 对函数的*args形参进行unpack\n\n诸如此类的操作，都是iterable.\n\n通过例子我们再来探索一下\n\n```\nRE_WORD = re.compile(r'\\w+')\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __len__(self):\n        return len(self.words)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。\n```\n\n\n## How the iter(...) built-in function is used to internally to hanlde iterable objects.\n\n每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？\n这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。\n\niter()方法的使用规则：\n\n1. 检查对象是否实现了__ iter__方法，如果有，则调用得到一个iterator.\n2. 如果__ iter__ 方法没有被实现，但是对象实现了__ getitem__方法，那么Python会创建一个Iterator并按照顺序从0开始索引.\n3. 如果没有实现以上方法，或者操作失败。Python会抛出**TypeError**， 如：TypeError: 'Sentence' object is not iterable.\n\n而正是Python的序列对象都实现了 __ getitem__方法，所以它们都是可迭代的。（通常标准的sequences也会实现 __ iter__方法）\n\n\n## How to implement the classic Iterator pattern in Python.\niterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:\n\n```\ns = 'ABC'\nfor char in s:\n    print(char)\nA\nB\nC\n这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。\n\ns = 'ABC'\nit = iter(s)\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        del it\n        break\n```\n**StopIteration** 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。\n\n标准的iterator接口有两个方法：\n\n1.  __ next__  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。\n2.  __ iter__  返回自身；这样可用于for循环操作。\n\n当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了__ iter__ 方法，调用它也只能获得它本身，所以不可能进行重设操作。\n\n`iterator` 是指实现了__ next__ 和__ iter__方法的对象, __ next__ 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了__ iter__方法，所以iterator同时也是iterable。\n\n接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n    def __iter__(self):\n        return SentenceIterator(self.words)\n\n\nclass SentenceIterator(object):\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n```\n通过这个例子，可以看到： iterable实现了 __ iter__方法，每次调用会返回一个iterator实例。iterator对象实现了 __ next__ 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), __ iter__ 方法每次返回自身。\n因此，我们可以说**iterator是iterable，但是iterable不是iterator.**\n\n\n最后我们作出一个猜想： 我们可不可以在Sentence类里实现__ next__方法呢，使Sentence既是iterator也是iterable，岂不美哉？\n\n答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。\n\n**Iterator Pattern**里有一点：to support multiple traversals of aggregate objects.\n如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了__ next__方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。\n\n\n## Summary\n感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。\n\n本文代码链接:[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。\n\n值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念**generator**也与其有关。因为篇幅原因，我将其拆分为另一篇文章[a](a)，打铁要趁热！！！快来学习一下！！！\n\n\n","slug":"Python-Iterators-and-Iterables介绍","published":1,"updated":"2017-12-02T07:04:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqc001zlvtllye91exk","content":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行<strong>惰性</strong>读取，意味着每次操作只读取一条数据—–而这就是Iterator模式。</p>\n<h2 id=\"Iterables\"><a href=\"#Iterables\" class=\"headerlink\" title=\"Iterables\"></a>Iterables</h2><p><code>iterable</code>  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了<strong> iter</strong>方法并且返回一个iterator，那么称对象是iterable.</p>\n<p>在Python里所有的集合都是可迭代的，例如：</p>\n<ul>\n<li>for 循环</li>\n<li>集合类型和其扩展</li>\n<li>list, dict, set类型的解析式</li>\n<li>tuple类型的unpack</li>\n<li>对函数的*args形参进行unpack</li>\n</ul>\n<p>诸如此类的操作，都是iterable.</p>\n<p>通过例子我们再来探索一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __len__(self):</div><div class=\"line\">        return len(self.words)</div><div class=\"line\"></div><div class=\"line\">    def __getitem__(self, index):</div><div class=\"line\">        return self.words[index]</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\"><a href=\"#How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\" class=\"headerlink\" title=\"How the iter(…) built-in function is used to internally to hanlde iterable objects.\"></a>How the iter(…) built-in function is used to internally to hanlde iterable objects.</h2><p>每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？<br>这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。</p>\n<p>iter()方法的使用规则：</p>\n<ol>\n<li>检查对象是否实现了<strong> iter</strong>方法，如果有，则调用得到一个iterator.</li>\n<li>如果<strong> iter</strong> 方法没有被实现，但是对象实现了<strong> getitem</strong>方法，那么Python会创建一个Iterator并按照顺序从0开始索引.</li>\n<li>如果没有实现以上方法，或者操作失败。Python会抛出<strong>TypeError</strong>， 如：TypeError: ‘Sentence’ object is not iterable.</li>\n</ol>\n<p>而正是Python的序列对象都实现了 <strong> getitem</strong>方法，所以它们都是可迭代的。（通常标准的sequences也会实现 <strong> iter</strong>方法）</p>\n<h2 id=\"How-to-implement-the-classic-Iterator-pattern-in-Python\"><a href=\"#How-to-implement-the-classic-Iterator-pattern-in-Python\" class=\"headerlink\" title=\"How to implement the classic Iterator pattern in Python.\"></a>How to implement the classic Iterator pattern in Python.</h2><p>iterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">for char in s:</div><div class=\"line\">    print(char)</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\">这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。</div><div class=\"line\"></div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">it = iter(s)</div><div class=\"line\">while True:</div><div class=\"line\">    try:</div><div class=\"line\">        print(next(it))</div><div class=\"line\">    except StopIteration:</div><div class=\"line\">        del it</div><div class=\"line\">        break</div></pre></td></tr></table></figure>\n<p><strong>StopIteration</strong> 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。</p>\n<p>标准的iterator接口有两个方法：</p>\n<ol>\n<li><strong> next</strong>  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。</li>\n<li><strong> iter</strong>  返回自身；这样可用于for循环操作。</li>\n</ol>\n<p>当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了<strong> iter</strong> 方法，调用它也只能获得它本身，所以不可能进行重设操作。</p>\n<p><code>iterator</code> 是指实现了<strong> next</strong> 和<strong> iter</strong>方法的对象, <strong> next</strong> 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了<strong> iter</strong>方法，所以iterator同时也是iterable。</p>\n<p>接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return SentenceIterator(self.words)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class SentenceIterator(object):</div><div class=\"line\">    def __init__(self, words):</div><div class=\"line\">        self.words = words</div><div class=\"line\">        self.index = 0</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return self</div><div class=\"line\"></div><div class=\"line\">    def __next__(self):</div><div class=\"line\">        try:</div><div class=\"line\">            word = self.words[self.index]</div><div class=\"line\">        except IndexError:</div><div class=\"line\">            raise StopIteration()</div><div class=\"line\">        self.index += 1</div><div class=\"line\">        return word</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div></pre></td></tr></table></figure>\n<p>通过这个例子，可以看到： iterable实现了 <strong> iter</strong>方法，每次调用会返回一个iterator实例。iterator对象实现了 <strong> next</strong> 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), <strong> iter</strong> 方法每次返回自身。<br>因此，我们可以说<strong>iterator是iterable，但是iterable不是iterator.</strong></p>\n<p>最后我们作出一个猜想： 我们可不可以在Sentence类里实现<strong> next</strong>方法呢，使Sentence既是iterator也是iterable，岂不美哉？</p>\n<p>答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。</p>\n<p><strong>Iterator Pattern</strong>里有一点：to support multiple traversals of aggregate objects.<br>如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了<strong> next</strong>方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。</p>\n<p>本文代码链接:<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n<p>如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。</p>\n<p>值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念<strong>generator</strong>也与其有关。因为篇幅原因，我将其拆分为另一篇文章<a href=\"a\">a</a>，打铁要趁热！！！快来学习一下！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行<strong>惰性</strong>读取，意味着每次操作只读取一条数据—–而这就是Iterator模式。</p>\n<h2 id=\"Iterables\"><a href=\"#Iterables\" class=\"headerlink\" title=\"Iterables\"></a>Iterables</h2><p><code>iterable</code>  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了<strong> iter</strong>方法并且返回一个iterator，那么称对象是iterable.</p>\n<p>在Python里所有的集合都是可迭代的，例如：</p>\n<ul>\n<li>for 循环</li>\n<li>集合类型和其扩展</li>\n<li>list, dict, set类型的解析式</li>\n<li>tuple类型的unpack</li>\n<li>对函数的*args形参进行unpack</li>\n</ul>\n<p>诸如此类的操作，都是iterable.</p>\n<p>通过例子我们再来探索一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __len__(self):</div><div class=\"line\">        return len(self.words)</div><div class=\"line\"></div><div class=\"line\">    def __getitem__(self, index):</div><div class=\"line\">        return self.words[index]</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\"><a href=\"#How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects\" class=\"headerlink\" title=\"How the iter(…) built-in function is used to internally to hanlde iterable objects.\"></a>How the iter(…) built-in function is used to internally to hanlde iterable objects.</h2><p>每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？<br>这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。</p>\n<p>iter()方法的使用规则：</p>\n<ol>\n<li>检查对象是否实现了<strong> iter</strong>方法，如果有，则调用得到一个iterator.</li>\n<li>如果<strong> iter</strong> 方法没有被实现，但是对象实现了<strong> getitem</strong>方法，那么Python会创建一个Iterator并按照顺序从0开始索引.</li>\n<li>如果没有实现以上方法，或者操作失败。Python会抛出<strong>TypeError</strong>， 如：TypeError: ‘Sentence’ object is not iterable.</li>\n</ol>\n<p>而正是Python的序列对象都实现了 <strong> getitem</strong>方法，所以它们都是可迭代的。（通常标准的sequences也会实现 <strong> iter</strong>方法）</p>\n<h2 id=\"How-to-implement-the-classic-Iterator-pattern-in-Python\"><a href=\"#How-to-implement-the-classic-Iterator-pattern-in-Python\" class=\"headerlink\" title=\"How to implement the classic Iterator pattern in Python.\"></a>How to implement the classic Iterator pattern in Python.</h2><p>iterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">for char in s:</div><div class=\"line\">    print(char)</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\">这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。</div><div class=\"line\"></div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">it = iter(s)</div><div class=\"line\">while True:</div><div class=\"line\">    try:</div><div class=\"line\">        print(next(it))</div><div class=\"line\">    except StopIteration:</div><div class=\"line\">        del it</div><div class=\"line\">        break</div></pre></td></tr></table></figure>\n<p><strong>StopIteration</strong> 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。</p>\n<p>标准的iterator接口有两个方法：</p>\n<ol>\n<li><strong> next</strong>  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。</li>\n<li><strong> iter</strong>  返回自身；这样可用于for循环操作。</li>\n</ol>\n<p>当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了<strong> iter</strong> 方法，调用它也只能获得它本身，所以不可能进行重设操作。</p>\n<p><code>iterator</code> 是指实现了<strong> next</strong> 和<strong> iter</strong>方法的对象, <strong> next</strong> 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了<strong> iter</strong>方法，所以iterator同时也是iterable。</p>\n<p>接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return SentenceIterator(self.words)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class SentenceIterator(object):</div><div class=\"line\">    def __init__(self, words):</div><div class=\"line\">        self.words = words</div><div class=\"line\">        self.index = 0</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return self</div><div class=\"line\"></div><div class=\"line\">    def __next__(self):</div><div class=\"line\">        try:</div><div class=\"line\">            word = self.words[self.index]</div><div class=\"line\">        except IndexError:</div><div class=\"line\">            raise StopIteration()</div><div class=\"line\">        self.index += 1</div><div class=\"line\">        return word</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div></pre></td></tr></table></figure>\n<p>通过这个例子，可以看到： iterable实现了 <strong> iter</strong>方法，每次调用会返回一个iterator实例。iterator对象实现了 <strong> next</strong> 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), <strong> iter</strong> 方法每次返回自身。<br>因此，我们可以说<strong>iterator是iterable，但是iterable不是iterator.</strong></p>\n<p>最后我们作出一个猜想： 我们可不可以在Sentence类里实现<strong> next</strong>方法呢，使Sentence既是iterator也是iterable，岂不美哉？</p>\n<p>答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。</p>\n<p><strong>Iterator Pattern</strong>里有一点：to support multiple traversals of aggregate objects.<br>如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了<strong> next</strong>方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。</p>\n<p>本文代码链接:<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n<p>如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。</p>\n<p>值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念<strong>generator</strong>也与其有关。因为篇幅原因，我将其拆分为另一篇文章<a href=\"a\">a</a>，打铁要趁热！！！快来学习一下！！！</p>\n"},{"title":"Python generator 介绍","date":"2017-12-02T09:12:38.000Z","_content":"## Preface\nGenerator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：[http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/](http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/)\n\n\n\n## How a generator function works in detail, with line by line descriptions.\n介绍相关概念前，我们先看一个Pythonic的Iterator实现。\n\n```\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for word in self.words:\n            yield word\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n对比之前实现的例子，可以看到已经简洁很多了！！ \ntip: 最简洁的是 return iter(self.words)\n```\n\n在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。\n\n```\ndef gen_123():\n    yield 1\n    yield 2\n    yield 3\n\nprint(gen_123)\nprint(gen_123())\nfor i in gen_123():\n    print(i)\ng = gen_123()\nprint(next(g))\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n<function gen_123 at 0x10a6661e0>\n<generator object gen_123 at 0x10a5d8258>\n1\n2\n3\n1\n2\n3\nTraceback (most recent call last):\n  File \"/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py\", line 45, in <module>\n    print(next(g))\nStopIteration\n当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。\n```\n调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。\n\n明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick---lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。\n\n我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for match in RE_WORD.finditer(self.text):\n            yield match.group()\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n```\n\n\n\n## How the classic Iterator can be repalced by a generator function or generator expression.\n尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！\n\ngenerator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。\n\n```\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\nif __name__ == '__main__':\n    res1 = [x*3 for x in gen_AB()]\n    for i in res1:\n        print(i)\n    res2 = (x*3 for x in gen_AB())\n    for i in res2:\n        print(i)\nstart\ncontinue\nend.\nAAA\nBBB\n\n\nstart\nAAA\ncontinue\nBBB\nend.\n\n通过打印结果，可以验证generator expression是lazy的。\n```\n\n\ngenerator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n\n    def __iter__(self):\n        return (match.group() for match in RE_WORD.finditer(self.text))\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。\n```\n尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.\n\n\n最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？\n\n```\n\nclass ArithmeticProgression(object):\n    def __init__(self, begin, step, end=None):\n        self.begin = begin\n        self.step = step\n        self.end = end\n\n    def __iter__(self):\n        result = type(self.begin + self.step)(self.begin)\n        forever = self.end is None\n        index = 0\n        while forever or result < self.end:\n            yield result\n            index += 1\n            result = self.begin + self.step * index\nap1 = ArithmeticProgression(1, 0.5, 2)\nprint(list(ap1))\nap2 = ArithmeticProgression(1, 0.5)\nfor i in ap2:\n    print(i)\n\nap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。  \n```\n\n\n## Using the new yield from statement to combine generators\n\n当我们的generator需要从另一个generator得到值时，要如何操作呢？\n\n```\ndef chain(*iterables):\n    for it in iterables:\n        for i in it:\n            yield i\ns = 'ABC'\nt = tuple(range(3))\nprint(list(chain(s, t)))\n\n['A', 'B', 'C', 0, 1, 2]\n\n要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。\ndef chain(*iterables):\n    for it in iterables:\n        yield from it \n```\nyield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。\n\n\n## Summary\n最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。\n\n本章相关代码：\n[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n\n\n\n","source":"_posts/Python-generator-介绍.md","raw":"---\ntitle: Python generator 介绍\ndate: 2017-12-02 17:12:38\ntags: Python\n\n---\n## Preface\nGenerator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：[http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/](http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/)\n\n\n\n## How a generator function works in detail, with line by line descriptions.\n介绍相关概念前，我们先看一个Pythonic的Iterator实现。\n\n```\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for word in self.words:\n            yield word\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\nif __name__ == '__main__':\n    s = Sentence('\"The time has come,\" the Walrus said,')\n    print(s)\n    for word in s:\n        print(word)\n    print(list(s))\nSentence('\"The time ha... Walrus said,')\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']\n\n对比之前实现的例子，可以看到已经简洁很多了！！ \ntip: 最简洁的是 return iter(self.words)\n```\n\n在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。\n\n```\ndef gen_123():\n    yield 1\n    yield 2\n    yield 3\n\nprint(gen_123)\nprint(gen_123())\nfor i in gen_123():\n    print(i)\ng = gen_123()\nprint(next(g))\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n<function gen_123 at 0x10a6661e0>\n<generator object gen_123 at 0x10a5d8258>\n1\n2\n3\n1\n2\n3\nTraceback (most recent call last):\n  File \"/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py\", line 45, in <module>\n    print(next(g))\nStopIteration\n当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。\n```\n调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。\n\n明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick---lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。\n\n我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(self.text)\n\n    def __iter__(self):\n        for match in RE_WORD.finditer(self.text):\n            yield match.group()\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n\n```\n\n\n\n## How the classic Iterator can be repalced by a generator function or generator expression.\n尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！\n\ngenerator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。\n\n```\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\nif __name__ == '__main__':\n    res1 = [x*3 for x in gen_AB()]\n    for i in res1:\n        print(i)\n    res2 = (x*3 for x in gen_AB())\n    for i in res2:\n        print(i)\nstart\ncontinue\nend.\nAAA\nBBB\n\n\nstart\nAAA\ncontinue\nBBB\nend.\n\n通过打印结果，可以验证generator expression是lazy的。\n```\n\n\ngenerator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。\n\n```\nimport re\nimport reprlib\n\nRE_WORD = re.compile(r'\\w+')\n\n\nclass Sentence(object):\n    def __init__(self, text):\n        self.text = text\n\n    def __iter__(self):\n        return (match.group() for match in RE_WORD.finditer(self.text))\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.\n尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。\n```\n尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.\n\n\n最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？\n\n```\n\nclass ArithmeticProgression(object):\n    def __init__(self, begin, step, end=None):\n        self.begin = begin\n        self.step = step\n        self.end = end\n\n    def __iter__(self):\n        result = type(self.begin + self.step)(self.begin)\n        forever = self.end is None\n        index = 0\n        while forever or result < self.end:\n            yield result\n            index += 1\n            result = self.begin + self.step * index\nap1 = ArithmeticProgression(1, 0.5, 2)\nprint(list(ap1))\nap2 = ArithmeticProgression(1, 0.5)\nfor i in ap2:\n    print(i)\n\nap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。  \n```\n\n\n## Using the new yield from statement to combine generators\n\n当我们的generator需要从另一个generator得到值时，要如何操作呢？\n\n```\ndef chain(*iterables):\n    for it in iterables:\n        for i in it:\n            yield i\ns = 'ABC'\nt = tuple(range(3))\nprint(list(chain(s, t)))\n\n['A', 'B', 'C', 0, 1, 2]\n\n要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。\ndef chain(*iterables):\n    for it in iterables:\n        yield from it \n```\nyield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。\n\n\n## Summary\n最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。\n\n本章相关代码：\n[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo)\n\n\n\n\n","slug":"Python-generator-介绍","published":1,"updated":"2017-12-02T09:13:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqd0022lvtlq9y65mwz","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：<a href=\"http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/\">http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/</a></p>\n<h2 id=\"How-a-generator-function-works-in-detail-with-line-by-line-descriptions\"><a href=\"#How-a-generator-function-works-in-detail-with-line-by-line-descriptions\" class=\"headerlink\" title=\"How a generator function works in detail, with line by line descriptions.\"></a>How a generator function works in detail, with line by line descriptions.</h2><p>介绍相关概念前，我们先看一个Pythonic的Iterator实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for word in self.words:</div><div class=\"line\">            yield word</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">对比之前实现的例子，可以看到已经简洁很多了！！ </div><div class=\"line\">tip: 最简洁的是 return iter(self.words)</div></pre></td></tr></table></figure>\n<p>在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_123():</div><div class=\"line\">    yield 1</div><div class=\"line\">    yield 2</div><div class=\"line\">    yield 3</div><div class=\"line\"></div><div class=\"line\">print(gen_123)</div><div class=\"line\">print(gen_123())</div><div class=\"line\">for i in gen_123():</div><div class=\"line\">    print(i)</div><div class=\"line\">g = gen_123()</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\"></div><div class=\"line\">&lt;function gen_123 at 0x10a6661e0&gt;</div><div class=\"line\">&lt;generator object gen_123 at 0x10a5d8258&gt;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py&quot;, line 45, in &lt;module&gt;</div><div class=\"line\">    print(next(g))</div><div class=\"line\">StopIteration</div><div class=\"line\">当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。</div></pre></td></tr></table></figure>\n<p>调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。</p>\n<p>明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick—lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。</p>\n<p>我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for match in RE_WORD.finditer(self.text):</div><div class=\"line\">            yield match.group()</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\"><a href=\"#How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\" class=\"headerlink\" title=\"How the classic Iterator can be repalced by a generator function or generator expression.\"></a>How the classic Iterator can be repalced by a generator function or generator expression.</h2><p>尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！</p>\n<p>generator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_AB():</div><div class=\"line\">    print(&apos;start&apos;)</div><div class=\"line\">    yield &apos;A&apos;</div><div class=\"line\">    print(&apos;continue&apos;)</div><div class=\"line\">    yield &apos;B&apos;</div><div class=\"line\">    print(&apos;end.&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    res1 = [x*3 for x in gen_AB()]</div><div class=\"line\">    for i in res1:</div><div class=\"line\">        print(i)</div><div class=\"line\">    res2 = (x*3 for x in gen_AB())</div><div class=\"line\">    for i in res2:</div><div class=\"line\">        print(i)</div><div class=\"line\">start</div><div class=\"line\">continue</div><div class=\"line\">end.</div><div class=\"line\">AAA</div><div class=\"line\">BBB</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\">AAA</div><div class=\"line\">continue</div><div class=\"line\">BBB</div><div class=\"line\">end.</div><div class=\"line\"></div><div class=\"line\">通过打印结果，可以验证generator expression是lazy的。</div></pre></td></tr></table></figure>\n<p>generator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return (match.group() for match in RE_WORD.finditer(self.text))</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\">尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。</div></pre></td></tr></table></figure>\n<p>尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.</p>\n<p>最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class ArithmeticProgression(object):</div><div class=\"line\">    def __init__(self, begin, step, end=None):</div><div class=\"line\">        self.begin = begin</div><div class=\"line\">        self.step = step</div><div class=\"line\">        self.end = end</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        result = type(self.begin + self.step)(self.begin)</div><div class=\"line\">        forever = self.end is None</div><div class=\"line\">        index = 0</div><div class=\"line\">        while forever or result &lt; self.end:</div><div class=\"line\">            yield result</div><div class=\"line\">            index += 1</div><div class=\"line\">            result = self.begin + self.step * index</div><div class=\"line\">ap1 = ArithmeticProgression(1, 0.5, 2)</div><div class=\"line\">print(list(ap1))</div><div class=\"line\">ap2 = ArithmeticProgression(1, 0.5)</div><div class=\"line\">for i in ap2:</div><div class=\"line\">    print(i)</div><div class=\"line\"></div><div class=\"line\">ap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。</div></pre></td></tr></table></figure>\n<h2 id=\"Using-the-new-yield-from-statement-to-combine-generators\"><a href=\"#Using-the-new-yield-from-statement-to-combine-generators\" class=\"headerlink\" title=\"Using the new yield from statement to combine generators\"></a>Using the new yield from statement to combine generators</h2><p>当我们的generator需要从另一个generator得到值时，要如何操作呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        for i in it:</div><div class=\"line\">            yield i</div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">t = tuple(range(3))</div><div class=\"line\">print(list(chain(s, t)))</div><div class=\"line\"></div><div class=\"line\">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 0, 1, 2]</div><div class=\"line\"></div><div class=\"line\">要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。</div><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        yield from it</div></pre></td></tr></table></figure>\n<p>yield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。</p>\n<p>本章相关代码：<br><a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：<a href=\"http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/\">http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/</a></p>\n<h2 id=\"How-a-generator-function-works-in-detail-with-line-by-line-descriptions\"><a href=\"#How-a-generator-function-works-in-detail-with-line-by-line-descriptions\" class=\"headerlink\" title=\"How a generator function works in detail, with line by line descriptions.\"></a>How a generator function works in detail, with line by line descriptions.</h2><p>介绍相关概念前，我们先看一个Pythonic的Iterator实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for word in self.words:</div><div class=\"line\">            yield word</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class=\"line\">    print(s)</div><div class=\"line\">    for word in s:</div><div class=\"line\">        print(word)</div><div class=\"line\">    print(list(s))</div><div class=\"line\">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class=\"line\">The</div><div class=\"line\">time</div><div class=\"line\">has</div><div class=\"line\">come</div><div class=\"line\">the</div><div class=\"line\">Walrus</div><div class=\"line\">said</div><div class=\"line\">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class=\"line\"></div><div class=\"line\">对比之前实现的例子，可以看到已经简洁很多了！！ </div><div class=\"line\">tip: 最简洁的是 return iter(self.words)</div></pre></td></tr></table></figure>\n<p>在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_123():</div><div class=\"line\">    yield 1</div><div class=\"line\">    yield 2</div><div class=\"line\">    yield 3</div><div class=\"line\"></div><div class=\"line\">print(gen_123)</div><div class=\"line\">print(gen_123())</div><div class=\"line\">for i in gen_123():</div><div class=\"line\">    print(i)</div><div class=\"line\">g = gen_123()</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\">print(next(g))</div><div class=\"line\"></div><div class=\"line\">&lt;function gen_123 at 0x10a6661e0&gt;</div><div class=\"line\">&lt;generator object gen_123 at 0x10a5d8258&gt;</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py&quot;, line 45, in &lt;module&gt;</div><div class=\"line\">    print(next(g))</div><div class=\"line\">StopIteration</div><div class=\"line\">当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。</div></pre></td></tr></table></figure>\n<p>调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。</p>\n<p>明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick—lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。</p>\n<p>我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\">        self.words = RE_WORD.findall(self.text)</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        for match in RE_WORD.finditer(self.text):</div><div class=\"line\">            yield match.group()</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div></pre></td></tr></table></figure>\n<h2 id=\"How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\"><a href=\"#How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression\" class=\"headerlink\" title=\"How the classic Iterator can be repalced by a generator function or generator expression.\"></a>How the classic Iterator can be repalced by a generator function or generator expression.</h2><p>尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！</p>\n<p>generator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">def gen_AB():</div><div class=\"line\">    print(&apos;start&apos;)</div><div class=\"line\">    yield &apos;A&apos;</div><div class=\"line\">    print(&apos;continue&apos;)</div><div class=\"line\">    yield &apos;B&apos;</div><div class=\"line\">    print(&apos;end.&apos;)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    res1 = [x*3 for x in gen_AB()]</div><div class=\"line\">    for i in res1:</div><div class=\"line\">        print(i)</div><div class=\"line\">    res2 = (x*3 for x in gen_AB())</div><div class=\"line\">    for i in res2:</div><div class=\"line\">        print(i)</div><div class=\"line\">start</div><div class=\"line\">continue</div><div class=\"line\">end.</div><div class=\"line\">AAA</div><div class=\"line\">BBB</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">start</div><div class=\"line\">AAA</div><div class=\"line\">continue</div><div class=\"line\">BBB</div><div class=\"line\">end.</div><div class=\"line\"></div><div class=\"line\">通过打印结果，可以验证generator expression是lazy的。</div></pre></td></tr></table></figure>\n<p>generator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">import re</div><div class=\"line\">import reprlib</div><div class=\"line\"></div><div class=\"line\">RE_WORD = re.compile(r&apos;\\w+&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Sentence(object):</div><div class=\"line\">    def __init__(self, text):</div><div class=\"line\">        self.text = text</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        return (match.group() for match in RE_WORD.finditer(self.text))</div><div class=\"line\"></div><div class=\"line\">    def __repr__(self):</div><div class=\"line\">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class=\"line\">尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。</div></pre></td></tr></table></figure>\n<p>尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.</p>\n<p>最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class ArithmeticProgression(object):</div><div class=\"line\">    def __init__(self, begin, step, end=None):</div><div class=\"line\">        self.begin = begin</div><div class=\"line\">        self.step = step</div><div class=\"line\">        self.end = end</div><div class=\"line\"></div><div class=\"line\">    def __iter__(self):</div><div class=\"line\">        result = type(self.begin + self.step)(self.begin)</div><div class=\"line\">        forever = self.end is None</div><div class=\"line\">        index = 0</div><div class=\"line\">        while forever or result &lt; self.end:</div><div class=\"line\">            yield result</div><div class=\"line\">            index += 1</div><div class=\"line\">            result = self.begin + self.step * index</div><div class=\"line\">ap1 = ArithmeticProgression(1, 0.5, 2)</div><div class=\"line\">print(list(ap1))</div><div class=\"line\">ap2 = ArithmeticProgression(1, 0.5)</div><div class=\"line\">for i in ap2:</div><div class=\"line\">    print(i)</div><div class=\"line\"></div><div class=\"line\">ap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。</div></pre></td></tr></table></figure>\n<h2 id=\"Using-the-new-yield-from-statement-to-combine-generators\"><a href=\"#Using-the-new-yield-from-statement-to-combine-generators\" class=\"headerlink\" title=\"Using the new yield from statement to combine generators\"></a>Using the new yield from statement to combine generators</h2><p>当我们的generator需要从另一个generator得到值时，要如何操作呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        for i in it:</div><div class=\"line\">            yield i</div><div class=\"line\">s = &apos;ABC&apos;</div><div class=\"line\">t = tuple(range(3))</div><div class=\"line\">print(list(chain(s, t)))</div><div class=\"line\"></div><div class=\"line\">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 0, 1, 2]</div><div class=\"line\"></div><div class=\"line\">要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。</div><div class=\"line\">def chain(*iterables):</div><div class=\"line\">    for it in iterables:</div><div class=\"line\">        yield from it</div></pre></td></tr></table></figure>\n<p>yield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。</p>\n<p>本章相关代码：<br><a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>\n"},{"title":"Python Function Decorators and Closures介绍","date":"2017-11-29T08:17:13.000Z","_content":"\n\n## Preface\n本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. **注意**本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。\n\n## How Python evaluates decorator syntax?\nPython对装饰器的使用了语法糖，如：\n\n```\n@decorate\ndef target():\n    print('Running target()')\n\ndef target():\n    print('Running target()')\ntarget = decorate(target)\n```\n二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。\n\n## When Python executes decorators?\n首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。\n装饰器是在import time被执行的，我们来看一个例子：\n\n```\nregistry = []\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('Running f1()')\n\n@register\ndef f2():\n    print('Running f2()')\n\ndef main():\n    print('running main')\n    print('registry ->', registry)\n    f1()\n    f2()\nif __name__ == '__main__':\n    main()\n------------------------------------------------------------------------    \nrunning register(<function f1 at 0x100c70158>)\nrunning register(<function f2 at 0x100c701e0>)\nrunning main\nregistry -> [<function f1 at 0x100c70158>, <function f2 at 0x100c701e0>]\nRunning f1()\nRunning f2()\n```\n通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。\n## How Python decides whether a variable is local?\n**Variable scope rules**这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。\n\n```\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n3\nNameError: name 'b' is not defined\nb = 6\nf1(3)\n3\n6\n\n接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\nf2(3)\n3\nUnboundLocalError: local variable 'b' referenced before assignment\n希望你可以先思考一下为什么没有打印出6。\n事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，\nprint()时发现b还未被赋值，所以抛出了错误。\n我们再通过字节码来确认一下是不是这样。\n\nprint(dis.dis(f1))\n  5           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n  6          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_GLOBAL              1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n             20 LOAD_CONST               0 (None)\n             23 RETURN_VALUE\n\nprint(dis.dis(f2))\n  9           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n 10          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_FAST                1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n\n 11          20 LOAD_CONST               1 (9)\n             23 STORE_FAST               1 (b)\n             26 LOAD_CONST               0 (None)\n对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。\n```\n如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。\n\n\n\n## Why closures exist and how they work?\n\n**闭包**，老样子，我们还是先思考一个例子。\n假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。\n\n```\n它的实现结果看起来应该是这样的\navg(10)\n10.0\navg(11)\n10.5\navg(12)\n11.0\n\n如果你已经思考过怎么实现这个函数了，那么继续往下看吧。\n\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n```\n我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是\nmake_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，\n并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？\n\npython里有个概念是**free variable**，而avarager里的series就是**free variable**.我们可以打印出来看看是不是这样。\n\n```\n    print(avg.__code__.co_varnames)\n    print(avg.__code__.co_freevars)\n    print(avg.__closure__[0].cell_contents)\n('new_value', 'total')\n('series',)\n[10, 11, 12]\n\n```\n可以看到，确实存在**free variable**这个属性，并且值是series.\n\n**总结一下**\n闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。\n\n\n## What problem is solved by nonlocal?\n爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        total += new_value\n        count += 1\n        return total / count\n    return averager\n\nif __name__ == '__main__':\n    avg = make_averager()\n    avg(10)    \n>>> UnboundLocalError: local variable 'total' referenced before assignment\n\n因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，\n根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量\n而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series\n一直是avg的自由变量。\n```\n所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal total, count\n        total += new_value\n        count += 1\n        return total / count\n    return averager\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n10.0\n10.5\n11.0\n```\n\n## Implementing a simple decorator\n\n通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。\n\n```\nimport time\n\ndef clock(func):\n    series = []\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\nprint('*' * 40, 'Calling snooze(0.123)')\nsnooze(.123)\n\n>>>**************************************** Calling snooze(0.123)\n>>>[0.12566963s] snooze (0.123) -> None\n\nprint(snooze.__name__)\nclocked\n\n如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()\n\ndef clock(func):\n    series = []\n    @functools.wraps(func)\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n\n    return clocked\n像上面这样的使用，就能消除装饰器的影响了。\n```\n\n## Summary\n感谢阅读，希望你能从这篇文章中有所收获。\n如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。\n\n本文的代码链接：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators)\n","source":"_posts/Python-Function-Decorators-and-Closures介绍.md","raw":"---\ntitle: Python Function Decorators and Closures介绍\ndate: 2017-11-29 16:17:13\ntags: Python\n\n---\n\n\n## Preface\n本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. **注意**本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。\n\n## How Python evaluates decorator syntax?\nPython对装饰器的使用了语法糖，如：\n\n```\n@decorate\ndef target():\n    print('Running target()')\n\ndef target():\n    print('Running target()')\ntarget = decorate(target)\n```\n二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。\n\n## When Python executes decorators?\n首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。\n装饰器是在import time被执行的，我们来看一个例子：\n\n```\nregistry = []\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('Running f1()')\n\n@register\ndef f2():\n    print('Running f2()')\n\ndef main():\n    print('running main')\n    print('registry ->', registry)\n    f1()\n    f2()\nif __name__ == '__main__':\n    main()\n------------------------------------------------------------------------    \nrunning register(<function f1 at 0x100c70158>)\nrunning register(<function f2 at 0x100c701e0>)\nrunning main\nregistry -> [<function f1 at 0x100c70158>, <function f2 at 0x100c701e0>]\nRunning f1()\nRunning f2()\n```\n通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。\n## How Python decides whether a variable is local?\n**Variable scope rules**这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。\n\n```\ndef f1(a):\n    print(a)\n    print(b)\n\nf1(3)\n3\nNameError: name 'b' is not defined\nb = 6\nf1(3)\n3\n6\n\n接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。\ndef f2(a):\n    print(a)\n    print(b)\n    b = 9\nf2(3)\n3\nUnboundLocalError: local variable 'b' referenced before assignment\n希望你可以先思考一下为什么没有打印出6。\n事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，\nprint()时发现b还未被赋值，所以抛出了错误。\n我们再通过字节码来确认一下是不是这样。\n\nprint(dis.dis(f1))\n  5           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n  6          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_GLOBAL              1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n             20 LOAD_CONST               0 (None)\n             23 RETURN_VALUE\n\nprint(dis.dis(f2))\n  9           0 LOAD_GLOBAL              0 (print)\n              3 LOAD_FAST                0 (a)\n              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n              9 POP_TOP\n\n 10          10 LOAD_GLOBAL              0 (print)\n             13 LOAD_FAST                1 (b)\n             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)\n             19 POP_TOP\n\n 11          20 LOAD_CONST               1 (9)\n             23 STORE_FAST               1 (b)\n             26 LOAD_CONST               0 (None)\n对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。\n```\n如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。\n\n\n\n## Why closures exist and how they work?\n\n**闭包**，老样子，我们还是先思考一个例子。\n假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。\n\n```\n它的实现结果看起来应该是这样的\navg(10)\n10.0\navg(11)\n10.5\navg(12)\n11.0\n\n如果你已经思考过怎么实现这个函数了，那么继续往下看吧。\n\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n```\n我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是\nmake_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，\n并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？\n\npython里有个概念是**free variable**，而avarager里的series就是**free variable**.我们可以打印出来看看是不是这样。\n\n```\n    print(avg.__code__.co_varnames)\n    print(avg.__code__.co_freevars)\n    print(avg.__closure__[0].cell_contents)\n('new_value', 'total')\n('series',)\n[10, 11, 12]\n\n```\n可以看到，确实存在**free variable**这个属性，并且值是series.\n\n**总结一下**\n闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。\n\n\n## What problem is solved by nonlocal?\n爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        total += new_value\n        count += 1\n        return total / count\n    return averager\n\nif __name__ == '__main__':\n    avg = make_averager()\n    avg(10)    \n>>> UnboundLocalError: local variable 'total' referenced before assignment\n\n因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，\n根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量\n而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series\n一直是avg的自由变量。\n```\n所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。\n\n```\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal total, count\n        total += new_value\n        count += 1\n        return total / count\n    return averager\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n\n10.0\n10.5\n11.0\n```\n\n## Implementing a simple decorator\n\n通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。\n\n```\nimport time\n\ndef clock(func):\n    series = []\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n    return clocked\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\nprint('*' * 40, 'Calling snooze(0.123)')\nsnooze(.123)\n\n>>>**************************************** Calling snooze(0.123)\n>>>[0.12566963s] snooze (0.123) -> None\n\nprint(snooze.__name__)\nclocked\n\n如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()\n\ndef clock(func):\n    series = []\n    @functools.wraps(func)\n    def clocked(*args):\n        t0 = time.perf_counter()\n        series.append(func)\n        _result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s (%s) -> %r ' % (elapsed, name, arg_str, _result))\n        return _result\n\n    return clocked\n像上面这样的使用，就能消除装饰器的影响了。\n```\n\n## Summary\n感谢阅读，希望你能从这篇文章中有所收获。\n如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。\n\n本文的代码链接：[https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators)\n","slug":"Python-Function-Decorators-and-Closures介绍","published":1,"updated":"2017-11-29T08:22:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqd0024lvtl18uy4ccj","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. <strong>注意</strong>本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。</p>\n<h2 id=\"How-Python-evaluates-decorator-syntax\"><a href=\"#How-Python-evaluates-decorator-syntax\" class=\"headerlink\" title=\"How Python evaluates decorator syntax?\"></a>How Python evaluates decorator syntax?</h2><p>Python对装饰器的使用了语法糖，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@decorate</div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\"></div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\">target = decorate(target)</div></pre></td></tr></table></figure>\n<p>二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。</p>\n<h2 id=\"When-Python-executes-decorators\"><a href=\"#When-Python-executes-decorators\" class=\"headerlink\" title=\"When Python executes decorators?\"></a>When Python executes decorators?</h2><p>首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。<br>装饰器是在import time被执行的，我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">registry = []</div><div class=\"line\">def register(func):</div><div class=\"line\">    print(&apos;running register(%s)&apos; % func)</div><div class=\"line\">    registry.append(func)</div><div class=\"line\">    return func</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f1():</div><div class=\"line\">    print(&apos;Running f1()&apos;)</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f2():</div><div class=\"line\">    print(&apos;Running f2()&apos;)</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print(&apos;running main&apos;)</div><div class=\"line\">    print(&apos;registry -&gt;&apos;, registry)</div><div class=\"line\">    f1()</div><div class=\"line\">    f2()</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">------------------------------------------------------------------------    </div><div class=\"line\">running register(&lt;function f1 at 0x100c70158&gt;)</div><div class=\"line\">running register(&lt;function f2 at 0x100c701e0&gt;)</div><div class=\"line\">running main</div><div class=\"line\">registry -&gt; [&lt;function f1 at 0x100c70158&gt;, &lt;function f2 at 0x100c701e0&gt;]</div><div class=\"line\">Running f1()</div><div class=\"line\">Running f2()</div></pre></td></tr></table></figure>\n<p>通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。</p>\n<h2 id=\"How-Python-decides-whether-a-variable-is-local\"><a href=\"#How-Python-decides-whether-a-variable-is-local\" class=\"headerlink\" title=\"How Python decides whether a variable is local?\"></a>How Python decides whether a variable is local?</h2><p><strong>Variable scope rules</strong>这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\"></div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">NameError: name &apos;b&apos; is not defined</div><div class=\"line\">b = 6</div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。</div><div class=\"line\">def f2(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\">    b = 9</div><div class=\"line\">f2(3)</div><div class=\"line\">3</div><div class=\"line\">UnboundLocalError: local variable &apos;b&apos; referenced before assignment</div><div class=\"line\">希望你可以先思考一下为什么没有打印出6。</div><div class=\"line\">事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，</div><div class=\"line\">print()时发现b还未被赋值，所以抛出了错误。</div><div class=\"line\">我们再通过字节码来确认一下是不是这样。</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f1))</div><div class=\"line\">  5           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\">  6          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_GLOBAL              1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\">             20 LOAD_CONST               0 (None)</div><div class=\"line\">             23 RETURN_VALUE</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f2))</div><div class=\"line\">  9           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 10          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_FAST                1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 11          20 LOAD_CONST               1 (9)</div><div class=\"line\">             23 STORE_FAST               1 (b)</div><div class=\"line\">             26 LOAD_CONST               0 (None)</div><div class=\"line\">对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。</div></pre></td></tr></table></figure>\n<p>如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。</p>\n<h2 id=\"Why-closures-exist-and-how-they-work\"><a href=\"#Why-closures-exist-and-how-they-work\" class=\"headerlink\" title=\"Why closures exist and how they work?\"></a>Why closures exist and how they work?</h2><p><strong>闭包</strong>，老样子，我们还是先思考一个例子。<br>假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">它的实现结果看起来应该是这样的</div><div class=\"line\">avg(10)</div><div class=\"line\">10.0</div><div class=\"line\">avg(11)</div><div class=\"line\">10.5</div><div class=\"line\">avg(12)</div><div class=\"line\">11.0</div><div class=\"line\"></div><div class=\"line\">如果你已经思考过怎么实现这个函数了，那么继续往下看吧。</div><div class=\"line\"></div><div class=\"line\">def make_averager():</div><div class=\"line\">    series = []</div><div class=\"line\"></div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        series.append(new_value)</div><div class=\"line\">        total = sum(series)</div><div class=\"line\">        return total / len(series)</div><div class=\"line\"></div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div></pre></td></tr></table></figure>\n<p>我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是<br>make_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，<br>并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？</p>\n<p>python里有个概念是<strong>free variable</strong>，而avarager里的series就是<strong>free variable</strong>.我们可以打印出来看看是不是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    print(avg.__code__.co_varnames)</div><div class=\"line\">    print(avg.__code__.co_freevars)</div><div class=\"line\">    print(avg.__closure__[0].cell_contents)</div><div class=\"line\">(&apos;new_value&apos;, &apos;total&apos;)</div><div class=\"line\">(&apos;series&apos;,)</div><div class=\"line\">[10, 11, 12]</div></pre></td></tr></table></figure>\n<p>可以看到，确实存在<strong>free variable</strong>这个属性，并且值是series.</p>\n<p><strong>总结一下</strong><br>闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。</p>\n<h2 id=\"What-problem-is-solved-by-nonlocal\"><a href=\"#What-problem-is-solved-by-nonlocal\" class=\"headerlink\" title=\"What problem is solved by nonlocal?\"></a>What problem is solved by nonlocal?</h2><p>爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    avg = make_averager()</div><div class=\"line\">    avg(10)    </div><div class=\"line\">&gt;&gt;&gt; UnboundLocalError: local variable &apos;total&apos; referenced before assignment</div><div class=\"line\"></div><div class=\"line\">因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，</div><div class=\"line\">根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量</div><div class=\"line\">而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series</div><div class=\"line\">一直是avg的自由变量。</div></pre></td></tr></table></figure>\n<p>所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        nonlocal total, count</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div><div class=\"line\"></div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div></pre></td></tr></table></figure>\n<h2 id=\"Implementing-a-simple-decorator\"><a href=\"#Implementing-a-simple-decorator\" class=\"headerlink\" title=\"Implementing a simple decorator\"></a>Implementing a simple decorator</h2><p>通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\">    return clocked</div><div class=\"line\"></div><div class=\"line\">@clock</div><div class=\"line\">def snooze(seconds):</div><div class=\"line\">    time.sleep(seconds)</div><div class=\"line\"></div><div class=\"line\">print(&apos;*&apos; * 40, &apos;Calling snooze(0.123)&apos;)</div><div class=\"line\">snooze(.123)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;**************************************** Calling snooze(0.123)</div><div class=\"line\">&gt;&gt;&gt;[0.12566963s] snooze (0.123) -&gt; None</div><div class=\"line\"></div><div class=\"line\">print(snooze.__name__)</div><div class=\"line\">clocked</div><div class=\"line\"></div><div class=\"line\">如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\"></div><div class=\"line\">    return clocked</div><div class=\"line\">像上面这样的使用，就能消除装饰器的影响了。</div></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你能从这篇文章中有所收获。<br>如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。</p>\n<p>本文的代码链接：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. <strong>注意</strong>本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。</p>\n<h2 id=\"How-Python-evaluates-decorator-syntax\"><a href=\"#How-Python-evaluates-decorator-syntax\" class=\"headerlink\" title=\"How Python evaluates decorator syntax?\"></a>How Python evaluates decorator syntax?</h2><p>Python对装饰器的使用了语法糖，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@decorate</div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\"></div><div class=\"line\">def target():</div><div class=\"line\">    print(&apos;Running target()&apos;)</div><div class=\"line\">target = decorate(target)</div></pre></td></tr></table></figure>\n<p>二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。</p>\n<h2 id=\"When-Python-executes-decorators\"><a href=\"#When-Python-executes-decorators\" class=\"headerlink\" title=\"When Python executes decorators?\"></a>When Python executes decorators?</h2><p>首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。<br>装饰器是在import time被执行的，我们来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">registry = []</div><div class=\"line\">def register(func):</div><div class=\"line\">    print(&apos;running register(%s)&apos; % func)</div><div class=\"line\">    registry.append(func)</div><div class=\"line\">    return func</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f1():</div><div class=\"line\">    print(&apos;Running f1()&apos;)</div><div class=\"line\"></div><div class=\"line\">@register</div><div class=\"line\">def f2():</div><div class=\"line\">    print(&apos;Running f2()&apos;)</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print(&apos;running main&apos;)</div><div class=\"line\">    print(&apos;registry -&gt;&apos;, registry)</div><div class=\"line\">    f1()</div><div class=\"line\">    f2()</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">------------------------------------------------------------------------    </div><div class=\"line\">running register(&lt;function f1 at 0x100c70158&gt;)</div><div class=\"line\">running register(&lt;function f2 at 0x100c701e0&gt;)</div><div class=\"line\">running main</div><div class=\"line\">registry -&gt; [&lt;function f1 at 0x100c70158&gt;, &lt;function f2 at 0x100c701e0&gt;]</div><div class=\"line\">Running f1()</div><div class=\"line\">Running f2()</div></pre></td></tr></table></figure>\n<p>通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。</p>\n<h2 id=\"How-Python-decides-whether-a-variable-is-local\"><a href=\"#How-Python-decides-whether-a-variable-is-local\" class=\"headerlink\" title=\"How Python decides whether a variable is local?\"></a>How Python decides whether a variable is local?</h2><p><strong>Variable scope rules</strong>这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">def f1(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\"></div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">NameError: name &apos;b&apos; is not defined</div><div class=\"line\">b = 6</div><div class=\"line\">f1(3)</div><div class=\"line\">3</div><div class=\"line\">6</div><div class=\"line\"></div><div class=\"line\">接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。</div><div class=\"line\">def f2(a):</div><div class=\"line\">    print(a)</div><div class=\"line\">    print(b)</div><div class=\"line\">    b = 9</div><div class=\"line\">f2(3)</div><div class=\"line\">3</div><div class=\"line\">UnboundLocalError: local variable &apos;b&apos; referenced before assignment</div><div class=\"line\">希望你可以先思考一下为什么没有打印出6。</div><div class=\"line\">事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，</div><div class=\"line\">print()时发现b还未被赋值，所以抛出了错误。</div><div class=\"line\">我们再通过字节码来确认一下是不是这样。</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f1))</div><div class=\"line\">  5           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\">  6          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_GLOBAL              1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\">             20 LOAD_CONST               0 (None)</div><div class=\"line\">             23 RETURN_VALUE</div><div class=\"line\"></div><div class=\"line\">print(dis.dis(f2))</div><div class=\"line\">  9           0 LOAD_GLOBAL              0 (print)</div><div class=\"line\">              3 LOAD_FAST                0 (a)</div><div class=\"line\">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">              9 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 10          10 LOAD_GLOBAL              0 (print)</div><div class=\"line\">             13 LOAD_FAST                1 (b)</div><div class=\"line\">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class=\"line\">             19 POP_TOP</div><div class=\"line\"></div><div class=\"line\"> 11          20 LOAD_CONST               1 (9)</div><div class=\"line\">             23 STORE_FAST               1 (b)</div><div class=\"line\">             26 LOAD_CONST               0 (None)</div><div class=\"line\">对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。</div></pre></td></tr></table></figure>\n<p>如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。</p>\n<h2 id=\"Why-closures-exist-and-how-they-work\"><a href=\"#Why-closures-exist-and-how-they-work\" class=\"headerlink\" title=\"Why closures exist and how they work?\"></a>Why closures exist and how they work?</h2><p><strong>闭包</strong>，老样子，我们还是先思考一个例子。<br>假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">它的实现结果看起来应该是这样的</div><div class=\"line\">avg(10)</div><div class=\"line\">10.0</div><div class=\"line\">avg(11)</div><div class=\"line\">10.5</div><div class=\"line\">avg(12)</div><div class=\"line\">11.0</div><div class=\"line\"></div><div class=\"line\">如果你已经思考过怎么实现这个函数了，那么继续往下看吧。</div><div class=\"line\"></div><div class=\"line\">def make_averager():</div><div class=\"line\">    series = []</div><div class=\"line\"></div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        series.append(new_value)</div><div class=\"line\">        total = sum(series)</div><div class=\"line\">        return total / len(series)</div><div class=\"line\"></div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div></pre></td></tr></table></figure>\n<p>我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是<br>make_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，<br>并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？</p>\n<p>python里有个概念是<strong>free variable</strong>，而avarager里的series就是<strong>free variable</strong>.我们可以打印出来看看是不是这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">    print(avg.__code__.co_varnames)</div><div class=\"line\">    print(avg.__code__.co_freevars)</div><div class=\"line\">    print(avg.__closure__[0].cell_contents)</div><div class=\"line\">(&apos;new_value&apos;, &apos;total&apos;)</div><div class=\"line\">(&apos;series&apos;,)</div><div class=\"line\">[10, 11, 12]</div></pre></td></tr></table></figure>\n<p>可以看到，确实存在<strong>free variable</strong>这个属性，并且值是series.</p>\n<p><strong>总结一下</strong><br>闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。</p>\n<h2 id=\"What-problem-is-solved-by-nonlocal\"><a href=\"#What-problem-is-solved-by-nonlocal\" class=\"headerlink\" title=\"What problem is solved by nonlocal?\"></a>What problem is solved by nonlocal?</h2><p>爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    avg = make_averager()</div><div class=\"line\">    avg(10)    </div><div class=\"line\">&gt;&gt;&gt; UnboundLocalError: local variable &apos;total&apos; referenced before assignment</div><div class=\"line\"></div><div class=\"line\">因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，</div><div class=\"line\">根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量</div><div class=\"line\">而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series</div><div class=\"line\">一直是avg的自由变量。</div></pre></td></tr></table></figure>\n<p>所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">def make_averager():</div><div class=\"line\">    count = 0</div><div class=\"line\">    total = 0</div><div class=\"line\">    def averager(new_value):</div><div class=\"line\">        nonlocal total, count</div><div class=\"line\">        total += new_value</div><div class=\"line\">        count += 1</div><div class=\"line\">        return total / count</div><div class=\"line\">    return averager</div><div class=\"line\">avg = make_averager()</div><div class=\"line\">print(avg(10))</div><div class=\"line\">print(avg(11))</div><div class=\"line\">print(avg(12))</div><div class=\"line\"></div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div></pre></td></tr></table></figure>\n<h2 id=\"Implementing-a-simple-decorator\"><a href=\"#Implementing-a-simple-decorator\" class=\"headerlink\" title=\"Implementing a simple decorator\"></a>Implementing a simple decorator</h2><p>通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">import time</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\">    return clocked</div><div class=\"line\"></div><div class=\"line\">@clock</div><div class=\"line\">def snooze(seconds):</div><div class=\"line\">    time.sleep(seconds)</div><div class=\"line\"></div><div class=\"line\">print(&apos;*&apos; * 40, &apos;Calling snooze(0.123)&apos;)</div><div class=\"line\">snooze(.123)</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt;**************************************** Calling snooze(0.123)</div><div class=\"line\">&gt;&gt;&gt;[0.12566963s] snooze (0.123) -&gt; None</div><div class=\"line\"></div><div class=\"line\">print(snooze.__name__)</div><div class=\"line\">clocked</div><div class=\"line\"></div><div class=\"line\">如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()</div><div class=\"line\"></div><div class=\"line\">def clock(func):</div><div class=\"line\">    series = []</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def clocked(*args):</div><div class=\"line\">        t0 = time.perf_counter()</div><div class=\"line\">        series.append(func)</div><div class=\"line\">        _result = func(*args)</div><div class=\"line\">        elapsed = time.perf_counter() - t0</div><div class=\"line\">        name = func.__name__</div><div class=\"line\">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class=\"line\">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class=\"line\">        return _result</div><div class=\"line\"></div><div class=\"line\">    return clocked</div><div class=\"line\">像上面这样的使用，就能消除装饰器的影响了。</div></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>感谢阅读，希望你能从这篇文章中有所收获。<br>如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。</p>\n<p>本文的代码链接：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators</a></p>\n"},{"title":"python实现计算机网络rip协议 Report","date":"2017-06-01T07:27:45.000Z","_content":"一、实验目的\n\n\n了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。\n\n\n二、打印结果\n\n\n输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 \n\n\n\n\n输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。\n\n\n\n\n输入第二个路由器的路由表。\n\n\n\n\n遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。\n\n\n三、程序代码\n\n\ngithub:\nhttps://github.com/Miksztowi/CorePython/blob/master/rip.py\n\n","source":"_posts/python实现计算机网络rip协议.md","raw":"---\ntitle: python实现计算机网络rip协议 Report\ndate: 2017-06-01 15:27:45\ntags: daily report\n---\n一、实验目的\n\n\n了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。\n\n\n二、打印结果\n\n\n输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 \n\n\n\n\n输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。\n\n\n\n\n输入第二个路由器的路由表。\n\n\n\n\n遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。\n\n\n三、程序代码\n\n\ngithub:\nhttps://github.com/Miksztowi/CorePython/blob/master/rip.py\n\n","slug":"python实现计算机网络rip协议","published":1,"updated":"2017-11-04T09:32:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqe0026lvtlhf6bnnlv","content":"<p>一、实验目的</p>\n<p>了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。</p>\n<p>二、打印结果</p>\n<p>输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 </p>\n<p>输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。</p>\n<p>输入第二个路由器的路由表。</p>\n<p>遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。</p>\n<p>三、程序代码</p>\n<p>github:<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/rip.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/rip.py</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、实验目的</p>\n<p>了解RIP协议的原理和应用等相关知识，通过距离矢量算法来实现最短传输路径的路由选择。通过本次课程设计，可以对RIP协议的工作原理和实现机制，路由表的建立和路由信息的更新等有更直观和清晰的认识。</p>\n<p>二、打印结果</p>\n<p>输入路由器数量，之后输入路由器邻接矩阵，表示路由器的连接关系，1为相邻，0为不相邻。 </p>\n<p>输入第一个路由器的路由表，首先输入表的长度，之后输入数据，数据格式为目的网络，距离长度，下一跳路由器。</p>\n<p>输入第二个路由器的路由表。</p>\n<p>遍历打印每一个当前路由器的修改时间，修改前的当前表，和接受的相邻路由表以及更新后的当前路由表。</p>\n<p>三、程序代码</p>\n<p>github:<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/rip.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/rip.py</a></p>\n"},{"title":"Python Coroutine介绍","date":"2017-12-11T06:58:15.000Z","_content":"\n\n## Concept\n通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。\n\n在coroutine里\n\n1. yield item通常放在=的右边，比如datum = yield item，item可以为None.\n2. 对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。\n3. yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。\n4. 增加了.throw()和.close()方法来扩展caller对coroutine的控制。\n\n\n## The behavior and states of a generator operating as a coroutine.\n\n我们先看一个基础的coroutine demo。\n\n```\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nmy_coro = simple_generator()\nprint(my_coro)\n<generator object simple_generator at 0x1093572b0>\nnext(my_coro)\nmy_coro.send(42)\n\n注意这里传递值时使用了.send()\n```\n看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。\n\ncoroutine只有四种状态：\n\n1. 'GEN_CREATED' 此时等待开始操作。\n2. 'GEN_RUINNING' 当前正在被解释器执行。\n3. 'GEN_SUSPENDED' 当前被一条yield语句挂起。\n4. 'GEN_CLOSED' coroutine已经全部执行完毕。\n\n通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在'GEN_CREATED'状态的coroutine里是无法操作的。\n`TypeError: can't send non-None value to a just-started generator`, 此时需要先通过next()来唤醒。\n\n接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。\n\n```\nfrom inspect import getgeneratorstate\ndef simple_coro2(a):\n    print('-> started: a =', a)\n    b = yield a\n    print('-> received: b =', b)\n    c = yield a + b\n    print('-> received: c = ', c)\n\nif __name__ == '__main__':\n    my_coro2 = simple_coro2(10)\n    print(getgeneratorstate(my_coro2))\n    next(my_coro2)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(20)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(30)\n    \nGEN_CREATED\n-> started: a = 10\nGEN_SUSPENDED\n-> received: b = 20\nGEN_SUSPENDED\n-> received: c =  30\nTraceback (most recent call last):\nStopIteration\n\n通过打印，看到代码运行的流程跟我们的答案符合。\n```\n\n顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，\n所以’b = yield a‘中b的只有caller唤醒后才会赋值。\n\n\n接下来，我们来看一下如何终止一个coroutine.\n\n```\ndef averager():\n    total = count = 0\n    average = None\n    while True:  # 注意看这里，这意味着这个循环会一直进行下去。\n        term = yield average\n        total += term\n        count += 1\n        average = total / count\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send(12))\ncoro_avg.close()\n10.0\n10.5\n11.0\n调用.close()后，将其终止。\nprint(coro_avg.send(14))\nTraceback (most recent call last):\n    print(coro_avg.send(14))\nStopIteration\n调用已经终止的coroutine会抛出Stopiteration的异常。\n```\n\n## Priming a coroutine automaticall with a decorator.\n通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于'慵懒'的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！\n\n```\nfrom functools import wraps\nfrom inspect import getgeneratorstate\n\ndef coroutine(func):\n    @wraps(func)\n    def primer(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n    return primer\n\n@coroutine\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nif __name__ == '__main__':\n    my_coro = simple_generator()\n    print(getgeneratorstate(my_coro))\n    print(my_coro.send(10))\ncoroutine start.\nGEN_SUSPENDED # 已经是挂起状态了!\ncoroutine received  10\n```\n我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！\n\n## How the caller can control a coroutine through .close() and .throw() methods of the generator object.\n对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？\n\n```\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send('a'))\n10.0\n10.5\nTypeError: unsupported operand type(s) for +=: 'int' and 'str'\ncoro_avg.send(12)\nStopIteration    ## 后续的调用会抛出Stopiteration的异常。\n```\n当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。\n所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)\n\n当然，generator对象有两种方法可以发送异常。\n\n1. generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。\n2. generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。\n\n介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。\n\n```\nfrom inspect import getgeneratorstate\nclass DemoException(Exception):\n    \"\"\"\"An exception type for the  demonstration.\"\"\"\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Continuing...')\n        else:\n            print('-> coroutine received: {!r}'.format(x))\n\n    raise RuntimeError('This line should never run.')\nexc_coro = demo_exc_handling()\nnext(exc_coro)\n\n\t# Demo 1\n\tprint(exc_coro.send(11))\n\tprint(exc_coro.send(22))\n\texc_coro.close()\n\tprint(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\nGEN_CLOSED\n\n    # Demo 2\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\n\n    # Demo 3\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(ZeroDivisionError)\n    print(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n'GEN_CLOSED'\n```\n\n注意看上面三种异常的打印，以及异常发生后的generator的状态。\n\n如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。\n\n```\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Continuing...')\n            else:\n                print('-> coroutine received: {!r}'.format(x))\n    finally:\n        print('Coroutine ending...')\n    raise RuntimeError('This line should never run.')\n    \n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\nCoroutine ending...\n```\n\nOK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。\n## How coroutines can return value upon termination.\n\n当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。\n\n```\nfrom collections import namedtuple\n\nResult = namedtuple('result', 'count average')\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)\n    \n    coro_avg = averager()\n    next(coro_avg)\n    coro_avg.send(10)\n    coro_avg.send(11)\n    print(coro_avg.send(None))\n    \nTraceback (most recent call last):\nStopIteration: result(count=2, average=10.5)\n注意这里的StopIteration.它将Result也一起打印了出来。\n\n    try:\n        coro_avg.send(None)\n    except StopIteration as exec:\n        print(exec.value)\nresult(count=2, average=10.5)\n借助try/except我们可以的到正确的result.\n```\n\n后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。\n\n## Usage and semantics of the new yield from syntax.\n\n前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。\n\n**yield from**是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。\n\n\n**yield from x**这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。\n\n**delegating generator**是指函数里包含了yield from <iterable>表达式。\n\n**subgenerator**指yield from <iterable>表达式里<iterable>得到的generator。\n\n**caller**指调用delagating generator的函数。\n\n```\nfrom collections import namedtuple\n\nresult = namedtuple('result', 'count average')\n\n\n# subgenerator\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return result(count, average)\n\n\n# delegating generator\ndef grouper(results, key):\n    while True:\n        results[key] = yield from averager()\n\n# caller\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            group.send(value)\n        group.send(None)  ## important\n\n    report(results)\n\n\ndef report(results):\n    for key, values in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}'.format(\n            values.count, group, values.average, unit\n        ))\n        \ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\nmain(data)\n\n 9 boys  averaging 40.42\n 9 boys  averaging 1.39\n10 girls averaging 42.04\n10 girls averaging 1.43\n```\n理解一下上面的代码：\n* 每一次迭代，调用grouper()创建的实例就是delegating generator.\n* 调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。\n* group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。\n* 当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。\n* 当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。\n\n上面代码的**核心**概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。\n\n如果还没有完全理解yield from,我们再从**PEP 380**中给出的介绍来理解：\n\n1. 任何subgenerator中yield的值都会直接传递给caller.\n2. 任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的__next__()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.\n3. return expr在generator里会抛出StopIteration，并且退出这个generator.\n4. yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。\n5. 通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.\n6. 如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。\n\n为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制\n\n```\nRESULT = yield from EXPR\n\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        _s = yield _y\n        try:\n            _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\n\nRESULT = _r\n\n_i是subgenerator.\n_y是subgenerator里yield出来的值.\n_r是最终结果.\n_s是caller传送给delegating generator的值，跳转给subgenerator.\n_e是一个异常.\n\n如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。\nimport sys\n\nRESULT = yield from EXPR\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except Exception as _e:\n                    _r = _e.value\n                    break\n    else:\n        try:\n            if _s is None:\n                _y = next(_i)\n            else:\n                _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\nRESULT = _r\n\n```\n\n## A use case: coroutines for managing concurrent activities in a simulation.\n\n最后我们通过一个写并发概念的简单demo来梳理一下概念\n\n```\nfrom collections import namedtuple\n\nEvent = namedtuple('Event', 'time proc action')\n\n\ndef taxi_process(ident, trips, start_time=0):\n    \"\"\"Yield to simular issuing event at each state change.\"\"\"\n    time = yield Event(start_time, ident, 'leave garge.')\n    for i in range(trips):\n        time = yield Event(time, ident, 'pick up passenger.')\n        time = yield Event(time, ident, 'drop off passenger.')\n    yield Event(time, ident, 'going home.')\n    taxi = taxi_process(ident=1, trips=2)\n    print(next(taxi))\n    print(taxi.send(7))\n    print(taxi.send(15))\n    print(taxi.send(16))\n    print(taxi.send(23))\n    print(taxi.send(30))\nEvent(time=0, proc=1, action='leave garge.')\nEvent(time=7, proc=1, action='pick up passenger.')\nEvent(time=15, proc=1, action='drop off passenger.')\nEvent(time=16, proc=1, action='pick up passenger.')\nEvent(time=23, proc=1, action='drop off passenger.')\nEvent(time=30, proc=1, action='going home.')\n这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。\n\nimport queue\n\n\nclass Simulator(object):\n    def __init__(self, procs_map):\n        self.events = queue.PriorityQueue()\n        self.procs = dict(procs_map)\n\n    def run(self, end_time):\n        \"\"\"Schedule and display events utill time is up.\"\"\"\n        for _, proc in sorted(self.procs.items()):\n            first_event = next(proc)\n            self.events.put(first_event)\n\n        sim_time = 0\n        while sim_time < end_time:\n            if self.events.empty():\n                print('*** end of events ***')\n                break\n            current_event = self.events.get()\n            sim_time, proc_id, previous_action = current_event\n            print('taxi:', proc_id, proc_id * '  ', current_event)\n            active_proc = self.procs[proc_id]\n            next_time = sim_time + compute_duration(previous_action)\n            try:\n                next_event = active_proc.send(next_time)\n            except StopIteration:\n                del self.procs[proc_id]\n            else:\n                self.events.put(next_event)\n        else:\n            msg = '*** end of simulation time: {} events pending ***'\n            print(msg.format(self.events.qsize()))\n\n\ndef compute_duration(previous_action):\n    duration = 1\n    if previous_action == 'pick up passenger.':\n        duration = 3\n    elif previous_action == 'drop off passenger.':\n        duration = 5\n    return duration\nif __name__ == '__main__':\n    DEPARTURE_INTERVAL = 2\n    num_taxis = 3\n    taxis = {\n        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)\n        for i in range(num_taxis)\n    }\n    sim = Simulator(taxis)\n    print(sim.run(100))\ntaxi: 0  Event(time=0, proc=0, action='leave garge.')\ntaxi: 0  Event(time=1, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=2, proc=1, action='leave garge.')\ntaxi: 1    Event(time=3, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=4, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=4, proc=2, action='leave garge.')\ntaxi: 2      Event(time=5, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=6, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=8, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=9, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=11, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=12, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=13, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=14, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=16, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=17, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=19, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=20, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=21, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=22, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=24, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=25, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=27, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=28, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=29, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=30, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=32, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=33, proc=0, action='going home.')\ntaxi: 1    Event(time=35, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=37, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=38, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=40, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=43, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=45, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=46, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=48, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=51, proc=1, action='going home.')\ntaxi: 2      Event(time=53, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=56, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=61, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=64, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=69, proc=2, action='going home.')\n*** end of events ***\n```\n\n请记住这个例子，之后在介绍**asyncio**时会进行详细的讲解。\n\n\n## Summary\n\n\n\n对于coroutine的介绍就到这里了，希望你已经理解了**yield from**的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！\n\n感谢你的阅读，希望能收到你的feedback :)\n\n本文代码地址: [https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo)","source":"_posts/Python-Coroutine介绍.md","raw":"---\ntitle: Python Coroutine介绍\ndate: 2017-12-11 14:58:15\ntags: Python\n\n---\n\n\n## Concept\n通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。\n\n在coroutine里\n\n1. yield item通常放在=的右边，比如datum = yield item，item可以为None.\n2. 对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。\n3. yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。\n4. 增加了.throw()和.close()方法来扩展caller对coroutine的控制。\n\n\n## The behavior and states of a generator operating as a coroutine.\n\n我们先看一个基础的coroutine demo。\n\n```\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nmy_coro = simple_generator()\nprint(my_coro)\n<generator object simple_generator at 0x1093572b0>\nnext(my_coro)\nmy_coro.send(42)\n\n注意这里传递值时使用了.send()\n```\n看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。\n\ncoroutine只有四种状态：\n\n1. 'GEN_CREATED' 此时等待开始操作。\n2. 'GEN_RUINNING' 当前正在被解释器执行。\n3. 'GEN_SUSPENDED' 当前被一条yield语句挂起。\n4. 'GEN_CLOSED' coroutine已经全部执行完毕。\n\n通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在'GEN_CREATED'状态的coroutine里是无法操作的。\n`TypeError: can't send non-None value to a just-started generator`, 此时需要先通过next()来唤醒。\n\n接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。\n\n```\nfrom inspect import getgeneratorstate\ndef simple_coro2(a):\n    print('-> started: a =', a)\n    b = yield a\n    print('-> received: b =', b)\n    c = yield a + b\n    print('-> received: c = ', c)\n\nif __name__ == '__main__':\n    my_coro2 = simple_coro2(10)\n    print(getgeneratorstate(my_coro2))\n    next(my_coro2)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(20)\n    print(getgeneratorstate(my_coro2))\n    my_coro2.send(30)\n    \nGEN_CREATED\n-> started: a = 10\nGEN_SUSPENDED\n-> received: b = 20\nGEN_SUSPENDED\n-> received: c =  30\nTraceback (most recent call last):\nStopIteration\n\n通过打印，看到代码运行的流程跟我们的答案符合。\n```\n\n顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，\n所以’b = yield a‘中b的只有caller唤醒后才会赋值。\n\n\n接下来，我们来看一下如何终止一个coroutine.\n\n```\ndef averager():\n    total = count = 0\n    average = None\n    while True:  # 注意看这里，这意味着这个循环会一直进行下去。\n        term = yield average\n        total += term\n        count += 1\n        average = total / count\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send(12))\ncoro_avg.close()\n10.0\n10.5\n11.0\n调用.close()后，将其终止。\nprint(coro_avg.send(14))\nTraceback (most recent call last):\n    print(coro_avg.send(14))\nStopIteration\n调用已经终止的coroutine会抛出Stopiteration的异常。\n```\n\n## Priming a coroutine automaticall with a decorator.\n通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于'慵懒'的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！\n\n```\nfrom functools import wraps\nfrom inspect import getgeneratorstate\n\ndef coroutine(func):\n    @wraps(func)\n    def primer(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n    return primer\n\n@coroutine\ndef simple_generator():\n    print(' coroutine start.')\n    x = yield\n    print(' coroutine received ', x)\n\nif __name__ == '__main__':\n    my_coro = simple_generator()\n    print(getgeneratorstate(my_coro))\n    print(my_coro.send(10))\ncoroutine start.\nGEN_SUSPENDED # 已经是挂起状态了!\ncoroutine received  10\n```\n我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！\n\n## How the caller can control a coroutine through .close() and .throw() methods of the generator object.\n对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？\n\n```\ncoro_avg = averager()\nnext(coro_avg)\nprint(coro_avg.send(10))\nprint(coro_avg.send(11))\nprint(coro_avg.send('a'))\n10.0\n10.5\nTypeError: unsupported operand type(s) for +=: 'int' and 'str'\ncoro_avg.send(12)\nStopIteration    ## 后续的调用会抛出Stopiteration的异常。\n```\n当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。\n所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)\n\n当然，generator对象有两种方法可以发送异常。\n\n1. generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。\n2. generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。\n\n介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。\n\n```\nfrom inspect import getgeneratorstate\nclass DemoException(Exception):\n    \"\"\"\"An exception type for the  demonstration.\"\"\"\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Continuing...')\n        else:\n            print('-> coroutine received: {!r}'.format(x))\n\n    raise RuntimeError('This line should never run.')\nexc_coro = demo_exc_handling()\nnext(exc_coro)\n\n\t# Demo 1\n\tprint(exc_coro.send(11))\n\tprint(exc_coro.send(22))\n\texc_coro.close()\n\tprint(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\nGEN_CLOSED\n\n    # Demo 2\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\n\n    # Demo 3\n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(ZeroDivisionError)\n    print(getgeneratorstate(exc_coro))\n\n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n'GEN_CLOSED'\n```\n\n注意看上面三种异常的打印，以及异常发生后的generator的状态。\n\n如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。\n\n```\n\ndef demo_exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Continuing...')\n            else:\n                print('-> coroutine received: {!r}'.format(x))\n    finally:\n        print('Coroutine ending...')\n    raise RuntimeError('This line should never run.')\n    \n    exc_coro.send(11)\n    exc_coro.send(22)\n    exc_coro.throw(DemoException)\n    print(getgeneratorstate(exc_coro))\n    \n-> coroutine started\n-> coroutine received: 11\n-> coroutine received: 22\n*** DemoException handled. Continuing...\nGEN_SUSPENDED\nCoroutine ending...\n```\n\nOK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。\n## How coroutines can return value upon termination.\n\n当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。\n\n```\nfrom collections import namedtuple\n\nResult = namedtuple('result', 'count average')\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)\n    \n    coro_avg = averager()\n    next(coro_avg)\n    coro_avg.send(10)\n    coro_avg.send(11)\n    print(coro_avg.send(None))\n    \nTraceback (most recent call last):\nStopIteration: result(count=2, average=10.5)\n注意这里的StopIteration.它将Result也一起打印了出来。\n\n    try:\n        coro_avg.send(None)\n    except StopIteration as exec:\n        print(exec.value)\nresult(count=2, average=10.5)\n借助try/except我们可以的到正确的result.\n```\n\n后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。\n\n## Usage and semantics of the new yield from syntax.\n\n前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。\n\n**yield from**是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。\n\n\n**yield from x**这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。\n\n**delegating generator**是指函数里包含了yield from <iterable>表达式。\n\n**subgenerator**指yield from <iterable>表达式里<iterable>得到的generator。\n\n**caller**指调用delagating generator的函数。\n\n```\nfrom collections import namedtuple\n\nresult = namedtuple('result', 'count average')\n\n\n# subgenerator\ndef averager():\n    total = count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return result(count, average)\n\n\n# delegating generator\ndef grouper(results, key):\n    while True:\n        results[key] = yield from averager()\n\n# caller\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            group.send(value)\n        group.send(None)  ## important\n\n    report(results)\n\n\ndef report(results):\n    for key, values in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}'.format(\n            values.count, group, values.average, unit\n        ))\n        \ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\nmain(data)\n\n 9 boys  averaging 40.42\n 9 boys  averaging 1.39\n10 girls averaging 42.04\n10 girls averaging 1.43\n```\n理解一下上面的代码：\n* 每一次迭代，调用grouper()创建的实例就是delegating generator.\n* 调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。\n* group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。\n* 当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。\n* 当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。\n\n上面代码的**核心**概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。\n\n如果还没有完全理解yield from,我们再从**PEP 380**中给出的介绍来理解：\n\n1. 任何subgenerator中yield的值都会直接传递给caller.\n2. 任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的__next__()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.\n3. return expr在generator里会抛出StopIteration，并且退出这个generator.\n4. yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。\n5. 通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.\n6. 如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。\n\n为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制\n\n```\nRESULT = yield from EXPR\n\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        _s = yield _y\n        try:\n            _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\n\nRESULT = _r\n\n_i是subgenerator.\n_y是subgenerator里yield出来的值.\n_r是最终结果.\n_s是caller传送给delegating generator的值，跳转给subgenerator.\n_e是一个异常.\n\n如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。\nimport sys\n\nRESULT = yield from EXPR\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except Exception as _e:\n                    _r = _e.value\n                    break\n    else:\n        try:\n            if _s is None:\n                _y = next(_i)\n            else:\n                _y = _i.send(_s)\n        except StopIteration as _e:\n            _r = _e.value\n            break\nRESULT = _r\n\n```\n\n## A use case: coroutines for managing concurrent activities in a simulation.\n\n最后我们通过一个写并发概念的简单demo来梳理一下概念\n\n```\nfrom collections import namedtuple\n\nEvent = namedtuple('Event', 'time proc action')\n\n\ndef taxi_process(ident, trips, start_time=0):\n    \"\"\"Yield to simular issuing event at each state change.\"\"\"\n    time = yield Event(start_time, ident, 'leave garge.')\n    for i in range(trips):\n        time = yield Event(time, ident, 'pick up passenger.')\n        time = yield Event(time, ident, 'drop off passenger.')\n    yield Event(time, ident, 'going home.')\n    taxi = taxi_process(ident=1, trips=2)\n    print(next(taxi))\n    print(taxi.send(7))\n    print(taxi.send(15))\n    print(taxi.send(16))\n    print(taxi.send(23))\n    print(taxi.send(30))\nEvent(time=0, proc=1, action='leave garge.')\nEvent(time=7, proc=1, action='pick up passenger.')\nEvent(time=15, proc=1, action='drop off passenger.')\nEvent(time=16, proc=1, action='pick up passenger.')\nEvent(time=23, proc=1, action='drop off passenger.')\nEvent(time=30, proc=1, action='going home.')\n这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。\n\nimport queue\n\n\nclass Simulator(object):\n    def __init__(self, procs_map):\n        self.events = queue.PriorityQueue()\n        self.procs = dict(procs_map)\n\n    def run(self, end_time):\n        \"\"\"Schedule and display events utill time is up.\"\"\"\n        for _, proc in sorted(self.procs.items()):\n            first_event = next(proc)\n            self.events.put(first_event)\n\n        sim_time = 0\n        while sim_time < end_time:\n            if self.events.empty():\n                print('*** end of events ***')\n                break\n            current_event = self.events.get()\n            sim_time, proc_id, previous_action = current_event\n            print('taxi:', proc_id, proc_id * '  ', current_event)\n            active_proc = self.procs[proc_id]\n            next_time = sim_time + compute_duration(previous_action)\n            try:\n                next_event = active_proc.send(next_time)\n            except StopIteration:\n                del self.procs[proc_id]\n            else:\n                self.events.put(next_event)\n        else:\n            msg = '*** end of simulation time: {} events pending ***'\n            print(msg.format(self.events.qsize()))\n\n\ndef compute_duration(previous_action):\n    duration = 1\n    if previous_action == 'pick up passenger.':\n        duration = 3\n    elif previous_action == 'drop off passenger.':\n        duration = 5\n    return duration\nif __name__ == '__main__':\n    DEPARTURE_INTERVAL = 2\n    num_taxis = 3\n    taxis = {\n        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)\n        for i in range(num_taxis)\n    }\n    sim = Simulator(taxis)\n    print(sim.run(100))\ntaxi: 0  Event(time=0, proc=0, action='leave garge.')\ntaxi: 0  Event(time=1, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=2, proc=1, action='leave garge.')\ntaxi: 1    Event(time=3, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=4, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=4, proc=2, action='leave garge.')\ntaxi: 2      Event(time=5, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=6, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=8, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=9, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=11, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=12, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=13, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=14, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=16, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=17, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=19, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=20, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=21, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=22, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=24, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=25, proc=0, action='pick up passenger.')\ntaxi: 1    Event(time=27, proc=1, action='pick up passenger.')\ntaxi: 0  Event(time=28, proc=0, action='drop off passenger.')\ntaxi: 2      Event(time=29, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=30, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=32, proc=2, action='drop off passenger.')\ntaxi: 0  Event(time=33, proc=0, action='going home.')\ntaxi: 1    Event(time=35, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=37, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=38, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=40, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=43, proc=1, action='pick up passenger.')\ntaxi: 2      Event(time=45, proc=2, action='pick up passenger.')\ntaxi: 1    Event(time=46, proc=1, action='drop off passenger.')\ntaxi: 2      Event(time=48, proc=2, action='drop off passenger.')\ntaxi: 1    Event(time=51, proc=1, action='going home.')\ntaxi: 2      Event(time=53, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=56, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=61, proc=2, action='pick up passenger.')\ntaxi: 2      Event(time=64, proc=2, action='drop off passenger.')\ntaxi: 2      Event(time=69, proc=2, action='going home.')\n*** end of events ***\n```\n\n请记住这个例子，之后在介绍**asyncio**时会进行详细的讲解。\n\n\n## Summary\n\n\n\n对于coroutine的介绍就到这里了，希望你已经理解了**yield from**的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！\n\n感谢你的阅读，希望能收到你的feedback :)\n\n本文代码地址: [https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo)","slug":"Python-Coroutine介绍","published":1,"updated":"2017-12-11T07:00:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqf0029lvtly0cd1gts","content":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。</p>\n<p>在coroutine里</p>\n<ol>\n<li>yield item通常放在=的右边，比如datum = yield item，item可以为None.</li>\n<li>对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。</li>\n<li>yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。</li>\n<li>增加了.throw()和.close()方法来扩展caller对coroutine的控制。</li>\n</ol>\n<h2 id=\"The-behavior-and-states-of-a-generator-operating-as-a-coroutine\"><a href=\"#The-behavior-and-states-of-a-generator-operating-as-a-coroutine\" class=\"headerlink\" title=\"The behavior and states of a generator operating as a coroutine.\"></a>The behavior and states of a generator operating as a coroutine.</h2><p>我们先看一个基础的coroutine demo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">my_coro = simple_generator()</div><div class=\"line\">print(my_coro)</div><div class=\"line\">&lt;generator object simple_generator at 0x1093572b0&gt;</div><div class=\"line\">next(my_coro)</div><div class=\"line\">my_coro.send(42)</div><div class=\"line\"></div><div class=\"line\">注意这里传递值时使用了.send()</div></pre></td></tr></table></figure>\n<p>看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。</p>\n<p>coroutine只有四种状态：</p>\n<ol>\n<li>‘GEN_CREATED’ 此时等待开始操作。</li>\n<li>‘GEN_RUINNING’ 当前正在被解释器执行。</li>\n<li>‘GEN_SUSPENDED’ 当前被一条yield语句挂起。</li>\n<li>‘GEN_CLOSED’ coroutine已经全部执行完毕。</li>\n</ol>\n<p>通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在’GEN_CREATED’状态的coroutine里是无法操作的。<br><code>TypeError: can&#39;t send non-None value to a just-started generator</code>, 此时需要先通过next()来唤醒。</p>\n<p>接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">def simple_coro2(a):</div><div class=\"line\">    print(&apos;-&gt; started: a =&apos;, a)</div><div class=\"line\">    b = yield a</div><div class=\"line\">    print(&apos;-&gt; received: b =&apos;, b)</div><div class=\"line\">    c = yield a + b</div><div class=\"line\">    print(&apos;-&gt; received: c = &apos;, c)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro2 = simple_coro2(10)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    next(my_coro2)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(20)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(30)</div><div class=\"line\">    </div><div class=\"line\">GEN_CREATED</div><div class=\"line\">-&gt; started: a = 10</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: b = 20</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: c =  30</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration</div><div class=\"line\"></div><div class=\"line\">通过打印，看到代码运行的流程跟我们的答案符合。</div></pre></td></tr></table></figure>\n<p>顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，<br>所以’b = yield a‘中b的只有caller唤醒后才会赋值。</p>\n<p>接下来，我们来看一下如何终止一个coroutine.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:  # 注意看这里，这意味着这个循环会一直进行下去。</div><div class=\"line\">        term = yield average</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(12))</div><div class=\"line\">coro_avg.close()</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div><div class=\"line\">调用.close()后，将其终止。</div><div class=\"line\">print(coro_avg.send(14))</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">    print(coro_avg.send(14))</div><div class=\"line\">StopIteration</div><div class=\"line\">调用已经终止的coroutine会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<h2 id=\"Priming-a-coroutine-automaticall-with-a-decorator\"><a href=\"#Priming-a-coroutine-automaticall-with-a-decorator\" class=\"headerlink\" title=\"Priming a coroutine automaticall with a decorator.\"></a>Priming a coroutine automaticall with a decorator.</h2><p>通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于’慵懒’的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from functools import wraps</div><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\"></div><div class=\"line\">def coroutine(func):</div><div class=\"line\">    @wraps(func)</div><div class=\"line\">    def primer(*args, **kwargs):</div><div class=\"line\">        gen = func(*args, **kwargs)</div><div class=\"line\">        next(gen)</div><div class=\"line\">        return gen</div><div class=\"line\">    return primer</div><div class=\"line\"></div><div class=\"line\">@coroutine</div><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro = simple_generator()</div><div class=\"line\">    print(getgeneratorstate(my_coro))</div><div class=\"line\">    print(my_coro.send(10))</div><div class=\"line\">coroutine start.</div><div class=\"line\">GEN_SUSPENDED # 已经是挂起状态了!</div><div class=\"line\">coroutine received  10</div></pre></td></tr></table></figure>\n<p>我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！</p>\n<h2 id=\"How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\"><a href=\"#How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\" class=\"headerlink\" title=\"How the caller can control a coroutine through .close() and .throw() methods of the generator object.\"></a>How the caller can control a coroutine through .close() and .throw() methods of the generator object.</h2><p>对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(&apos;a&apos;))</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">TypeError: unsupported operand type(s) for +=: &apos;int&apos; and &apos;str&apos;</div><div class=\"line\">coro_avg.send(12)</div><div class=\"line\">StopIteration    ## 后续的调用会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<p>当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。<br>所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)</p>\n<p>当然，generator对象有两种方法可以发送异常。</p>\n<ol>\n<li>generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。</li>\n<li>generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。</li>\n</ol>\n<p>介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">class DemoException(Exception):</div><div class=\"line\">    &quot;&quot;&quot;&quot;An exception type for the  demonstration.&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    while True:</div><div class=\"line\">        try:</div><div class=\"line\">            x = yield</div><div class=\"line\">        except DemoException:</div><div class=\"line\">            print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\"></div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">exc_coro = demo_exc_handling()</div><div class=\"line\">next(exc_coro)</div><div class=\"line\"></div><div class=\"line\">\t# Demo 1</div><div class=\"line\">\tprint(exc_coro.send(11))</div><div class=\"line\">\tprint(exc_coro.send(22))</div><div class=\"line\">\texc_coro.close()</div><div class=\"line\">\tprint(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">GEN_CLOSED</div><div class=\"line\"></div><div class=\"line\">    # Demo 2</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\"></div><div class=\"line\">    # Demo 3</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(ZeroDivisionError)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">&apos;GEN_CLOSED&apos;</div></pre></td></tr></table></figure>\n<p>注意看上面三种异常的打印，以及异常发生后的generator的状态。</p>\n<p>如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    try:</div><div class=\"line\">        while True:</div><div class=\"line\">            try:</div><div class=\"line\">                x = yield</div><div class=\"line\">            except DemoException:</div><div class=\"line\">                print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">            else:</div><div class=\"line\">                print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\">    finally:</div><div class=\"line\">        print(&apos;Coroutine ending...&apos;)</div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">    </div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">Coroutine ending...</div></pre></td></tr></table></figure>\n<p>OK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。</p>\n<h2 id=\"How-coroutines-can-return-value-upon-termination\"><a href=\"#How-coroutines-can-return-value-upon-termination\" class=\"headerlink\" title=\"How coroutines can return value upon termination.\"></a>How coroutines can return value upon termination.</h2><p>当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return Result(count, average)</div><div class=\"line\">    </div><div class=\"line\">    coro_avg = averager()</div><div class=\"line\">    next(coro_avg)</div><div class=\"line\">    coro_avg.send(10)</div><div class=\"line\">    coro_avg.send(11)</div><div class=\"line\">    print(coro_avg.send(None))</div><div class=\"line\">    </div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration: result(count=2, average=10.5)</div><div class=\"line\">注意这里的StopIteration.它将Result也一起打印了出来。</div><div class=\"line\"></div><div class=\"line\">    try:</div><div class=\"line\">        coro_avg.send(None)</div><div class=\"line\">    except StopIteration as exec:</div><div class=\"line\">        print(exec.value)</div><div class=\"line\">result(count=2, average=10.5)</div><div class=\"line\">借助try/except我们可以的到正确的result.</div></pre></td></tr></table></figure>\n<p>后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。</p>\n<h2 id=\"Usage-and-semantics-of-the-new-yield-from-syntax\"><a href=\"#Usage-and-semantics-of-the-new-yield-from-syntax\" class=\"headerlink\" title=\"Usage and semantics of the new yield from syntax.\"></a>Usage and semantics of the new yield from syntax.</h2><p>前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。</p>\n<p><strong>yield from</strong>是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。</p>\n<p><strong>yield from x</strong>这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。</p>\n<p><strong>delegating generator</strong>是指函数里包含了yield from <iterable>表达式。</iterable></p>\n<p><strong>subgenerator</strong>指yield from <iterable>表达式里<iterable>得到的generator。</iterable></iterable></p>\n<p><strong>caller</strong>指调用delagating generator的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># subgenerator</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return result(count, average)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># delegating generator</div><div class=\"line\">def grouper(results, key):</div><div class=\"line\">    while True:</div><div class=\"line\">        results[key] = yield from averager()</div><div class=\"line\"></div><div class=\"line\"># caller</div><div class=\"line\">def main(data):</div><div class=\"line\">    results = &#123;&#125;</div><div class=\"line\">    for key, values in data.items():</div><div class=\"line\">        group = grouper(results, key)</div><div class=\"line\">        next(group)</div><div class=\"line\">        for value in values:</div><div class=\"line\">            group.send(value)</div><div class=\"line\">        group.send(None)  ## important</div><div class=\"line\"></div><div class=\"line\">    report(results)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def report(results):</div><div class=\"line\">    for key, values in sorted(results.items()):</div><div class=\"line\">        group, unit = key.split(&apos;;&apos;)</div><div class=\"line\">        print(&apos;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&apos;.format(</div><div class=\"line\">            values.count, group, values.average, unit</div><div class=\"line\">        ))</div><div class=\"line\">        </div><div class=\"line\">data = &#123;</div><div class=\"line\">    &apos;girls;kg&apos;:</div><div class=\"line\">        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],</div><div class=\"line\">    &apos;girls;m&apos;:</div><div class=\"line\">        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],</div><div class=\"line\">    &apos;boys;kg&apos;:</div><div class=\"line\">        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],</div><div class=\"line\">    &apos;boys;m&apos;:</div><div class=\"line\">        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],</div><div class=\"line\">&#125;</div><div class=\"line\">main(data)</div><div class=\"line\"></div><div class=\"line\"> 9 boys  averaging 40.42</div><div class=\"line\"> 9 boys  averaging 1.39</div><div class=\"line\">10 girls averaging 42.04</div><div class=\"line\">10 girls averaging 1.43</div></pre></td></tr></table></figure>\n<p>理解一下上面的代码：</p>\n<ul>\n<li>每一次迭代，调用grouper()创建的实例就是delegating generator.</li>\n<li>调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。</li>\n<li>group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。</li>\n<li>当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。</li>\n<li>当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。</li>\n</ul>\n<p>上面代码的<strong>核心</strong>概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。</p>\n<p>如果还没有完全理解yield from,我们再从<strong>PEP 380</strong>中给出的介绍来理解：</p>\n<ol>\n<li>任何subgenerator中yield的值都会直接传递给caller.</li>\n<li>任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的<strong>next</strong>()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.</li>\n<li>return expr在generator里会抛出StopIteration，并且退出这个generator.</li>\n<li>yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。</li>\n<li>通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.</li>\n<li>如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。</li>\n</ol>\n<p>为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\"></div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        _s = yield _y</div><div class=\"line\">        try:</div><div class=\"line\">            _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\"></div><div class=\"line\">RESULT = _r</div><div class=\"line\"></div><div class=\"line\">_i是subgenerator.</div><div class=\"line\">_y是subgenerator里yield出来的值.</div><div class=\"line\">_r是最终结果.</div><div class=\"line\">_s是caller传送给delegating generator的值，跳转给subgenerator.</div><div class=\"line\">_e是一个异常.</div><div class=\"line\"></div><div class=\"line\">如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        try:</div><div class=\"line\">            _s = yield _y</div><div class=\"line\">        except GeneratorExit as _e:</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.close</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                pass</div><div class=\"line\">            else:</div><div class=\"line\">                _m()</div><div class=\"line\">            raise _e</div><div class=\"line\">        except BaseException as _e:</div><div class=\"line\">            _x = sys.exc_info()</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.throw</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                raise _e</div><div class=\"line\">            else:</div><div class=\"line\">                try:</div><div class=\"line\">                    _y = _m(*_x)</div><div class=\"line\">                except Exception as _e:</div><div class=\"line\">                    _r = _e.value</div><div class=\"line\">                    break</div><div class=\"line\">    else:</div><div class=\"line\">        try:</div><div class=\"line\">            if _s is None:</div><div class=\"line\">                _y = next(_i)</div><div class=\"line\">            else:</div><div class=\"line\">                _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\">RESULT = _r</div></pre></td></tr></table></figure>\n<h2 id=\"A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\"><a href=\"#A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\" class=\"headerlink\" title=\"A use case: coroutines for managing concurrent activities in a simulation.\"></a>A use case: coroutines for managing concurrent activities in a simulation.</h2><p>最后我们通过一个写并发概念的简单demo来梳理一下概念</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Event = namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def taxi_process(ident, trips, start_time=0):</div><div class=\"line\">    &quot;&quot;&quot;Yield to simular issuing event at each state change.&quot;&quot;&quot;</div><div class=\"line\">    time = yield Event(start_time, ident, &apos;leave garge.&apos;)</div><div class=\"line\">    for i in range(trips):</div><div class=\"line\">        time = yield Event(time, ident, &apos;pick up passenger.&apos;)</div><div class=\"line\">        time = yield Event(time, ident, &apos;drop off passenger.&apos;)</div><div class=\"line\">    yield Event(time, ident, &apos;going home.&apos;)</div><div class=\"line\">    taxi = taxi_process(ident=1, trips=2)</div><div class=\"line\">    print(next(taxi))</div><div class=\"line\">    print(taxi.send(7))</div><div class=\"line\">    print(taxi.send(15))</div><div class=\"line\">    print(taxi.send(16))</div><div class=\"line\">    print(taxi.send(23))</div><div class=\"line\">    print(taxi.send(30))</div><div class=\"line\">Event(time=0, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">Event(time=7, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=15, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=16, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=23, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=30, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。</div><div class=\"line\"></div><div class=\"line\">import queue</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Simulator(object):</div><div class=\"line\">    def __init__(self, procs_map):</div><div class=\"line\">        self.events = queue.PriorityQueue()</div><div class=\"line\">        self.procs = dict(procs_map)</div><div class=\"line\"></div><div class=\"line\">    def run(self, end_time):</div><div class=\"line\">        &quot;&quot;&quot;Schedule and display events utill time is up.&quot;&quot;&quot;</div><div class=\"line\">        for _, proc in sorted(self.procs.items()):</div><div class=\"line\">            first_event = next(proc)</div><div class=\"line\">            self.events.put(first_event)</div><div class=\"line\"></div><div class=\"line\">        sim_time = 0</div><div class=\"line\">        while sim_time &lt; end_time:</div><div class=\"line\">            if self.events.empty():</div><div class=\"line\">                print(&apos;*** end of events ***&apos;)</div><div class=\"line\">                break</div><div class=\"line\">            current_event = self.events.get()</div><div class=\"line\">            sim_time, proc_id, previous_action = current_event</div><div class=\"line\">            print(&apos;taxi:&apos;, proc_id, proc_id * &apos;  &apos;, current_event)</div><div class=\"line\">            active_proc = self.procs[proc_id]</div><div class=\"line\">            next_time = sim_time + compute_duration(previous_action)</div><div class=\"line\">            try:</div><div class=\"line\">                next_event = active_proc.send(next_time)</div><div class=\"line\">            except StopIteration:</div><div class=\"line\">                del self.procs[proc_id]</div><div class=\"line\">            else:</div><div class=\"line\">                self.events.put(next_event)</div><div class=\"line\">        else:</div><div class=\"line\">            msg = &apos;*** end of simulation time: &#123;&#125; events pending ***&apos;</div><div class=\"line\">            print(msg.format(self.events.qsize()))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def compute_duration(previous_action):</div><div class=\"line\">    duration = 1</div><div class=\"line\">    if previous_action == &apos;pick up passenger.&apos;:</div><div class=\"line\">        duration = 3</div><div class=\"line\">    elif previous_action == &apos;drop off passenger.&apos;:</div><div class=\"line\">        duration = 5</div><div class=\"line\">    return duration</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    DEPARTURE_INTERVAL = 2</div><div class=\"line\">    num_taxis = 3</div><div class=\"line\">    taxis = &#123;</div><div class=\"line\">        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)</div><div class=\"line\">        for i in range(num_taxis)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sim = Simulator(taxis)</div><div class=\"line\">    print(sim.run(100))</div><div class=\"line\">taxi: 0  Event(time=0, proc=0, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 0  Event(time=1, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=2, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 1    Event(time=3, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=4, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=4, proc=2, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 2      Event(time=5, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=6, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=8, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=9, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=11, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=12, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=13, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=14, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=16, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=17, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=19, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=20, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=21, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=22, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=24, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=25, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=27, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=28, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=29, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=30, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=32, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=33, proc=0, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 1    Event(time=35, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=37, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=38, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=40, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=43, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=45, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=46, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=48, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=51, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 2      Event(time=53, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=56, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=61, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=64, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=69, proc=2, action=&apos;going home.&apos;)</div><div class=\"line\">*** end of events ***</div></pre></td></tr></table></figure>\n<p>请记住这个例子，之后在介绍<strong>asyncio</strong>时会进行详细的讲解。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>对于coroutine的介绍就到这里了，希望你已经理解了<strong>yield from</strong>的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！</p>\n<p>感谢你的阅读，希望能收到你的feedback :)</p>\n<p>本文代码地址: <a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><p>通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。</p>\n<p>在coroutine里</p>\n<ol>\n<li>yield item通常放在=的右边，比如datum = yield item，item可以为None.</li>\n<li>对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。</li>\n<li>yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。</li>\n<li>增加了.throw()和.close()方法来扩展caller对coroutine的控制。</li>\n</ol>\n<h2 id=\"The-behavior-and-states-of-a-generator-operating-as-a-coroutine\"><a href=\"#The-behavior-and-states-of-a-generator-operating-as-a-coroutine\" class=\"headerlink\" title=\"The behavior and states of a generator operating as a coroutine.\"></a>The behavior and states of a generator operating as a coroutine.</h2><p>我们先看一个基础的coroutine demo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">my_coro = simple_generator()</div><div class=\"line\">print(my_coro)</div><div class=\"line\">&lt;generator object simple_generator at 0x1093572b0&gt;</div><div class=\"line\">next(my_coro)</div><div class=\"line\">my_coro.send(42)</div><div class=\"line\"></div><div class=\"line\">注意这里传递值时使用了.send()</div></pre></td></tr></table></figure>\n<p>看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。</p>\n<p>coroutine只有四种状态：</p>\n<ol>\n<li>‘GEN_CREATED’ 此时等待开始操作。</li>\n<li>‘GEN_RUINNING’ 当前正在被解释器执行。</li>\n<li>‘GEN_SUSPENDED’ 当前被一条yield语句挂起。</li>\n<li>‘GEN_CLOSED’ coroutine已经全部执行完毕。</li>\n</ol>\n<p>通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在’GEN_CREATED’状态的coroutine里是无法操作的。<br><code>TypeError: can&#39;t send non-None value to a just-started generator</code>, 此时需要先通过next()来唤醒。</p>\n<p>接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">def simple_coro2(a):</div><div class=\"line\">    print(&apos;-&gt; started: a =&apos;, a)</div><div class=\"line\">    b = yield a</div><div class=\"line\">    print(&apos;-&gt; received: b =&apos;, b)</div><div class=\"line\">    c = yield a + b</div><div class=\"line\">    print(&apos;-&gt; received: c = &apos;, c)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro2 = simple_coro2(10)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    next(my_coro2)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(20)</div><div class=\"line\">    print(getgeneratorstate(my_coro2))</div><div class=\"line\">    my_coro2.send(30)</div><div class=\"line\">    </div><div class=\"line\">GEN_CREATED</div><div class=\"line\">-&gt; started: a = 10</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: b = 20</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">-&gt; received: c =  30</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration</div><div class=\"line\"></div><div class=\"line\">通过打印，看到代码运行的流程跟我们的答案符合。</div></pre></td></tr></table></figure>\n<p>顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，<br>所以’b = yield a‘中b的只有caller唤醒后才会赋值。</p>\n<p>接下来，我们来看一下如何终止一个coroutine.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:  # 注意看这里，这意味着这个循环会一直进行下去。</div><div class=\"line\">        term = yield average</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(12))</div><div class=\"line\">coro_avg.close()</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">11.0</div><div class=\"line\">调用.close()后，将其终止。</div><div class=\"line\">print(coro_avg.send(14))</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">    print(coro_avg.send(14))</div><div class=\"line\">StopIteration</div><div class=\"line\">调用已经终止的coroutine会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<h2 id=\"Priming-a-coroutine-automaticall-with-a-decorator\"><a href=\"#Priming-a-coroutine-automaticall-with-a-decorator\" class=\"headerlink\" title=\"Priming a coroutine automaticall with a decorator.\"></a>Priming a coroutine automaticall with a decorator.</h2><p>通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于’慵懒’的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">from functools import wraps</div><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\"></div><div class=\"line\">def coroutine(func):</div><div class=\"line\">    @wraps(func)</div><div class=\"line\">    def primer(*args, **kwargs):</div><div class=\"line\">        gen = func(*args, **kwargs)</div><div class=\"line\">        next(gen)</div><div class=\"line\">        return gen</div><div class=\"line\">    return primer</div><div class=\"line\"></div><div class=\"line\">@coroutine</div><div class=\"line\">def simple_generator():</div><div class=\"line\">    print(&apos; coroutine start.&apos;)</div><div class=\"line\">    x = yield</div><div class=\"line\">    print(&apos; coroutine received &apos;, x)</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    my_coro = simple_generator()</div><div class=\"line\">    print(getgeneratorstate(my_coro))</div><div class=\"line\">    print(my_coro.send(10))</div><div class=\"line\">coroutine start.</div><div class=\"line\">GEN_SUSPENDED # 已经是挂起状态了!</div><div class=\"line\">coroutine received  10</div></pre></td></tr></table></figure>\n<p>我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！</p>\n<h2 id=\"How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\"><a href=\"#How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object\" class=\"headerlink\" title=\"How the caller can control a coroutine through .close() and .throw() methods of the generator object.\"></a>How the caller can control a coroutine through .close() and .throw() methods of the generator object.</h2><p>对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">coro_avg = averager()</div><div class=\"line\">next(coro_avg)</div><div class=\"line\">print(coro_avg.send(10))</div><div class=\"line\">print(coro_avg.send(11))</div><div class=\"line\">print(coro_avg.send(&apos;a&apos;))</div><div class=\"line\">10.0</div><div class=\"line\">10.5</div><div class=\"line\">TypeError: unsupported operand type(s) for +=: &apos;int&apos; and &apos;str&apos;</div><div class=\"line\">coro_avg.send(12)</div><div class=\"line\">StopIteration    ## 后续的调用会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>\n<p>当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。<br>所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)</p>\n<p>当然，generator对象有两种方法可以发送异常。</p>\n<ol>\n<li>generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。</li>\n<li>generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。</li>\n</ol>\n<p>介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">from inspect import getgeneratorstate</div><div class=\"line\">class DemoException(Exception):</div><div class=\"line\">    &quot;&quot;&quot;&quot;An exception type for the  demonstration.&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    while True:</div><div class=\"line\">        try:</div><div class=\"line\">            x = yield</div><div class=\"line\">        except DemoException:</div><div class=\"line\">            print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">        else:</div><div class=\"line\">            print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\"></div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">exc_coro = demo_exc_handling()</div><div class=\"line\">next(exc_coro)</div><div class=\"line\"></div><div class=\"line\">\t# Demo 1</div><div class=\"line\">\tprint(exc_coro.send(11))</div><div class=\"line\">\tprint(exc_coro.send(22))</div><div class=\"line\">\texc_coro.close()</div><div class=\"line\">\tprint(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">GEN_CLOSED</div><div class=\"line\"></div><div class=\"line\">    # Demo 2</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\"></div><div class=\"line\">    # Demo 3</div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(ZeroDivisionError)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\"></div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">&apos;GEN_CLOSED&apos;</div></pre></td></tr></table></figure>\n<p>注意看上面三种异常的打印，以及异常发生后的generator的状态。</p>\n<p>如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">def demo_exc_handling():</div><div class=\"line\">    print(&apos;-&gt; coroutine started&apos;)</div><div class=\"line\">    try:</div><div class=\"line\">        while True:</div><div class=\"line\">            try:</div><div class=\"line\">                x = yield</div><div class=\"line\">            except DemoException:</div><div class=\"line\">                print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class=\"line\">            else:</div><div class=\"line\">                print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class=\"line\">    finally:</div><div class=\"line\">        print(&apos;Coroutine ending...&apos;)</div><div class=\"line\">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class=\"line\">    </div><div class=\"line\">    exc_coro.send(11)</div><div class=\"line\">    exc_coro.send(22)</div><div class=\"line\">    exc_coro.throw(DemoException)</div><div class=\"line\">    print(getgeneratorstate(exc_coro))</div><div class=\"line\">    </div><div class=\"line\">-&gt; coroutine started</div><div class=\"line\">-&gt; coroutine received: 11</div><div class=\"line\">-&gt; coroutine received: 22</div><div class=\"line\">*** DemoException handled. Continuing...</div><div class=\"line\">GEN_SUSPENDED</div><div class=\"line\">Coroutine ending...</div></pre></td></tr></table></figure>\n<p>OK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。</p>\n<h2 id=\"How-coroutines-can-return-value-upon-termination\"><a href=\"#How-coroutines-can-return-value-upon-termination\" class=\"headerlink\" title=\"How coroutines can return value upon termination.\"></a>How coroutines can return value upon termination.</h2><p>当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return Result(count, average)</div><div class=\"line\">    </div><div class=\"line\">    coro_avg = averager()</div><div class=\"line\">    next(coro_avg)</div><div class=\"line\">    coro_avg.send(10)</div><div class=\"line\">    coro_avg.send(11)</div><div class=\"line\">    print(coro_avg.send(None))</div><div class=\"line\">    </div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">StopIteration: result(count=2, average=10.5)</div><div class=\"line\">注意这里的StopIteration.它将Result也一起打印了出来。</div><div class=\"line\"></div><div class=\"line\">    try:</div><div class=\"line\">        coro_avg.send(None)</div><div class=\"line\">    except StopIteration as exec:</div><div class=\"line\">        print(exec.value)</div><div class=\"line\">result(count=2, average=10.5)</div><div class=\"line\">借助try/except我们可以的到正确的result.</div></pre></td></tr></table></figure>\n<p>后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。</p>\n<h2 id=\"Usage-and-semantics-of-the-new-yield-from-syntax\"><a href=\"#Usage-and-semantics-of-the-new-yield-from-syntax\" class=\"headerlink\" title=\"Usage and semantics of the new yield from syntax.\"></a>Usage and semantics of the new yield from syntax.</h2><p>前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。</p>\n<p><strong>yield from</strong>是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。</p>\n<p><strong>yield from x</strong>这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。</p>\n<p><strong>delegating generator</strong>是指函数里包含了yield from <iterable>表达式。</iterable></p>\n<p><strong>subgenerator</strong>指yield from <iterable>表达式里<iterable>得到的generator。</iterable></iterable></p>\n<p><strong>caller</strong>指调用delagating generator的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># subgenerator</div><div class=\"line\">def averager():</div><div class=\"line\">    total = count = 0</div><div class=\"line\">    average = None</div><div class=\"line\">    while True:</div><div class=\"line\">        term = yield</div><div class=\"line\">        if term is None:</div><div class=\"line\">            break</div><div class=\"line\">        total += term</div><div class=\"line\">        count += 1</div><div class=\"line\">        average = total / count</div><div class=\"line\">    return result(count, average)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># delegating generator</div><div class=\"line\">def grouper(results, key):</div><div class=\"line\">    while True:</div><div class=\"line\">        results[key] = yield from averager()</div><div class=\"line\"></div><div class=\"line\"># caller</div><div class=\"line\">def main(data):</div><div class=\"line\">    results = &#123;&#125;</div><div class=\"line\">    for key, values in data.items():</div><div class=\"line\">        group = grouper(results, key)</div><div class=\"line\">        next(group)</div><div class=\"line\">        for value in values:</div><div class=\"line\">            group.send(value)</div><div class=\"line\">        group.send(None)  ## important</div><div class=\"line\"></div><div class=\"line\">    report(results)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def report(results):</div><div class=\"line\">    for key, values in sorted(results.items()):</div><div class=\"line\">        group, unit = key.split(&apos;;&apos;)</div><div class=\"line\">        print(&apos;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&apos;.format(</div><div class=\"line\">            values.count, group, values.average, unit</div><div class=\"line\">        ))</div><div class=\"line\">        </div><div class=\"line\">data = &#123;</div><div class=\"line\">    &apos;girls;kg&apos;:</div><div class=\"line\">        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],</div><div class=\"line\">    &apos;girls;m&apos;:</div><div class=\"line\">        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],</div><div class=\"line\">    &apos;boys;kg&apos;:</div><div class=\"line\">        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],</div><div class=\"line\">    &apos;boys;m&apos;:</div><div class=\"line\">        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],</div><div class=\"line\">&#125;</div><div class=\"line\">main(data)</div><div class=\"line\"></div><div class=\"line\"> 9 boys  averaging 40.42</div><div class=\"line\"> 9 boys  averaging 1.39</div><div class=\"line\">10 girls averaging 42.04</div><div class=\"line\">10 girls averaging 1.43</div></pre></td></tr></table></figure>\n<p>理解一下上面的代码：</p>\n<ul>\n<li>每一次迭代，调用grouper()创建的实例就是delegating generator.</li>\n<li>调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。</li>\n<li>group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。</li>\n<li>当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。</li>\n<li>当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。</li>\n</ul>\n<p>上面代码的<strong>核心</strong>概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。</p>\n<p>如果还没有完全理解yield from,我们再从<strong>PEP 380</strong>中给出的介绍来理解：</p>\n<ol>\n<li>任何subgenerator中yield的值都会直接传递给caller.</li>\n<li>任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的<strong>next</strong>()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.</li>\n<li>return expr在generator里会抛出StopIteration，并且退出这个generator.</li>\n<li>yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。</li>\n<li>通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.</li>\n<li>如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。</li>\n</ol>\n<p>为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\"></div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        _s = yield _y</div><div class=\"line\">        try:</div><div class=\"line\">            _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\"></div><div class=\"line\">RESULT = _r</div><div class=\"line\"></div><div class=\"line\">_i是subgenerator.</div><div class=\"line\">_y是subgenerator里yield出来的值.</div><div class=\"line\">_r是最终结果.</div><div class=\"line\">_s是caller传送给delegating generator的值，跳转给subgenerator.</div><div class=\"line\">_e是一个异常.</div><div class=\"line\"></div><div class=\"line\">如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">RESULT = yield from EXPR</div><div class=\"line\">_i = iter(EXPR)</div><div class=\"line\">try:</div><div class=\"line\">    _y = next(_i)</div><div class=\"line\">except StopIteration as _e:</div><div class=\"line\">    _r = _e.value</div><div class=\"line\">else:</div><div class=\"line\">    while 1:</div><div class=\"line\">        try:</div><div class=\"line\">            _s = yield _y</div><div class=\"line\">        except GeneratorExit as _e:</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.close</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                pass</div><div class=\"line\">            else:</div><div class=\"line\">                _m()</div><div class=\"line\">            raise _e</div><div class=\"line\">        except BaseException as _e:</div><div class=\"line\">            _x = sys.exc_info()</div><div class=\"line\">            try:</div><div class=\"line\">                _m = _i.throw</div><div class=\"line\">            except AttributeError:</div><div class=\"line\">                raise _e</div><div class=\"line\">            else:</div><div class=\"line\">                try:</div><div class=\"line\">                    _y = _m(*_x)</div><div class=\"line\">                except Exception as _e:</div><div class=\"line\">                    _r = _e.value</div><div class=\"line\">                    break</div><div class=\"line\">    else:</div><div class=\"line\">        try:</div><div class=\"line\">            if _s is None:</div><div class=\"line\">                _y = next(_i)</div><div class=\"line\">            else:</div><div class=\"line\">                _y = _i.send(_s)</div><div class=\"line\">        except StopIteration as _e:</div><div class=\"line\">            _r = _e.value</div><div class=\"line\">            break</div><div class=\"line\">RESULT = _r</div></pre></td></tr></table></figure>\n<h2 id=\"A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\"><a href=\"#A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation\" class=\"headerlink\" title=\"A use case: coroutines for managing concurrent activities in a simulation.\"></a>A use case: coroutines for managing concurrent activities in a simulation.</h2><p>最后我们通过一个写并发概念的简单demo来梳理一下概念</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div></pre></td><td class=\"code\"><pre><div class=\"line\">from collections import namedtuple</div><div class=\"line\"></div><div class=\"line\">Event = namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def taxi_process(ident, trips, start_time=0):</div><div class=\"line\">    &quot;&quot;&quot;Yield to simular issuing event at each state change.&quot;&quot;&quot;</div><div class=\"line\">    time = yield Event(start_time, ident, &apos;leave garge.&apos;)</div><div class=\"line\">    for i in range(trips):</div><div class=\"line\">        time = yield Event(time, ident, &apos;pick up passenger.&apos;)</div><div class=\"line\">        time = yield Event(time, ident, &apos;drop off passenger.&apos;)</div><div class=\"line\">    yield Event(time, ident, &apos;going home.&apos;)</div><div class=\"line\">    taxi = taxi_process(ident=1, trips=2)</div><div class=\"line\">    print(next(taxi))</div><div class=\"line\">    print(taxi.send(7))</div><div class=\"line\">    print(taxi.send(15))</div><div class=\"line\">    print(taxi.send(16))</div><div class=\"line\">    print(taxi.send(23))</div><div class=\"line\">    print(taxi.send(30))</div><div class=\"line\">Event(time=0, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">Event(time=7, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=15, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=16, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">Event(time=23, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">Event(time=30, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。</div><div class=\"line\"></div><div class=\"line\">import queue</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class Simulator(object):</div><div class=\"line\">    def __init__(self, procs_map):</div><div class=\"line\">        self.events = queue.PriorityQueue()</div><div class=\"line\">        self.procs = dict(procs_map)</div><div class=\"line\"></div><div class=\"line\">    def run(self, end_time):</div><div class=\"line\">        &quot;&quot;&quot;Schedule and display events utill time is up.&quot;&quot;&quot;</div><div class=\"line\">        for _, proc in sorted(self.procs.items()):</div><div class=\"line\">            first_event = next(proc)</div><div class=\"line\">            self.events.put(first_event)</div><div class=\"line\"></div><div class=\"line\">        sim_time = 0</div><div class=\"line\">        while sim_time &lt; end_time:</div><div class=\"line\">            if self.events.empty():</div><div class=\"line\">                print(&apos;*** end of events ***&apos;)</div><div class=\"line\">                break</div><div class=\"line\">            current_event = self.events.get()</div><div class=\"line\">            sim_time, proc_id, previous_action = current_event</div><div class=\"line\">            print(&apos;taxi:&apos;, proc_id, proc_id * &apos;  &apos;, current_event)</div><div class=\"line\">            active_proc = self.procs[proc_id]</div><div class=\"line\">            next_time = sim_time + compute_duration(previous_action)</div><div class=\"line\">            try:</div><div class=\"line\">                next_event = active_proc.send(next_time)</div><div class=\"line\">            except StopIteration:</div><div class=\"line\">                del self.procs[proc_id]</div><div class=\"line\">            else:</div><div class=\"line\">                self.events.put(next_event)</div><div class=\"line\">        else:</div><div class=\"line\">            msg = &apos;*** end of simulation time: &#123;&#125; events pending ***&apos;</div><div class=\"line\">            print(msg.format(self.events.qsize()))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def compute_duration(previous_action):</div><div class=\"line\">    duration = 1</div><div class=\"line\">    if previous_action == &apos;pick up passenger.&apos;:</div><div class=\"line\">        duration = 3</div><div class=\"line\">    elif previous_action == &apos;drop off passenger.&apos;:</div><div class=\"line\">        duration = 5</div><div class=\"line\">    return duration</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    DEPARTURE_INTERVAL = 2</div><div class=\"line\">    num_taxis = 3</div><div class=\"line\">    taxis = &#123;</div><div class=\"line\">        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)</div><div class=\"line\">        for i in range(num_taxis)</div><div class=\"line\">    &#125;</div><div class=\"line\">    sim = Simulator(taxis)</div><div class=\"line\">    print(sim.run(100))</div><div class=\"line\">taxi: 0  Event(time=0, proc=0, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 0  Event(time=1, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=2, proc=1, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 1    Event(time=3, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=4, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=4, proc=2, action=&apos;leave garge.&apos;)</div><div class=\"line\">taxi: 2      Event(time=5, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=6, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=8, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=9, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=11, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=12, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=13, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=14, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=16, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=17, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=19, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=20, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=21, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=22, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=24, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=25, proc=0, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=27, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=28, proc=0, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=29, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=30, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=32, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 0  Event(time=33, proc=0, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 1    Event(time=35, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=37, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=38, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=40, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=43, proc=1, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=45, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=46, proc=1, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=48, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 1    Event(time=51, proc=1, action=&apos;going home.&apos;)</div><div class=\"line\">taxi: 2      Event(time=53, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=56, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=61, proc=2, action=&apos;pick up passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=64, proc=2, action=&apos;drop off passenger.&apos;)</div><div class=\"line\">taxi: 2      Event(time=69, proc=2, action=&apos;going home.&apos;)</div><div class=\"line\">*** end of events ***</div></pre></td></tr></table></figure>\n<p>请记住这个例子，之后在介绍<strong>asyncio</strong>时会进行详细的讲解。</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>对于coroutine的介绍就到这里了，希望你已经理解了<strong>yield from</strong>的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！</p>\n<p>感谢你的阅读，希望能收到你的feedback :)</p>\n<p>本文代码地址: <a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo</a></p>\n"},{"title":"python暑期实习面试 Report","date":"2017-06-16T07:27:45.000Z","_content":"\n\nps:本文是up记录第一次面试的经历，有对笔试题和面试题的解答与代码，更多的还是Up的个人感想。\n\n\n笔试部分\n约好10：20开始答题，结束时间为11：00。\n（实际11：30左右才答完QAQ）\n10：20\n\n\n刚开始拿到这道题，看了一下是亚马逊的商品爬虫，up心想这种爬虫GitHub上应该有很多，于是立马上Github，想找一个借鉴一下。可惜Github上找到的都已经年代久远了，最重要的是连提取格式都已经变了。而此时已经过去了20分钟左右了。\n\n\n10：40\n\n\n创建scrapy的项目，创建完成后，按照要求写好item的类型，写了一个Mysql的pipeline。因为之前浪费了太久的时间，此时心里还是非常焦急的，脑中仍是一片空白。打开Firefox后，用Firebug定位了商品信息的元素，再将每个元素的提取用selenium先模拟一遍。不过提取的过程中，由于一直静不下心，所以接连出错，总是提取不到正确的数据。\n\n\n11：00\n\n\n此时已经到了约定的时间了。元素也只提取了商品名称和评分，不过还是硬着头皮把代码发了过去（代码在后面）。\n\n\n11：30\n\n\n面试官一直没有消息，一边等待一边继续完成。\nps\n：\n此时才静下心思考了这题。发现连题目要求都弄错了！ 题目中只要求展示数据，并没有要求用数据库存储。而且完全没有必要使用scrapy项目，于是开始重新写\n\n\n最后用selenium+FireFox完成了翻页和Ajax的问题。\n\n\n以下是代码部分：\n\n\nhttps://github.com/Miksztowi/CorePython/blob/master/amazon.py\n\n","source":"_posts/python暑期实习面试.md","raw":"---\ntitle: python暑期实习面试 Report\ndate:  2017-06-16 15:27:45\ntags: 实习面试\n---\n\n\nps:本文是up记录第一次面试的经历，有对笔试题和面试题的解答与代码，更多的还是Up的个人感想。\n\n\n笔试部分\n约好10：20开始答题，结束时间为11：00。\n（实际11：30左右才答完QAQ）\n10：20\n\n\n刚开始拿到这道题，看了一下是亚马逊的商品爬虫，up心想这种爬虫GitHub上应该有很多，于是立马上Github，想找一个借鉴一下。可惜Github上找到的都已经年代久远了，最重要的是连提取格式都已经变了。而此时已经过去了20分钟左右了。\n\n\n10：40\n\n\n创建scrapy的项目，创建完成后，按照要求写好item的类型，写了一个Mysql的pipeline。因为之前浪费了太久的时间，此时心里还是非常焦急的，脑中仍是一片空白。打开Firefox后，用Firebug定位了商品信息的元素，再将每个元素的提取用selenium先模拟一遍。不过提取的过程中，由于一直静不下心，所以接连出错，总是提取不到正确的数据。\n\n\n11：00\n\n\n此时已经到了约定的时间了。元素也只提取了商品名称和评分，不过还是硬着头皮把代码发了过去（代码在后面）。\n\n\n11：30\n\n\n面试官一直没有消息，一边等待一边继续完成。\nps\n：\n此时才静下心思考了这题。发现连题目要求都弄错了！ 题目中只要求展示数据，并没有要求用数据库存储。而且完全没有必要使用scrapy项目，于是开始重新写\n\n\n最后用selenium+FireFox完成了翻页和Ajax的问题。\n\n\n以下是代码部分：\n\n\nhttps://github.com/Miksztowi/CorePython/blob/master/amazon.py\n\n","slug":"python暑期实习面试","published":1,"updated":"2017-11-04T09:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqg002blvtl7uwkl7aw","content":"<p>ps:本文是up记录第一次面试的经历，有对笔试题和面试题的解答与代码，更多的还是Up的个人感想。</p>\n<p>笔试部分<br>约好10：20开始答题，结束时间为11：00。<br>（实际11：30左右才答完QAQ）<br>10：20</p>\n<p>刚开始拿到这道题，看了一下是亚马逊的商品爬虫，up心想这种爬虫GitHub上应该有很多，于是立马上Github，想找一个借鉴一下。可惜Github上找到的都已经年代久远了，最重要的是连提取格式都已经变了。而此时已经过去了20分钟左右了。</p>\n<p>10：40</p>\n<p>创建scrapy的项目，创建完成后，按照要求写好item的类型，写了一个Mysql的pipeline。因为之前浪费了太久的时间，此时心里还是非常焦急的，脑中仍是一片空白。打开Firefox后，用Firebug定位了商品信息的元素，再将每个元素的提取用selenium先模拟一遍。不过提取的过程中，由于一直静不下心，所以接连出错，总是提取不到正确的数据。</p>\n<p>11：00</p>\n<p>此时已经到了约定的时间了。元素也只提取了商品名称和评分，不过还是硬着头皮把代码发了过去（代码在后面）。</p>\n<p>11：30</p>\n<p>面试官一直没有消息，一边等待一边继续完成。<br>ps<br>：<br>此时才静下心思考了这题。发现连题目要求都弄错了！ 题目中只要求展示数据，并没有要求用数据库存储。而且完全没有必要使用scrapy项目，于是开始重新写</p>\n<p>最后用selenium+FireFox完成了翻页和Ajax的问题。</p>\n<p>以下是代码部分：</p>\n<p><a href=\"https://github.com/Miksztowi/CorePython/blob/master/amazon.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/amazon.py</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ps:本文是up记录第一次面试的经历，有对笔试题和面试题的解答与代码，更多的还是Up的个人感想。</p>\n<p>笔试部分<br>约好10：20开始答题，结束时间为11：00。<br>（实际11：30左右才答完QAQ）<br>10：20</p>\n<p>刚开始拿到这道题，看了一下是亚马逊的商品爬虫，up心想这种爬虫GitHub上应该有很多，于是立马上Github，想找一个借鉴一下。可惜Github上找到的都已经年代久远了，最重要的是连提取格式都已经变了。而此时已经过去了20分钟左右了。</p>\n<p>10：40</p>\n<p>创建scrapy的项目，创建完成后，按照要求写好item的类型，写了一个Mysql的pipeline。因为之前浪费了太久的时间，此时心里还是非常焦急的，脑中仍是一片空白。打开Firefox后，用Firebug定位了商品信息的元素，再将每个元素的提取用selenium先模拟一遍。不过提取的过程中，由于一直静不下心，所以接连出错，总是提取不到正确的数据。</p>\n<p>11：00</p>\n<p>此时已经到了约定的时间了。元素也只提取了商品名称和评分，不过还是硬着头皮把代码发了过去（代码在后面）。</p>\n<p>11：30</p>\n<p>面试官一直没有消息，一边等待一边继续完成。<br>ps<br>：<br>此时才静下心思考了这题。发现连题目要求都弄错了！ 题目中只要求展示数据，并没有要求用数据库存储。而且完全没有必要使用scrapy项目，于是开始重新写</p>\n<p>最后用selenium+FireFox完成了翻页和Ajax的问题。</p>\n<p>以下是代码部分：</p>\n<p><a href=\"https://github.com/Miksztowi/CorePython/blob/master/amazon.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/amazon.py</a></p>\n"},{"title":"Python内置模块bisect介绍","date":"2017-11-20T06:33:07.000Z","_content":"\n\n\n在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的**bisect**模块.\t\n\n## 介绍\n\n对于bisect，官网的解释是：\n\nThis module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。\n\n## 模块内提供的函数\n\n#### 查找：\n\n`bisect.bisect_left(a, x, lo=0, hi=len(a))`\n\na是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使`all(val < x for val in a[lo:i])` 在左侧， `all(val >= x for val in a[i:hi])` 在右侧。返回值为可插入的第一个位置(有相同的item).\n\n`bisect.bisect_right(a, x, lo=0, hi=len(a))`\n\n`bisect.bisect(a, x, lo=0, hi=len(a))`\n\n这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即`all(val <= x for val in a[lo:i])` 在左侧 `all(val > x for val in a[i:hi])` 在右侧。\n\n#### 插入：\n`bisect.insort_left(a, x, lo=0, hi=len(a))`\n\n函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).\n\n`bisect.insort_right(a, x, lo=0, hi=len(a))`\n\n`bisect.insort(a, x, lo=0, hi=len(a))`\n\n\n## 事例讲解\n用一个排序后的lists查找案例来练习一下吧。\n\n```\ndef index(a, x):\n    'Locate the leftmost value exactly equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n\ndef find_lt(a, x):\n    'Find rightmost value less than x'\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_le(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect.bisect_right(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bisect.bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n\n\ndef find_ge(a, x):\n    'Find leftmost item greater than or equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n```\n\n\n## 进入正题\n\n最后leetcode的题目是：\n\nImplement a MyCalendar class to store your events.\nA new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end).\nFormally, this represents a booking on the half open interval [start, end),\nthe range of real numbers x such that start <= x < end.\nA double booking happens when two events have some non-empty intersection\n(ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book,\nreturn true if the event can be added to the calendar successfully without causing a double booking. Otherwise,\nreturn false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n\n代码：\n\n```\nimport bisect\n\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.calendar = []\n        self._start_sorted = []\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        if not self.calendar:\n            self.calendar += (start, end),\n            self._start_sorted += start,\n            return True\n        floor_index = bisect.bisect_left(self._start_sorted, start)\n        if floor_index and self.calendar[floor_index - 1][1] > start:\n                return False\n\n        ceiling_index = bisect.bisect_right(self._start_sorted, start)\n        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] < end:\n                return False\n        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] < end:\n                return False\n\n        self.calendar.insert(floor_index, (start, end))\n        self._start_sorted.insert(floor_index, start)\n        return True\n```\n\n## 最后\n详细的代码和用例：\n[https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py](https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py)\n\n\n","source":"_posts/Python内置模块bisect介绍.md","raw":"---\ntitle: Python内置模块bisect介绍\ndate: 2017-11-20 14:33:07\ntags: Python\n---\n\n\n\n在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的**bisect**模块.\t\n\n## 介绍\n\n对于bisect，官网的解释是：\n\nThis module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).\n\n大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。\n\n## 模块内提供的函数\n\n#### 查找：\n\n`bisect.bisect_left(a, x, lo=0, hi=len(a))`\n\na是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使`all(val < x for val in a[lo:i])` 在左侧， `all(val >= x for val in a[i:hi])` 在右侧。返回值为可插入的第一个位置(有相同的item).\n\n`bisect.bisect_right(a, x, lo=0, hi=len(a))`\n\n`bisect.bisect(a, x, lo=0, hi=len(a))`\n\n这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即`all(val <= x for val in a[lo:i])` 在左侧 `all(val > x for val in a[i:hi])` 在右侧。\n\n#### 插入：\n`bisect.insort_left(a, x, lo=0, hi=len(a))`\n\n函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).\n\n`bisect.insort_right(a, x, lo=0, hi=len(a))`\n\n`bisect.insort(a, x, lo=0, hi=len(a))`\n\n\n## 事例讲解\n用一个排序后的lists查找案例来练习一下吧。\n\n```\ndef index(a, x):\n    'Locate the leftmost value exactly equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n\ndef find_lt(a, x):\n    'Find rightmost value less than x'\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_le(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect.bisect_right(a, x)\n    if i:\n        return a[i - 1]\n    raise ValueError\n\n\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bisect.bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n\n\ndef find_ge(a, x):\n    'Find leftmost item greater than or equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\n```\n\n\n## 进入正题\n\n最后leetcode的题目是：\n\nImplement a MyCalendar class to store your events.\nA new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end).\nFormally, this represents a booking on the half open interval [start, end),\nthe range of real numbers x such that start <= x < end.\nA double booking happens when two events have some non-empty intersection\n(ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book,\nreturn true if the event can be added to the calendar successfully without causing a double booking. Otherwise,\nreturn false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n\n代码：\n\n```\nimport bisect\n\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.calendar = []\n        self._start_sorted = []\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        if not self.calendar:\n            self.calendar += (start, end),\n            self._start_sorted += start,\n            return True\n        floor_index = bisect.bisect_left(self._start_sorted, start)\n        if floor_index and self.calendar[floor_index - 1][1] > start:\n                return False\n\n        ceiling_index = bisect.bisect_right(self._start_sorted, start)\n        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] < end:\n                return False\n        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] < end:\n                return False\n\n        self.calendar.insert(floor_index, (start, end))\n        self._start_sorted.insert(floor_index, start)\n        return True\n```\n\n## 最后\n详细的代码和用例：\n[https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py](https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py)\n\n\n","slug":"Python内置模块bisect介绍","published":1,"updated":"2017-11-20T06:34:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqh002glvtllcyjfdqk","content":"<p>在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的<strong>bisect</strong>模块.    </p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于bisect，官网的解释是：</p>\n<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>\n<p>大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。</p>\n<h2 id=\"模块内提供的函数\"><a href=\"#模块内提供的函数\" class=\"headerlink\" title=\"模块内提供的函数\"></a>模块内提供的函数</h2><h4 id=\"查找：\"><a href=\"#查找：\" class=\"headerlink\" title=\"查找：\"></a>查找：</h4><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></p>\n<p>a是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使<code>all(val &lt; x for val in a[lo:i])</code> 在左侧， <code>all(val &gt;= x for val in a[i:hi])</code> 在右侧。返回值为可插入的第一个位置(有相同的item).</p>\n<p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></p>\n<p>这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即<code>all(val &lt;= x for val in a[lo:i])</code> 在左侧 <code>all(val &gt; x for val in a[i:hi])</code> 在右侧。</p>\n<h4 id=\"插入：\"><a href=\"#插入：\" class=\"headerlink\" title=\"插入：\"></a>插入：</h4><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></p>\n<p>函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).</p>\n<p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.insort(a, x, lo=0, hi=len(a))</code></p>\n<h2 id=\"事例讲解\"><a href=\"#事例讲解\" class=\"headerlink\" title=\"事例讲解\"></a>事例讲解</h2><p>用一个排序后的lists查找案例来练习一下吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def index(a, x):</div><div class=\"line\">    &apos;Locate the leftmost value exactly equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a) and a[i] == x:</div><div class=\"line\">        return i</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_lt(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_le(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_gt(a, x):</div><div class=\"line\">    &apos;Find leftmost value greater than x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_ge(a, x):</div><div class=\"line\">    &apos;Find leftmost item greater than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div></pre></td></tr></table></figure>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><p>最后leetcode的题目是：</p>\n<p>Implement a MyCalendar class to store your events.<br>A new event can be added if adding the event will not cause a double booking.<br>Your class will have the method, book(int start, int end).<br>Formally, this represents a booking on the half open interval [start, end),<br>the range of real numbers x such that start &lt;= x &lt; end.<br>A double booking happens when two events have some non-empty intersection<br>(ie., there is some time that is common to both events.)<br>For each call to the method MyCalendar.book,<br>return true if the event can be added to the calendar successfully without causing a double booking. Otherwise,<br>return false and do not add the event to the calendar.<br>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">import bisect</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class MyCalendar(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        self.calendar = []</div><div class=\"line\">        self._start_sorted = []</div><div class=\"line\"></div><div class=\"line\">    def book(self, start, end):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type start: int</div><div class=\"line\">        :type end: int</div><div class=\"line\">        :rtype: bool</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        if not self.calendar:</div><div class=\"line\">            self.calendar += (start, end),</div><div class=\"line\">            self._start_sorted += start,</div><div class=\"line\">            return True</div><div class=\"line\">        floor_index = bisect.bisect_left(self._start_sorted, start)</div><div class=\"line\">        if floor_index and self.calendar[floor_index - 1][1] &gt; start:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        ceiling_index = bisect.bisect_right(self._start_sorted, start)</div><div class=\"line\">        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\">        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        self.calendar.insert(floor_index, (start, end))</div><div class=\"line\">        self._start_sorted.insert(floor_index, start)</div><div class=\"line\">        return True</div></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>详细的代码和用例：<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的<strong>bisect</strong>模块.    </p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于bisect，官网的解释是：</p>\n<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>\n<p>大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。</p>\n<h2 id=\"模块内提供的函数\"><a href=\"#模块内提供的函数\" class=\"headerlink\" title=\"模块内提供的函数\"></a>模块内提供的函数</h2><h4 id=\"查找：\"><a href=\"#查找：\" class=\"headerlink\" title=\"查找：\"></a>查找：</h4><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></p>\n<p>a是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使<code>all(val &lt; x for val in a[lo:i])</code> 在左侧， <code>all(val &gt;= x for val in a[i:hi])</code> 在右侧。返回值为可插入的第一个位置(有相同的item).</p>\n<p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></p>\n<p>这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即<code>all(val &lt;= x for val in a[lo:i])</code> 在左侧 <code>all(val &gt; x for val in a[i:hi])</code> 在右侧。</p>\n<h4 id=\"插入：\"><a href=\"#插入：\" class=\"headerlink\" title=\"插入：\"></a>插入：</h4><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></p>\n<p>函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).</p>\n<p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></p>\n<p><code>bisect.insort(a, x, lo=0, hi=len(a))</code></p>\n<h2 id=\"事例讲解\"><a href=\"#事例讲解\" class=\"headerlink\" title=\"事例讲解\"></a>事例讲解</h2><p>用一个排序后的lists查找案例来练习一下吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">def index(a, x):</div><div class=\"line\">    &apos;Locate the leftmost value exactly equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a) and a[i] == x:</div><div class=\"line\">        return i</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_lt(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_le(a, x):</div><div class=\"line\">    &apos;Find rightmost value less than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i:</div><div class=\"line\">        return a[i - 1]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_gt(a, x):</div><div class=\"line\">    &apos;Find leftmost value greater than x&apos;</div><div class=\"line\">    i = bisect.bisect_right(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def find_ge(a, x):</div><div class=\"line\">    &apos;Find leftmost item greater than or equal to x&apos;</div><div class=\"line\">    i = bisect.bisect_left(a, x)</div><div class=\"line\">    if i != len(a):</div><div class=\"line\">        return a[i]</div><div class=\"line\">    raise ValueError</div></pre></td></tr></table></figure>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><p>最后leetcode的题目是：</p>\n<p>Implement a MyCalendar class to store your events.<br>A new event can be added if adding the event will not cause a double booking.<br>Your class will have the method, book(int start, int end).<br>Formally, this represents a booking on the half open interval [start, end),<br>the range of real numbers x such that start &lt;= x &lt; end.<br>A double booking happens when two events have some non-empty intersection<br>(ie., there is some time that is common to both events.)<br>For each call to the method MyCalendar.book,<br>return true if the event can be added to the calendar successfully without causing a double booking. Otherwise,<br>return false and do not add the event to the calendar.<br>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">import bisect</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class MyCalendar(object):</div><div class=\"line\">    def __init__(self):</div><div class=\"line\">        self.calendar = []</div><div class=\"line\">        self._start_sorted = []</div><div class=\"line\"></div><div class=\"line\">    def book(self, start, end):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type start: int</div><div class=\"line\">        :type end: int</div><div class=\"line\">        :rtype: bool</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        if not self.calendar:</div><div class=\"line\">            self.calendar += (start, end),</div><div class=\"line\">            self._start_sorted += start,</div><div class=\"line\">            return True</div><div class=\"line\">        floor_index = bisect.bisect_left(self._start_sorted, start)</div><div class=\"line\">        if floor_index and self.calendar[floor_index - 1][1] &gt; start:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        ceiling_index = bisect.bisect_right(self._start_sorted, start)</div><div class=\"line\">        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\">        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] &lt; end:</div><div class=\"line\">                return False</div><div class=\"line\"></div><div class=\"line\">        self.calendar.insert(floor_index, (start, end))</div><div class=\"line\">        self._start_sorted.insert(floor_index, start)</div><div class=\"line\">        return True</div></pre></td></tr></table></figure>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>详细的代码和用例：<br><a href=\"https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py\" target=\"_blank\" rel=\"external\">https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py</a></p>\n"},{"title":"检查清单 Report","date":"2017-11-04T07:27:45.000Z","_content":"写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，并集|，交集&，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n用assert 来确定数据是可用的(assert A,B = if not A do B)\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n\n\n团队沟通\n\n\n换位思考，从对方的思路开始思考，先明白对方问题的原因。\n\n\n不仅要有自己的想法，还要对于想法有可行的方案。\n\n\n前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！\n\n\nHTML操作\n\n\nw3lib.html.remove_tags()可以过滤Html标签。\n\n","source":"_posts/检查清单.md","raw":"---\ntitle: 检查清单 Report\ndate: 2017-11-04 15:27:45\ntags: 清单\n---\n写代码前\n\n\n写代码的要思考到明确\n做什么\n，而不仅仅是\n怎么做\n。\n\n\n先Google,gitHub看看有没有已经成熟的思路，先找资源。\n\n\n把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。\n\n\n如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。\n\n\n文件操作\n\n\n操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。\n\n\n数据结构\n\n\n注意可变对象和不可变对象（list和dict），防止做参数时被污染。\n\n\n数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。\n\n\n对数据集有操作，一定要用Set，并集|，交集&，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）\n\n\n检查需要\n\n\n先检查输入类型，用isinstance去限定所需要的数据类型。\n\n\n输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。\n\n\n数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。\n\n\n用assert 来确定数据是可用的(assert A,B = if not A do B)\n\n\n节约资源的方法\n\n\nreduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。\n\n\n数据库操作\n\n\n对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。\n\n\n对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。\n\n\n尽量不要用Where这种隐形连接，用Inner Join这种显性连接。\n\n\n对数据库有操作，要用log记录下来，以便数据恢复使用。\n\n\n错误处理\n\n\n死循环，给第一行print，第二行continue。\n\n\n如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 \n\n\n团队沟通\n\n\n换位思考，从对方的思路开始思考，先明白对方问题的原因。\n\n\n不仅要有自己的想法，还要对于想法有可行的方案。\n\n\n前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！\n\n\nHTML操作\n\n\nw3lib.html.remove_tags()可以过滤Html标签。\n\n","slug":"检查清单","published":1,"updated":"2017-11-04T09:31:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqi002jlvtl2ivkz992","content":"<p>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，并集|，交集&amp;，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>用assert 来确定数据是可用的(assert A,B = if not A do B)</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 </p>\n<p>团队沟通</p>\n<p>换位思考，从对方的思路开始思考，先明白对方问题的原因。</p>\n<p>不仅要有自己的想法，还要对于想法有可行的方案。</p>\n<p>前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！</p>\n<p>HTML操作</p>\n<p>w3lib.html.remove_tags()可以过滤Html标签。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写代码前</p>\n<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>\n<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>\n<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>\n<p>如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。</p>\n<p>文件操作</p>\n<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>\n<p>数据结构</p>\n<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>\n<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>\n<p>对数据集有操作，一定要用Set，并集|，交集&amp;，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）</p>\n<p>检查需要</p>\n<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>\n<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>\n<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>\n<p>用assert 来确定数据是可用的(assert A,B = if not A do B)</p>\n<p>节约资源的方法</p>\n<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>\n<p>数据库操作</p>\n<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>\n<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>\n<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>\n<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>\n<p>错误处理</p>\n<p>死循环，给第一行print，第二行continue。</p>\n<p>如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 </p>\n<p>团队沟通</p>\n<p>换位思考，从对方的思路开始思考，先明白对方问题的原因。</p>\n<p>不仅要有自己的想法，还要对于想法有可行的方案。</p>\n<p>前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！</p>\n<p>HTML操作</p>\n<p>w3lib.html.remove_tags()可以过滤Html标签。</p>\n"},{"title":"函数式编程 Report","date":"2017-11-04T07:27:45.000Z","_content":"函数式编程\n不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你\n1）代码更简单了。\n2）数据集，操作，返回值都放到了一起。\n3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。\n4）你的代码变成了在描述你要干什么，而不是怎么去干","source":"_posts/函数式编程.md","raw":"---\ntitle: 函数式编程 Report\ndate: 2017-11-04 15:27:45\ntags: 函数式\n---\n函数式编程\n不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你\n1）代码更简单了。\n2）数据集，操作，返回值都放到了一起。\n3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。\n4）你的代码变成了在描述你要干什么，而不是怎么去干","slug":"函数式编程","published":1,"updated":"2017-11-04T09:32:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqj002llvtl9rvhvuwz","content":"<p>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干</p>\n","site":{"data":{}},"excerpt":"","more":"<p>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干</p>\n"},{"title":"问题清单 Report","date":"2017-11-04T07:27:45.000Z","_content":"\n\n整理一下Git分支的知识\n\n\nfrom sqlalchemy import Column, Integer, String\n\n\n\n\n\n\nclass User(Base):\n…     \ntablename\n = ‘users’\n…\n…     id = Column(Integer, primary_key=True)\n…     name = Column(String)\n…     fullname = Column(String)\n…     password = Column(String)\n…\n…     def \nrepr\n(self):\n…        return “\n“ % (\n…                             self.name, self.fullname, self.password)\n\n\n\n\n\n\n\n\n\n\njson.dumps()把python结构变成json， json.loads()反之 \n\n\nTypeError: vars() argument must have \ndict\n attribute vars可以得到\ndict\n的属性值\n\n\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.\n\n\nfrom collections import deque , \nuse deque \nlike a queue\n\n\n如何使用sqlalchemy搭配scrapy 减少参数配置呢？？？\n\n\nCounter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。\n\n\nhow to realize keys option?\n\n\n为什么同一个路径下搜索不到文件，pycharm中的terminal有问题，\n\n\n绝对路径相对于文件还是运行位置的理解，看os源码理解。设计一套方法预先解决运行路径变更的问题。\n\n\n为什么%s可以 但是{}会出问题？？\n\n\n最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。\n\n\n为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。\n这里对 object() 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。\n\n\n数据集我已经拥有？！！！！\n\n\n我觉得LeakPasswd这个Project背后用的是类似华西安全网的APi.\n\n\ngoogle analytics\n\n\n\n","source":"_posts/问题清单.md","raw":"---\ntitle: 问题清单 Report\ndate: 2017-11-04 15:27:45\ntags: 清单\n---\n\n\n整理一下Git分支的知识\n\n\nfrom sqlalchemy import Column, Integer, String\n\n\n\n\n\n\nclass User(Base):\n…     \ntablename\n = ‘users’\n…\n…     id = Column(Integer, primary_key=True)\n…     name = Column(String)\n…     fullname = Column(String)\n…     password = Column(String)\n…\n…     def \nrepr\n(self):\n…        return “\n“ % (\n…                             self.name, self.fullname, self.password)\n\n\n\n\n\n\n\n\n\n\njson.dumps()把python结构变成json， json.loads()反之 \n\n\nTypeError: vars() argument must have \ndict\n attribute vars可以得到\ndict\n的属性值\n\n\nlist.extend(iterable)\nExtend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.\n\n\nfrom collections import deque , \nuse deque \nlike a queue\n\n\n如何使用sqlalchemy搭配scrapy 减少参数配置呢？？？\n\n\nCounter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。\n\n\nhow to realize keys option?\n\n\n为什么同一个路径下搜索不到文件，pycharm中的terminal有问题，\n\n\n绝对路径相对于文件还是运行位置的理解，看os源码理解。设计一套方法预先解决运行路径变更的问题。\n\n\n为什么%s可以 但是{}会出问题？？\n\n\n最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。\n\n\n为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。\n这里对 object() 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。\n\n\n数据集我已经拥有？！！！！\n\n\n我觉得LeakPasswd这个Project背后用的是类似华西安全网的APi.\n\n\ngoogle analytics\n\n\n\n","slug":"问题清单","published":1,"updated":"2017-11-04T09:31:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqk002olvtl2uw8nc91","content":"<p>整理一下Git分支的知识</p>\n<p>from sqlalchemy import Column, Integer, String</p>\n<p>class User(Base):<br>…<br>tablename<br> = ‘users’<br>…<br>…     id = Column(Integer, primary_key=True)<br>…     name = Column(String)<br>…     fullname = Column(String)<br>…     password = Column(String)<br>…<br>…     def<br>repr<br>(self):<br>…        return “<br>“ % (<br>…                             self.name, self.fullname, self.password)</p>\n<p>json.dumps()把python结构变成json， json.loads()反之 </p>\n<p>TypeError: vars() argument must have<br>dict<br> attribute vars可以得到<br>dict<br>的属性值</p>\n<p>list.extend(iterable)<br>Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.</p>\n<p>from collections import deque ,<br>use deque<br>like a queue</p>\n<p>如何使用sqlalchemy搭配scrapy 减少参数配置呢？？？</p>\n<p>Counter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。</p>\n<p>how to realize keys option?</p>\n<p>为什么同一个路径下搜索不到文件，pycharm中的terminal有问题，</p>\n<p>绝对路径相对于文件还是运行位置的理解，看os源码理解。设计一套方法预先解决运行路径变更的问题。</p>\n<p>为什么%s可以 但是{}会出问题？？</p>\n<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。</p>\n<p>为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>这里对 object() 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>\n<p>数据集我已经拥有？！！！！</p>\n<p>我觉得LeakPasswd这个Project背后用的是类似华西安全网的APi.</p>\n<p>google analytics</p>\n","site":{"data":{}},"excerpt":"","more":"<p>整理一下Git分支的知识</p>\n<p>from sqlalchemy import Column, Integer, String</p>\n<p>class User(Base):<br>…<br>tablename<br> = ‘users’<br>…<br>…     id = Column(Integer, primary_key=True)<br>…     name = Column(String)<br>…     fullname = Column(String)<br>…     password = Column(String)<br>…<br>…     def<br>repr<br>(self):<br>…        return “<br>“ % (<br>…                             self.name, self.fullname, self.password)</p>\n<p>json.dumps()把python结构变成json， json.loads()反之 </p>\n<p>TypeError: vars() argument must have<br>dict<br> attribute vars可以得到<br>dict<br>的属性值</p>\n<p>list.extend(iterable)<br>Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.</p>\n<p>from collections import deque ,<br>use deque<br>like a queue</p>\n<p>如何使用sqlalchemy搭配scrapy 减少参数配置呢？？？</p>\n<p>Counter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。</p>\n<p>how to realize keys option?</p>\n<p>为什么同一个路径下搜索不到文件，pycharm中的terminal有问题，</p>\n<p>绝对路径相对于文件还是运行位置的理解，看os源码理解。设计一套方法预先解决运行路径变更的问题。</p>\n<p>为什么%s可以 但是{}会出问题？？</p>\n<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。</p>\n<p>为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>这里对 object() 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>\n<p>数据集我已经拥有？！！！！</p>\n<p>我觉得LeakPasswd这个Project背后用的是类似华西安全网的APi.</p>\n<p>google analytics</p>\n"},{"title":"联合-查找算法","date":"2017-11-06T05:26:47.000Z","_content":"介绍这个算法前，先梳理一些相关词组的概念：\n\n**并查集**： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.\n\n**Find(node)函数**： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.\n\n**Union(node_a, node_b)函数**： 将两个子集合并成同一个集合.\n\n**并查集森林**： 并查集森林中每个节点保存的都是其父节点的引用。\n\n**下面从基础版本分析，再到两种优化来讲解这个算法。**\n\n* 基础版本的联合-查找算法：\n\n```\n\tdef find(node):\n\t\tif parent[node] == node:\n\t\t\treturn node\n\t\telse:\n\t\t\treturn find(parent[node])\n\t\t\t\n\tdef union(node_a, node_b):\n\t\troot_a = find(node_a)\n\t\troot_b = find(nond_b)\n\t\tparent[root_a] = roo_b\n\n```\n这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。\n\n* 按秩合并\n\n```\n    def union(node_a, node_b):\n        root_a = get_parent(node_a)\n        root_b = get_parent(node_b)\n\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        elif rank[root_a] < rank[root_b]:\n            parent[root_a] = root_b\n        else:\n        \t  parent[root_a] = root_b\n            rank[root_b] += 1\n```\n这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).\n\n* 路径压缩\n\n```\n    def get_parent(node):\n        if parent[node] == node:\n            return node\n        parent[node] = get_parent(parent[node])\n        return parent[node]\n```\n在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。\n\n\n### 扩展\n**我们用一道题目来梳理一下这个算法。**\n\nLeet Code Weekly Contest 57 里有一道题目：\n\nGiven a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n题目的**大意**是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。\n\n```\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n\n        def get_parent(node):\n            if parent[node] == node:\n                return node\n            parent[node] = get_parent(parent[node])\n            return parent[node]\n\n        def union(node_a, node_b):\n            root_a = get_parent(node_a)\n            root_b = get_parent(node_b)\n\n            if rank[root_a] < rank[root_b]:\n                parent[root_a] = root_b\n            else:\n                parent[root_b] = root_a\n                rank[root_a] += 1\n\n        rank = collections.defaultdict(int)\n        parent = {}\n        owner = {}\n        result = collections.defaultdict(list)\n        emails_set = set()\n\n        for i, account in enumerate(accounts):\n            name, emails = account[0], account[1:]\n            for email in emails:\n                emails_set.add(email)\n                owner[email] = name\n                if email not in parent:  # 生成并查集森林\n                    parent[email] = email\n\n            for email in emails[1:]:  \n                union(emails[0], email)\n\n        for email in emails_set:\n            result[get_parent(email)].append(email)\n        return [[owner[email]] + sorted(result[email]) for email in result]\n```\n\n\n","source":"_posts/联合-查找算法.md","raw":"---\ntitle: 联合-查找算法\ndate: 2017-11-06 13:26:47\ntags: 算法\n---\n介绍这个算法前，先梳理一些相关词组的概念：\n\n**并查集**： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.\n\n**Find(node)函数**： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.\n\n**Union(node_a, node_b)函数**： 将两个子集合并成同一个集合.\n\n**并查集森林**： 并查集森林中每个节点保存的都是其父节点的引用。\n\n**下面从基础版本分析，再到两种优化来讲解这个算法。**\n\n* 基础版本的联合-查找算法：\n\n```\n\tdef find(node):\n\t\tif parent[node] == node:\n\t\t\treturn node\n\t\telse:\n\t\t\treturn find(parent[node])\n\t\t\t\n\tdef union(node_a, node_b):\n\t\troot_a = find(node_a)\n\t\troot_b = find(nond_b)\n\t\tparent[root_a] = roo_b\n\n```\n这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。\n\n* 按秩合并\n\n```\n    def union(node_a, node_b):\n        root_a = get_parent(node_a)\n        root_b = get_parent(node_b)\n\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        elif rank[root_a] < rank[root_b]:\n            parent[root_a] = root_b\n        else:\n        \t  parent[root_a] = root_b\n            rank[root_b] += 1\n```\n这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).\n\n* 路径压缩\n\n```\n    def get_parent(node):\n        if parent[node] == node:\n            return node\n        parent[node] = get_parent(parent[node])\n        return parent[node]\n```\n在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。\n\n\n### 扩展\n**我们用一道题目来梳理一下这个算法。**\n\nLeet Code Weekly Contest 57 里有一道题目：\n\nGiven a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n题目的**大意**是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。\n\n```\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n\n        def get_parent(node):\n            if parent[node] == node:\n                return node\n            parent[node] = get_parent(parent[node])\n            return parent[node]\n\n        def union(node_a, node_b):\n            root_a = get_parent(node_a)\n            root_b = get_parent(node_b)\n\n            if rank[root_a] < rank[root_b]:\n                parent[root_a] = root_b\n            else:\n                parent[root_b] = root_a\n                rank[root_a] += 1\n\n        rank = collections.defaultdict(int)\n        parent = {}\n        owner = {}\n        result = collections.defaultdict(list)\n        emails_set = set()\n\n        for i, account in enumerate(accounts):\n            name, emails = account[0], account[1:]\n            for email in emails:\n                emails_set.add(email)\n                owner[email] = name\n                if email not in parent:  # 生成并查集森林\n                    parent[email] = email\n\n            for email in emails[1:]:  \n                union(emails[0], email)\n\n        for email in emails_set:\n            result[get_parent(email)].append(email)\n        return [[owner[email]] + sorted(result[email]) for email in result]\n```\n\n\n","slug":"联合-查找算法","published":1,"updated":"2017-11-29T04:37:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb4j8oqk002qlvtlg0ciqa7j","content":"<p>介绍这个算法前，先梳理一些相关词组的概念：</p>\n<p><strong>并查集</strong>： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.</p>\n<p><strong>Find(node)函数</strong>： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.</p>\n<p><strong>Union(node_a, node_b)函数</strong>： 将两个子集合并成同一个集合.</p>\n<p><strong>并查集森林</strong>： 并查集森林中每个节点保存的都是其父节点的引用。</p>\n<p><strong>下面从基础版本分析，再到两种优化来讲解这个算法。</strong></p>\n<ul>\n<li>基础版本的联合-查找算法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def find(node):</div><div class=\"line\">\tif parent[node] == node:</div><div class=\"line\">\t\treturn node</div><div class=\"line\">\telse:</div><div class=\"line\">\t\treturn find(parent[node])</div><div class=\"line\">\t\t</div><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">\troot_a = find(node_a)</div><div class=\"line\">\troot_b = find(nond_b)</div><div class=\"line\">\tparent[root_a] = roo_b</div></pre></td></tr></table></figure>\n<p>这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。</p>\n<ul>\n<li>按秩合并</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">    root_a = get_parent(node_a)</div><div class=\"line\">    root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">    if rank[root_a] &gt; rank[root_b]:</div><div class=\"line\">        parent[root_b] = root_a</div><div class=\"line\">    elif rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">        parent[root_a] = root_b</div><div class=\"line\">    else:</div><div class=\"line\">    \t  parent[root_a] = root_b</div><div class=\"line\">        rank[root_b] += 1</div></pre></td></tr></table></figure>\n<p>这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).</p>\n<ul>\n<li>路径压缩</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def get_parent(node):</div><div class=\"line\">    if parent[node] == node:</div><div class=\"line\">        return node</div><div class=\"line\">    parent[node] = get_parent(parent[node])</div><div class=\"line\">    return parent[node]</div></pre></td></tr></table></figure>\n<p>在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><strong>我们用一道题目来梳理一下这个算法。</strong></p>\n<p>Leet Code Weekly Contest 57 里有一道题目：</p>\n<p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.</p>\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n<p>After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>\n<p>题目的<strong>大意</strong>是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    def accountsMerge(self, accounts):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type accounts: List[List[str]]</div><div class=\"line\">        :rtype: List[List[str]]</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">        def get_parent(node):</div><div class=\"line\">            if parent[node] == node:</div><div class=\"line\">                return node</div><div class=\"line\">            parent[node] = get_parent(parent[node])</div><div class=\"line\">            return parent[node]</div><div class=\"line\"></div><div class=\"line\">        def union(node_a, node_b):</div><div class=\"line\">            root_a = get_parent(node_a)</div><div class=\"line\">            root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">            if rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">                parent[root_a] = root_b</div><div class=\"line\">            else:</div><div class=\"line\">                parent[root_b] = root_a</div><div class=\"line\">                rank[root_a] += 1</div><div class=\"line\"></div><div class=\"line\">        rank = collections.defaultdict(int)</div><div class=\"line\">        parent = &#123;&#125;</div><div class=\"line\">        owner = &#123;&#125;</div><div class=\"line\">        result = collections.defaultdict(list)</div><div class=\"line\">        emails_set = set()</div><div class=\"line\"></div><div class=\"line\">        for i, account in enumerate(accounts):</div><div class=\"line\">            name, emails = account[0], account[1:]</div><div class=\"line\">            for email in emails:</div><div class=\"line\">                emails_set.add(email)</div><div class=\"line\">                owner[email] = name</div><div class=\"line\">                if email not in parent:  # 生成并查集森林</div><div class=\"line\">                    parent[email] = email</div><div class=\"line\"></div><div class=\"line\">            for email in emails[1:]:  </div><div class=\"line\">                union(emails[0], email)</div><div class=\"line\"></div><div class=\"line\">        for email in emails_set:</div><div class=\"line\">            result[get_parent(email)].append(email)</div><div class=\"line\">        return [[owner[email]] + sorted(result[email]) for email in result]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍这个算法前，先梳理一些相关词组的概念：</p>\n<p><strong>并查集</strong>： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.</p>\n<p><strong>Find(node)函数</strong>： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.</p>\n<p><strong>Union(node_a, node_b)函数</strong>： 将两个子集合并成同一个集合.</p>\n<p><strong>并查集森林</strong>： 并查集森林中每个节点保存的都是其父节点的引用。</p>\n<p><strong>下面从基础版本分析，再到两种优化来讲解这个算法。</strong></p>\n<ul>\n<li>基础版本的联合-查找算法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">def find(node):</div><div class=\"line\">\tif parent[node] == node:</div><div class=\"line\">\t\treturn node</div><div class=\"line\">\telse:</div><div class=\"line\">\t\treturn find(parent[node])</div><div class=\"line\">\t\t</div><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">\troot_a = find(node_a)</div><div class=\"line\">\troot_b = find(nond_b)</div><div class=\"line\">\tparent[root_a] = roo_b</div></pre></td></tr></table></figure>\n<p>这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。</p>\n<ul>\n<li>按秩合并</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">def union(node_a, node_b):</div><div class=\"line\">    root_a = get_parent(node_a)</div><div class=\"line\">    root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">    if rank[root_a] &gt; rank[root_b]:</div><div class=\"line\">        parent[root_b] = root_a</div><div class=\"line\">    elif rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">        parent[root_a] = root_b</div><div class=\"line\">    else:</div><div class=\"line\">    \t  parent[root_a] = root_b</div><div class=\"line\">        rank[root_b] += 1</div></pre></td></tr></table></figure>\n<p>这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).</p>\n<ul>\n<li>路径压缩</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">def get_parent(node):</div><div class=\"line\">    if parent[node] == node:</div><div class=\"line\">        return node</div><div class=\"line\">    parent[node] = get_parent(parent[node])</div><div class=\"line\">    return parent[node]</div></pre></td></tr></table></figure>\n<p>在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><strong>我们用一道题目来梳理一下这个算法。</strong></p>\n<p>Leet Code Weekly Contest 57 里有一道题目：</p>\n<p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.</p>\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n<p>After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>\n<p>题目的<strong>大意</strong>是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    def accountsMerge(self, accounts):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type accounts: List[List[str]]</div><div class=\"line\">        :rtype: List[List[str]]</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">        def get_parent(node):</div><div class=\"line\">            if parent[node] == node:</div><div class=\"line\">                return node</div><div class=\"line\">            parent[node] = get_parent(parent[node])</div><div class=\"line\">            return parent[node]</div><div class=\"line\"></div><div class=\"line\">        def union(node_a, node_b):</div><div class=\"line\">            root_a = get_parent(node_a)</div><div class=\"line\">            root_b = get_parent(node_b)</div><div class=\"line\"></div><div class=\"line\">            if rank[root_a] &lt; rank[root_b]:</div><div class=\"line\">                parent[root_a] = root_b</div><div class=\"line\">            else:</div><div class=\"line\">                parent[root_b] = root_a</div><div class=\"line\">                rank[root_a] += 1</div><div class=\"line\"></div><div class=\"line\">        rank = collections.defaultdict(int)</div><div class=\"line\">        parent = &#123;&#125;</div><div class=\"line\">        owner = &#123;&#125;</div><div class=\"line\">        result = collections.defaultdict(list)</div><div class=\"line\">        emails_set = set()</div><div class=\"line\"></div><div class=\"line\">        for i, account in enumerate(accounts):</div><div class=\"line\">            name, emails = account[0], account[1:]</div><div class=\"line\">            for email in emails:</div><div class=\"line\">                emails_set.add(email)</div><div class=\"line\">                owner[email] = name</div><div class=\"line\">                if email not in parent:  # 生成并查集森林</div><div class=\"line\">                    parent[email] = email</div><div class=\"line\"></div><div class=\"line\">            for email in emails[1:]:  </div><div class=\"line\">                union(emails[0], email)</div><div class=\"line\"></div><div class=\"line\">        for email in emails_set:</div><div class=\"line\">            result[get_parent(email)].append(email)</div><div class=\"line\">        return [[owner[email]] + sorted(result[email]) for email in result]</div></pre></td></tr></table></figure>\n"},{"title":"Python asyncio模块介绍","date":"2017-12-19T15:00:51.000Z","_content":"\n\n## Preface\n\n本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。\n\n注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。\n\n## A comparison between a simple threaded program and the asyncio equivalent\n\n我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。\n\nThread demo:\n\n```\nclass Signal:\n    go = True\n\n\ndef spin(msg, signal):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        time.sleep(.1)\n        if not signal.go:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n\ndef slow_function():\n    time.sleep(3)\n    return 42\n\n\ndef supervisor():\n    signal = Signal()\n    spinner = threading.Thread(target=spin,\n                               args=('thinkg!', signal))\n    print('spinner object:', spinner)\n    spinner.start()\n    result = slow_function()\n    signal.go = False\n    spinner.join()\n    return result\n\ndef main():\n    result = supervisor()\n    print('Answer:', result)\n因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。\n```\n注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。\n\n\n### 关于asyncio版本的代码做几点解释：\n1.  Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.\n2. 使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。\n3. 当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。\n4. aysncio.async(...)安排spin coroutine去运行，将其封装成Task对象后立即返回。\n5. Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。\n6. run_ until_ complete()会驱动coroutine运行，返回的结果是coroutine的返回值。\n\n```\n@asyncio.coroutine\ndef spin(msg):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        try:\n            yield from asyncio.sleep(.1)\n        except asyncio.CancelledError:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n@asyncio.coroutine\ndef slow_function():\n    yield from asyncio.sleep(3)\n    return 42\n\n@asyncio.coroutine\ndef supervisor():\n    spinner = asyncio.ensure_future(spin('thinking!'))\n    print('spinner object:', spinner)\n    result = yield from slow_function()\n    spinner.cancel()\n    return result\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(supervisor())\n    loop.close()\n    print('Answer:', result)\n```\n\n\n对比上面两个版本的demo,解释一下它们之间的区别：\n\n1. 一个Task驱动一个coroutine,一个线程调用一个callable.\n2. 我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(...)或者loop.create_ task(...)来获得Task对象。\n3. 当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。\n4. 在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。\n5. 没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。\n6. supervisor必须在main函数中通过loop.run_ until_ complete()调用。\n7. 在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。\n\n## How the asyncio.Future class differs from concurrent.futures.Future\n如果你还不清楚future的概念，你可以参考我写的另一篇文章[Python concurrency with futures](http://www.ganbinwen.com/2017/12/13/Python-concurrency-with-futures/)，里面有相关介绍，或者可以自行参考官方文档/wiki。\n\n请务必确认已经清楚了future的概念后再阅读下面内容 :)\n\nasyncio中的future：\n\n* asyncio中Task是Future的子类,故Task也是Future。\n* 对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。\n* 对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。\n* yield from my_ future 相当于 my_ future.add_ done_ callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。\n\n\nasyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。\n为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：\n\n1. aysncio.async(coro_or_future, *, loop=None)\n\n\t*  这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create_ task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get_ event_ loop()来的到一个loop对象。\n\n\t\n2. BaseEventLoop.create_task(coro)\n\n\t* 这个方法安排coroutine操作，并且返回一个asyncio.Task对象。\n\t\n几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数\n\n```\nimport asyncio\n\n\ndef run_sync(coro_or_future):\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(coro_or_future)\n\n\n@asyncio.coroutine\ndef coro():\n    yield from asyncio.sleep(1)\n\n\nif __name__ == '__main__':\n    a = run_sync(coro())\n```\n \t \n\n## Asynchronous programming manages high concurrency in network applications, without using threads or processes\n\n我们使用aiohttp这个第三方库来完善我们的Http Client。\n\n```\n\nimport asyncio\nimport aiohttp\nimport time\nimport os\nimport sys\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    session = aiohttp.ClientSession()\n    res = yield from session.get(url)\n    # res = yield from aiohttp.request('GET', url) will occur error with 'Unclosed client session'.\n    image = yield from res.read()\n    session.close()\n    return image\n\n\n@asyncio.coroutine\ndef download_one(cc):\n    image = yield from get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\n\n# @asyncio.coroutine\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()\n    to_do = [download_one(cc) for cc in sorted(cc_list)]\n    wait_coro = asyncio.wait(to_do)\n    res, _ = loop.run_until_complete(wait_coro)\n    loop.close()\n\n    return len(res)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\nCN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE \n19 flags download in 3.85s\n```\nasyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例\n当事件循环运行时，loop.run_ until_ complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。\n\n这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get_ flag里用yield from驱动aiohttp所以get_ flag是一个coroutine，同样在download_ one里用yield from驱动get_ flag所以它也是一个coroutine，最后在download_ many通过loop.run_ until_ complete来驱动被asyncio.wait()方法实例过的Tasks。\n\n可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：\n\n1. 每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.\n2. 链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。\n\n当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：\n驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run_ until_ complete(...) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。\n\n\n## How coroutines are a major improvement over callbacks for asynchronous programming\n\n通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？\n\n对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：\n1. 让阻塞操作在不同的线程中运行。\n2. 让用非阻塞的异步操作来调用阻塞操作。\n\n我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。\n\n使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。\n\n```\n```\n\n\n## How to avoid blocking the event loop by offloading blocking operations to a thread pool\n尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？\n在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。\n\n```\n@asyncio.coroutine\ndef download_one(cc, base_url, semaphore, verbose):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(base_url, cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.NOT_FOUND\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(None, save_flags, image, cc.lower() + '.gif') # Avoiding blocking.\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose and msg:\n        print(cc, msg)\n\n    return Result(status, cc)\n```\n\n\n## Callback Hell\n关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：\n\n```\ndef stage1(response1):\n    request2 = step1(response1)\n    api_call2(request2, stage2)\n\ndef stage2(response2):\n    request3 = step2(response2)\n    api_call3(request3, stage3)\n\ndef stage3(response3):\n    step(response3)\n\napi_call(request1, stage1)\n```\n\n分析一下这种风格的代码：\n读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。\n接下来我们再用coroutine来完成上述逻辑。\n\n```\n@asyncio.coroutine\ndef three_stages(request1):\n    response1 = yield from api_call1(request1)\n\n    request2 = step1(response1)\n    response2 = yield from api_call2(request2)\n    \n    request3 = step2(response2)\n    response3 = yield from api_call3(request3)\n    \n    step3(request3)\n```\n不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。\n\n尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。\n\n\n\n## Writing asyncio servers, and how to rethink Web applications for high concurrency \n接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。\n\n```\nimport sys\nimport asyncio\n\nfrom Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?>'\nindex = UnicodeNameIndex()\n\n@asyncio.coroutine\ndef handle_queries(reader, writer):\n    while True:\n        writer.write(PROMPT)\n        yield from writer.drain()\n        data = yield from reader.readline()\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            query = '\\x00'\n        client = writer.get_extra_info('peername')\n        print('Received from {}: {!r}'.format(client, query))\n        if query:\n            if ord(query[:1]) < 32:\n                break\n            lines = list(index.find_description_strs(query))\n            if lines:\n                writer.writelines(line.encode() + CRLF for line in lines)\n            writer.write(index.status(query, len(lines)).encode() + CRLF)\n\n            yield from writer.drain()\n            print('Sent {} results'.format(len(lines)))\n    print('Close the client socket')\n    writer.close()\n\ndef main(address='127.0.0.1', port=2323):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)\n    server = loop.run_until_complete(server_coro)\n\n    host = server.sockets[0].getsockname()\n    print('Serving on {} Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    loop.run_until_complete(server.wait_closed())\n    loop.close()\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n```\n希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。\n\nTips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).\n\n\n接下来再看一下http版本的：\n\n```\n@asyncio.coroutine\ndef init(loop, address, port):\n    app = web.Application(loop=loop)\n    app.router.add_route('GET', '/', home)\n    handler = app.make_handler()\n    server = yield from loop.create_server(handler, address, port)\n\n    return server.sockets[0].getsockname()\n\n\ndef main(address='127.0.0.1', port=8888):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    host = loop.run_until_complete(init(loop, address, port))\n    print('Servering on {}. Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n    print('Server shutting down.')\n    loop.close()\n\n\ndef home(request):\n    query = request.GET.get('query', '').strip()\n    print('Query: {!r}'.format(query))\n    if query:\n        descriptions = list(index.find_descriptions(query))\n        res = '\\n'.join(ROW_TPL.format(**vars(descr))\n                        for descr in descriptions)\n        msg = index.status(query, len(descriptions))\n\n    else:\n        descriptions = []\n        res = ''\n        msg = 'Enter words describing characters.'\n\n    html = template.format(query, res, msg)\n\n    print('Sending {} results'.format(len(descriptions)))\n    return web.Response(content_type=CONTENT_TYPE, text=html)\n```\n\n对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。\n\n\n## Parallelism and Concurrency\n给大家分享《Fluent Python》中的一则quote.\n\n*Concurrency is about dealing with lots of things at once.*\n\n*Parallelism is about doing lots of things at once.*\n\n*Not the same, but related.*\n\n*One is about structure, one is about execution.*\n\n*Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.*  \n\n\t\t\t\t\t\t\t\t\t-----Rob Pike\n\t\t\t\t\t\t\t\t\t\n这段quote揭示了中文里的**并行**和**并发**的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。\n\n对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).\n\n## Summary\n最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)\n\n本文代码地址：[asycnio_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo)\n\n","source":"_posts/Python-asyncio模块介绍.md","raw":"---\ntitle: Python asyncio模块介绍\ndate: 2017-12-19 23:00:51\ntags: Python\n\n---\n\n\n## Preface\n\n本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。\n\n注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。\n\n## A comparison between a simple threaded program and the asyncio equivalent\n\n我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。\n\nThread demo:\n\n```\nclass Signal:\n    go = True\n\n\ndef spin(msg, signal):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        time.sleep(.1)\n        if not signal.go:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n\ndef slow_function():\n    time.sleep(3)\n    return 42\n\n\ndef supervisor():\n    signal = Signal()\n    spinner = threading.Thread(target=spin,\n                               args=('thinkg!', signal))\n    print('spinner object:', spinner)\n    spinner.start()\n    result = slow_function()\n    signal.go = False\n    spinner.join()\n    return result\n\ndef main():\n    result = supervisor()\n    print('Answer:', result)\n因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。\n```\n注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。\n\n\n### 关于asyncio版本的代码做几点解释：\n1.  Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.\n2. 使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。\n3. 当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。\n4. aysncio.async(...)安排spin coroutine去运行，将其封装成Task对象后立即返回。\n5. Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。\n6. run_ until_ complete()会驱动coroutine运行，返回的结果是coroutine的返回值。\n\n```\n@asyncio.coroutine\ndef spin(msg):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))\n        try:\n            yield from asyncio.sleep(.1)\n        except asyncio.CancelledError:\n            break\n    write(' ' * len(status) + '\\x08' * len(status))\n\n@asyncio.coroutine\ndef slow_function():\n    yield from asyncio.sleep(3)\n    return 42\n\n@asyncio.coroutine\ndef supervisor():\n    spinner = asyncio.ensure_future(spin('thinking!'))\n    print('spinner object:', spinner)\n    result = yield from slow_function()\n    spinner.cancel()\n    return result\n\n\ndef main():\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(supervisor())\n    loop.close()\n    print('Answer:', result)\n```\n\n\n对比上面两个版本的demo,解释一下它们之间的区别：\n\n1. 一个Task驱动一个coroutine,一个线程调用一个callable.\n2. 我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(...)或者loop.create_ task(...)来获得Task对象。\n3. 当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。\n4. 在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。\n5. 没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。\n6. supervisor必须在main函数中通过loop.run_ until_ complete()调用。\n7. 在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。\n\n## How the asyncio.Future class differs from concurrent.futures.Future\n如果你还不清楚future的概念，你可以参考我写的另一篇文章[Python concurrency with futures](http://www.ganbinwen.com/2017/12/13/Python-concurrency-with-futures/)，里面有相关介绍，或者可以自行参考官方文档/wiki。\n\n请务必确认已经清楚了future的概念后再阅读下面内容 :)\n\nasyncio中的future：\n\n* asyncio中Task是Future的子类,故Task也是Future。\n* 对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。\n* 对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。\n* yield from my_ future 相当于 my_ future.add_ done_ callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。\n\n\nasyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。\n为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：\n\n1. aysncio.async(coro_or_future, *, loop=None)\n\n\t*  这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create_ task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get_ event_ loop()来的到一个loop对象。\n\n\t\n2. BaseEventLoop.create_task(coro)\n\n\t* 这个方法安排coroutine操作，并且返回一个asyncio.Task对象。\n\t\n几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数\n\n```\nimport asyncio\n\n\ndef run_sync(coro_or_future):\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(coro_or_future)\n\n\n@asyncio.coroutine\ndef coro():\n    yield from asyncio.sleep(1)\n\n\nif __name__ == '__main__':\n    a = run_sync(coro())\n```\n \t \n\n## Asynchronous programming manages high concurrency in network applications, without using threads or processes\n\n我们使用aiohttp这个第三方库来完善我们的Http Client。\n\n```\n\nimport asyncio\nimport aiohttp\nimport time\nimport os\nimport sys\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP'\n            'MX PH VN ET EG DE IR TR CD FR').split()\nBASE_URL = 'http://flupy.org/data/flags'\n\nDEST_DIR = 'downloads/'\n\n\ndef save_flags(img, filename):\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\ndef show(text):\n    print(text, end=' ')\n    sys.stdout.flush()\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    session = aiohttp.ClientSession()\n    res = yield from session.get(url)\n    # res = yield from aiohttp.request('GET', url) will occur error with 'Unclosed client session'.\n    image = yield from res.read()\n    session.close()\n    return image\n\n\n@asyncio.coroutine\ndef download_one(cc):\n    image = yield from get_flag(cc)\n    show(cc)\n    save_flags(image, cc.lower() + '.gif')\n    return cc\n\n\n# @asyncio.coroutine\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()\n    to_do = [download_one(cc) for cc in sorted(cc_list)]\n    wait_coro = asyncio.wait(to_do)\n    res, _ = loop.run_until_complete(wait_coro)\n    loop.close()\n\n    return len(res)\n\n\ndef main(download_many):\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags download in {:.2f}s'\n    print(msg.format(count, elapsed))\nCN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE \n19 flags download in 3.85s\n```\nasyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例\n当事件循环运行时，loop.run_ until_ complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。\n\n这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get_ flag里用yield from驱动aiohttp所以get_ flag是一个coroutine，同样在download_ one里用yield from驱动get_ flag所以它也是一个coroutine，最后在download_ many通过loop.run_ until_ complete来驱动被asyncio.wait()方法实例过的Tasks。\n\n可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：\n\n1. 每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.\n2. 链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。\n\n当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：\n驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run_ until_ complete(...) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。\n\n\n## How coroutines are a major improvement over callbacks for asynchronous programming\n\n通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？\n\n对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：\n1. 让阻塞操作在不同的线程中运行。\n2. 让用非阻塞的异步操作来调用阻塞操作。\n\n我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。\n\n使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。\n\n```\n```\n\n\n## How to avoid blocking the event loop by offloading blocking operations to a thread pool\n尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？\n在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。\n\n```\n@asyncio.coroutine\ndef download_one(cc, base_url, semaphore, verbose):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(base_url, cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.NOT_FOUND\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(None, save_flags, image, cc.lower() + '.gif') # Avoiding blocking.\n        status = HTTPStatus.OK\n        msg = 'OK'\n\n    if verbose and msg:\n        print(cc, msg)\n\n    return Result(status, cc)\n```\n\n\n## Callback Hell\n关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：\n\n```\ndef stage1(response1):\n    request2 = step1(response1)\n    api_call2(request2, stage2)\n\ndef stage2(response2):\n    request3 = step2(response2)\n    api_call3(request3, stage3)\n\ndef stage3(response3):\n    step(response3)\n\napi_call(request1, stage1)\n```\n\n分析一下这种风格的代码：\n读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。\n接下来我们再用coroutine来完成上述逻辑。\n\n```\n@asyncio.coroutine\ndef three_stages(request1):\n    response1 = yield from api_call1(request1)\n\n    request2 = step1(response1)\n    response2 = yield from api_call2(request2)\n    \n    request3 = step2(response2)\n    response3 = yield from api_call3(request3)\n    \n    step3(request3)\n```\n不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。\n\n尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。\n\n\n\n## Writing asyncio servers, and how to rethink Web applications for high concurrency \n接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。\n\n```\nimport sys\nimport asyncio\n\nfrom Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?>'\nindex = UnicodeNameIndex()\n\n@asyncio.coroutine\ndef handle_queries(reader, writer):\n    while True:\n        writer.write(PROMPT)\n        yield from writer.drain()\n        data = yield from reader.readline()\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            query = '\\x00'\n        client = writer.get_extra_info('peername')\n        print('Received from {}: {!r}'.format(client, query))\n        if query:\n            if ord(query[:1]) < 32:\n                break\n            lines = list(index.find_description_strs(query))\n            if lines:\n                writer.writelines(line.encode() + CRLF for line in lines)\n            writer.write(index.status(query, len(lines)).encode() + CRLF)\n\n            yield from writer.drain()\n            print('Sent {} results'.format(len(lines)))\n    print('Close the client socket')\n    writer.close()\n\ndef main(address='127.0.0.1', port=2323):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)\n    server = loop.run_until_complete(server_coro)\n\n    host = server.sockets[0].getsockname()\n    print('Serving on {} Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    loop.run_until_complete(server.wait_closed())\n    loop.close()\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n```\n希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。\n\nTips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).\n\n\n接下来再看一下http版本的：\n\n```\n@asyncio.coroutine\ndef init(loop, address, port):\n    app = web.Application(loop=loop)\n    app.router.add_route('GET', '/', home)\n    handler = app.make_handler()\n    server = yield from loop.create_server(handler, address, port)\n\n    return server.sockets[0].getsockname()\n\n\ndef main(address='127.0.0.1', port=8888):\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    host = loop.run_until_complete(init(loop, address, port))\n    print('Servering on {}. Hit CTRL-C to stop.'.format(host))\n    try:\n        loop.run_forever()\n    except KeyboardInterrupt:\n        pass\n    print('Server shutting down.')\n    loop.close()\n\n\ndef home(request):\n    query = request.GET.get('query', '').strip()\n    print('Query: {!r}'.format(query))\n    if query:\n        descriptions = list(index.find_descriptions(query))\n        res = '\\n'.join(ROW_TPL.format(**vars(descr))\n                        for descr in descriptions)\n        msg = index.status(query, len(descriptions))\n\n    else:\n        descriptions = []\n        res = ''\n        msg = 'Enter words describing characters.'\n\n    html = template.format(query, res, msg)\n\n    print('Sending {} results'.format(len(descriptions)))\n    return web.Response(content_type=CONTENT_TYPE, text=html)\n```\n\n对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。\n\n\n## Parallelism and Concurrency\n给大家分享《Fluent Python》中的一则quote.\n\n*Concurrency is about dealing with lots of things at once.*\n\n*Parallelism is about doing lots of things at once.*\n\n*Not the same, but related.*\n\n*One is about structure, one is about execution.*\n\n*Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.*  \n\n\t\t\t\t\t\t\t\t\t-----Rob Pike\n\t\t\t\t\t\t\t\t\t\n这段quote揭示了中文里的**并行**和**并发**的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。\n\n对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).\n\n## Summary\n最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)\n\n本文代码地址：[asycnio_demo](https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo)\n\n","slug":"Python-asyncio模块介绍","published":1,"updated":"2018-01-24T16:35:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjctavxgm0000i6vvls9vzxyd","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。</p>\n<p>注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。</p>\n<h2 id=\"A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\"><a href=\"#A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\" class=\"headerlink\" title=\"A comparison between a simple threaded program and the asyncio equivalent\"></a>A comparison between a simple threaded program and the asyncio equivalent</h2><p>我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。</p>\n<p>Thread demo:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Signal:</div><div class=\"line\">    go = True</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def spin(msg, signal):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        time.sleep(.1)</div><div class=\"line\">        if not signal.go:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def slow_function():</div><div class=\"line\">    time.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def supervisor():</div><div class=\"line\">    signal = Signal()</div><div class=\"line\">    spinner = threading.Thread(target=spin,</div><div class=\"line\">                               args=(&apos;thinkg!&apos;, signal))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    spinner.start()</div><div class=\"line\">    result = slow_function()</div><div class=\"line\">    signal.go = False</div><div class=\"line\">    spinner.join()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    result = supervisor()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div><div class=\"line\">因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。</div></pre></td></tr></table></figure>\n<p>注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。</p>\n<h3 id=\"关于asyncio版本的代码做几点解释：\"><a href=\"#关于asyncio版本的代码做几点解释：\" class=\"headerlink\" title=\"关于asyncio版本的代码做几点解释：\"></a>关于asyncio版本的代码做几点解释：</h3><ol>\n<li>Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.</li>\n<li>使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。</li>\n<li>当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。</li>\n<li>aysncio.async(…)安排spin coroutine去运行，将其封装成Task对象后立即返回。</li>\n<li>Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。</li>\n<li>run<em> until</em> complete()会驱动coroutine运行，返回的结果是coroutine的返回值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def spin(msg):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        try:</div><div class=\"line\">            yield from asyncio.sleep(.1)</div><div class=\"line\">        except asyncio.CancelledError:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def slow_function():</div><div class=\"line\">    yield from asyncio.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def supervisor():</div><div class=\"line\">    spinner = asyncio.ensure_future(spin(&apos;thinking!&apos;))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    result = yield from slow_function()</div><div class=\"line\">    spinner.cancel()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    result = loop.run_until_complete(supervisor())</div><div class=\"line\">    loop.close()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div></pre></td></tr></table></figure>\n<p>对比上面两个版本的demo,解释一下它们之间的区别：</p>\n<ol>\n<li>一个Task驱动一个coroutine,一个线程调用一个callable.</li>\n<li>我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(…)或者loop.create_ task(…)来获得Task对象。</li>\n<li>当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。</li>\n<li>在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。</li>\n<li>没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。</li>\n<li>supervisor必须在main函数中通过loop.run<em> until</em> complete()调用。</li>\n<li>在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。</li>\n</ol>\n<h2 id=\"How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\"><a href=\"#How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\" class=\"headerlink\" title=\"How the asyncio.Future class differs from concurrent.futures.Future\"></a>How the asyncio.Future class differs from concurrent.futures.Future</h2><p>如果你还不清楚future的概念，你可以参考我写的另一篇文章<a href=\"http://www.ganbinwen.com/2017/12/13/Python-concurrency-with-futures/\" target=\"_blank\" rel=\"external\">Python concurrency with futures</a>，里面有相关介绍，或者可以自行参考官方文档/wiki。</p>\n<p>请务必确认已经清楚了future的概念后再阅读下面内容 :)</p>\n<p>asyncio中的future：</p>\n<ul>\n<li>asyncio中Task是Future的子类,故Task也是Future。</li>\n<li>对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。</li>\n<li>对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。</li>\n<li>yield from my<em> future 相当于 my</em> future.add<em> done</em> callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。</li>\n</ul>\n<p>asyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。<br>为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：</p>\n<ol>\n<li><p>aysncio.async(coro_or_future, *, loop=None)</p>\n<ul>\n<li>这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create<em> task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get</em> event_ loop()来的到一个loop对象。</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>BaseEventLoop.create_task(coro)</p>\n<ul>\n<li>这个方法安排coroutine操作，并且返回一个asyncio.Task对象。</li>\n</ul>\n</li>\n</ol>\n<p>几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run_sync(coro_or_future):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    return loop.run_until_complete(coro_or_future)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def coro():</div><div class=\"line\">    yield from asyncio.sleep(1)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    a = run_sync(coro())</div></pre></td></tr></table></figure>\n<h2 id=\"Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\"><a href=\"#Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\" class=\"headerlink\" title=\"Asynchronous programming manages high concurrency in network applications, without using threads or processes\"></a>Asynchronous programming manages high concurrency in network applications, without using threads or processes</h2><p>我们使用aiohttp这个第三方库来完善我们的Http Client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import asyncio</div><div class=\"line\">import aiohttp</div><div class=\"line\">import time</div><div class=\"line\">import os</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    session = aiohttp.ClientSession()</div><div class=\"line\">    res = yield from session.get(url)</div><div class=\"line\">    # res = yield from aiohttp.request(&apos;GET&apos;, url) will occur error with &apos;Unclosed client session&apos;.</div><div class=\"line\">    image = yield from res.read()</div><div class=\"line\">    session.close()</div><div class=\"line\">    return image</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = yield from get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># @asyncio.coroutine</div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    to_do = [download_one(cc) for cc in sorted(cc_list)]</div><div class=\"line\">    wait_coro = asyncio.wait(to_do)</div><div class=\"line\">    res, _ = loop.run_until_complete(wait_coro)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\">    return len(res)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\">CN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE </div><div class=\"line\">19 flags download in 3.85s</div></pre></td></tr></table></figure>\n<p>asyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例<br>当事件循环运行时，loop.run<em> until</em> complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。</p>\n<p>这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get<em> flag里用yield from驱动aiohttp所以get</em> flag是一个coroutine，同样在download<em> one里用yield from驱动get</em> flag所以它也是一个coroutine，最后在download<em> many通过loop.run</em> until_ complete来驱动被asyncio.wait()方法实例过的Tasks。</p>\n<p>可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：</p>\n<ol>\n<li>每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.</li>\n<li>链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。</li>\n</ol>\n<p>当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：<br>驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run<em> until</em> complete(…) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。</p>\n<h2 id=\"How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\"><a href=\"#How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\" class=\"headerlink\" title=\"How coroutines are a major improvement over callbacks for asynchronous programming\"></a>How coroutines are a major improvement over callbacks for asynchronous programming</h2><p>通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？</p>\n<p>对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：</p>\n<ol>\n<li>让阻塞操作在不同的线程中运行。</li>\n<li>让用非阻塞的异步操作来调用阻塞操作。</li>\n</ol>\n<p>我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。</p>\n<p>使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## How to avoid blocking the event loop by offloading blocking operations to a thread pool</div><div class=\"line\">尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？</div><div class=\"line\">在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。</div></pre></td></tr></table></figure>\n<p>@asyncio.coroutine<br>def download_one(cc, base_url, semaphore, verbose):<br>    try:<br>        with (yield from semaphore):<br>            image = yield from get_flag(base_url, cc)<br>    except web.HTTPNotFound:<br>        status = HTTPStatus.NOT_FOUND<br>        msg = ‘not found’<br>    except Exception as exc:<br>        raise FetchError(cc) from exc<br>    else:<br>        loop = asyncio.get_event_loop()<br>        loop.run_in_executor(None, save_flags, image, cc.lower() + ‘.gif’) # Avoiding blocking.<br>        status = HTTPStatus.OK<br>        msg = ‘OK’</p>\n<pre><code>if verbose and msg:\n    print(cc, msg)\n\nreturn Result(status, cc)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## Callback Hell</div><div class=\"line\">关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</div></pre></td></tr></table></figure>\n<p>def stage1(response1):<br>    request2 = step1(response1)<br>    api_call2(request2, stage2)</p>\n<p>def stage2(response2):<br>    request3 = step2(response2)<br>    api_call3(request3, stage3)</p>\n<p>def stage3(response3):<br>    step(response3)</p>\n<p>api_call(request1, stage1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">分析一下这种风格的代码：</div><div class=\"line\">读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。</div><div class=\"line\">接下来我们再用coroutine来完成上述逻辑。</div></pre></td></tr></table></figure></p>\n<p>@asyncio.coroutine<br>def three_stages(request1):<br>    response1 = yield from api_call1(request1)</p>\n<pre><code>request2 = step1(response1)\nresponse2 = yield from api_call2(request2)\n\nrequest3 = step2(response2)\nresponse3 = yield from api_call3(request3)\n\nstep3(request3)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</div><div class=\"line\"></div><div class=\"line\">尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## Writing asyncio servers, and how to rethink Web applications for high concurrency </div><div class=\"line\">接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</div></pre></td></tr></table></figure>\n<p>import sys<br>import asyncio</p>\n<p>from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</p>\n<p>CRLF = b’\\r\\n’<br>PROMPT = b’?&gt;’<br>index = UnicodeNameIndex()</p>\n<p>@asyncio.coroutine<br>def handle_queries(reader, writer):<br>    while True:<br>        writer.write(PROMPT)<br>        yield from writer.drain()<br>        data = yield from reader.readline()<br>        try:<br>            query = data.decode().strip()<br>        except UnicodeDecodeError:<br>            query = ‘\\x00’<br>        client = writer.get_extra_info(‘peername’)<br>        print(‘Received from {}: {!r}’.format(client, query))<br>        if query:<br>            if ord(query[:1]) &lt; 32:<br>                break<br>            lines = list(index.find_description_strs(query))<br>            if lines:<br>                writer.writelines(line.encode() + CRLF for line in lines)<br>            writer.write(index.status(query, len(lines)).encode() + CRLF)</p>\n<pre><code>        yield from writer.drain()\n        print(&apos;Sent {} results&apos;.format(len(lines)))\nprint(&apos;Close the client socket&apos;)\nwriter.close()\n</code></pre><p>def main(address=’127.0.0.1’, port=2323):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)<br>    server = loop.run_until_complete(server_coro)</p>\n<pre><code>host = server.sockets[0].getsockname()\nprint(&apos;Serving on {} Hit CTRL-C to stop.&apos;.format(host))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nprint(&apos;Server shutting down.&apos;)\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()\n</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main(*sys.argv[1:])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</div><div class=\"line\"></div><div class=\"line\">Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">接下来再看一下http版本的：</div></pre></td></tr></table></figure></p>\n<p>@asyncio.coroutine<br>def init(loop, address, port):<br>    app = web.Application(loop=loop)<br>    app.router.add_route(‘GET’, ‘/‘, home)<br>    handler = app.make_handler()<br>    server = yield from loop.create_server(handler, address, port)</p>\n<pre><code>return server.sockets[0].getsockname()\n</code></pre><p>def main(address=’127.0.0.1’, port=8888):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    host = loop.run_until_complete(init(loop, address, port))<br>    print(‘Servering on {}. Hit CTRL-C to stop.’.format(host))<br>    try:<br>        loop.run_forever()<br>    except KeyboardInterrupt:<br>        pass<br>    print(‘Server shutting down.’)<br>    loop.close()</p>\n<p>def home(request):<br>    query = request.GET.get(‘query’, ‘’).strip()<br>    print(‘Query: {!r}’.format(query))<br>    if query:<br>        descriptions = list(index.find_descriptions(query))<br>        res = ‘\\n’.join(ROW_TPL.format(**vars(descr))<br>                        for descr in descriptions)<br>        msg = index.status(query, len(descriptions))</p>\n<pre><code>else:\n    descriptions = []\n    res = &apos;&apos;\n    msg = &apos;Enter words describing characters.&apos;\n\nhtml = template.format(query, res, msg)\n\nprint(&apos;Sending {} results&apos;.format(len(descriptions)))\nreturn web.Response(content_type=CONTENT_TYPE, text=html)\n</code></pre><p>```</p>\n<p>对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。</p>\n<h2 id=\"Parallelism-and-Concurrency\"><a href=\"#Parallelism-and-Concurrency\" class=\"headerlink\" title=\"Parallelism and Concurrency\"></a>Parallelism and Concurrency</h2><p>给大家分享《Fluent Python》中的一则quote.</p>\n<p><em>Concurrency is about dealing with lots of things at once.</em></p>\n<p><em>Parallelism is about doing lots of things at once.</em></p>\n<p><em>Not the same, but related.</em></p>\n<p><em>One is about structure, one is about execution.</em></p>\n<p><em>Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.</em>  </p>\n<pre><code>-----Rob Pike\n</code></pre><p>这段quote揭示了中文里的<strong>并行</strong>和<strong>并发</strong>的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。</p>\n<p>对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo\" target=\"_blank\" rel=\"external\">asycnio_demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。</p>\n<p>注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。</p>\n<h2 id=\"A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\"><a href=\"#A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent\" class=\"headerlink\" title=\"A comparison between a simple threaded program and the asyncio equivalent\"></a>A comparison between a simple threaded program and the asyncio equivalent</h2><p>我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。</p>\n<p>Thread demo:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Signal:</div><div class=\"line\">    go = True</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def spin(msg, signal):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        time.sleep(.1)</div><div class=\"line\">        if not signal.go:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def slow_function():</div><div class=\"line\">    time.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def supervisor():</div><div class=\"line\">    signal = Signal()</div><div class=\"line\">    spinner = threading.Thread(target=spin,</div><div class=\"line\">                               args=(&apos;thinkg!&apos;, signal))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    spinner.start()</div><div class=\"line\">    result = slow_function()</div><div class=\"line\">    signal.go = False</div><div class=\"line\">    spinner.join()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    result = supervisor()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div><div class=\"line\">因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。</div></pre></td></tr></table></figure>\n<p>注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。</p>\n<h3 id=\"关于asyncio版本的代码做几点解释：\"><a href=\"#关于asyncio版本的代码做几点解释：\" class=\"headerlink\" title=\"关于asyncio版本的代码做几点解释：\"></a>关于asyncio版本的代码做几点解释：</h3><ol>\n<li>Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.</li>\n<li>使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。</li>\n<li>当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。</li>\n<li>aysncio.async(…)安排spin coroutine去运行，将其封装成Task对象后立即返回。</li>\n<li>Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。</li>\n<li>run<em> until</em> complete()会驱动coroutine运行，返回的结果是coroutine的返回值。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def spin(msg):</div><div class=\"line\">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class=\"line\">    for char in itertools.cycle(&apos;|/-\\\\&apos;):</div><div class=\"line\">        status = char + &apos; &apos; + msg</div><div class=\"line\">        write(status)</div><div class=\"line\">        flush()</div><div class=\"line\">        write(&apos;\\x08&apos; * len(status))</div><div class=\"line\">        try:</div><div class=\"line\">            yield from asyncio.sleep(.1)</div><div class=\"line\">        except asyncio.CancelledError:</div><div class=\"line\">            break</div><div class=\"line\">    write(&apos; &apos; * len(status) + &apos;\\x08&apos; * len(status))</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def slow_function():</div><div class=\"line\">    yield from asyncio.sleep(3)</div><div class=\"line\">    return 42</div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def supervisor():</div><div class=\"line\">    spinner = asyncio.ensure_future(spin(&apos;thinking!&apos;))</div><div class=\"line\">    print(&apos;spinner object:&apos;, spinner)</div><div class=\"line\">    result = yield from slow_function()</div><div class=\"line\">    spinner.cancel()</div><div class=\"line\">    return result</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    result = loop.run_until_complete(supervisor())</div><div class=\"line\">    loop.close()</div><div class=\"line\">    print(&apos;Answer:&apos;, result)</div></pre></td></tr></table></figure>\n<p>对比上面两个版本的demo,解释一下它们之间的区别：</p>\n<ol>\n<li>一个Task驱动一个coroutine,一个线程调用一个callable.</li>\n<li>我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(…)或者loop.create_ task(…)来获得Task对象。</li>\n<li>当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。</li>\n<li>在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。</li>\n<li>没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。</li>\n<li>supervisor必须在main函数中通过loop.run<em> until</em> complete()调用。</li>\n<li>在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。</li>\n</ol>\n<h2 id=\"How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\"><a href=\"#How-the-asyncio-Future-class-differs-from-concurrent-futures-Future\" class=\"headerlink\" title=\"How the asyncio.Future class differs from concurrent.futures.Future\"></a>How the asyncio.Future class differs from concurrent.futures.Future</h2><p>如果你还不清楚future的概念，你可以参考我写的另一篇文章<a href=\"http://www.ganbinwen.com/2017/12/13/Python-concurrency-with-futures/\" target=\"_blank\" rel=\"external\">Python concurrency with futures</a>，里面有相关介绍，或者可以自行参考官方文档/wiki。</p>\n<p>请务必确认已经清楚了future的概念后再阅读下面内容 :)</p>\n<p>asyncio中的future：</p>\n<ul>\n<li>asyncio中Task是Future的子类,故Task也是Future。</li>\n<li>对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。</li>\n<li>对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。</li>\n<li>yield from my<em> future 相当于 my</em> future.add<em> done</em> callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。</li>\n</ul>\n<p>asyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。<br>为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：</p>\n<ol>\n<li><p>aysncio.async(coro_or_future, *, loop=None)</p>\n<ul>\n<li>这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create<em> task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get</em> event_ loop()来的到一个loop对象。</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>BaseEventLoop.create_task(coro)</p>\n<ul>\n<li>这个方法安排coroutine操作，并且返回一个asyncio.Task对象。</li>\n</ul>\n</li>\n</ol>\n<p>几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">import asyncio</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def run_sync(coro_or_future):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    return loop.run_until_complete(coro_or_future)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def coro():</div><div class=\"line\">    yield from asyncio.sleep(1)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    a = run_sync(coro())</div></pre></td></tr></table></figure>\n<h2 id=\"Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\"><a href=\"#Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes\" class=\"headerlink\" title=\"Asynchronous programming manages high concurrency in network applications, without using threads or processes\"></a>Asynchronous programming manages high concurrency in network applications, without using threads or processes</h2><p>我们使用aiohttp这个第三方库来完善我们的Http Client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import asyncio</div><div class=\"line\">import aiohttp</div><div class=\"line\">import time</div><div class=\"line\">import os</div><div class=\"line\">import sys</div><div class=\"line\"></div><div class=\"line\">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class=\"line\">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class=\"line\">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class=\"line\"></div><div class=\"line\">DEST_DIR = &apos;downloads/&apos;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def save_flags(img, filename):</div><div class=\"line\">    path = os.path.join(DEST_DIR, filename)</div><div class=\"line\">    with open(path, &apos;wb&apos;) as fp:</div><div class=\"line\">        fp.write(img)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def show(text):</div><div class=\"line\">    print(text, end=&apos; &apos;)</div><div class=\"line\">    sys.stdout.flush()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def get_flag(cc):</div><div class=\"line\">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class=\"line\">    session = aiohttp.ClientSession()</div><div class=\"line\">    res = yield from session.get(url)</div><div class=\"line\">    # res = yield from aiohttp.request(&apos;GET&apos;, url) will occur error with &apos;Unclosed client session&apos;.</div><div class=\"line\">    image = yield from res.read()</div><div class=\"line\">    session.close()</div><div class=\"line\">    return image</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@asyncio.coroutine</div><div class=\"line\">def download_one(cc):</div><div class=\"line\">    image = yield from get_flag(cc)</div><div class=\"line\">    show(cc)</div><div class=\"line\">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class=\"line\">    return cc</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># @asyncio.coroutine</div><div class=\"line\">def download_many(cc_list):</div><div class=\"line\">    loop = asyncio.get_event_loop()</div><div class=\"line\">    to_do = [download_one(cc) for cc in sorted(cc_list)]</div><div class=\"line\">    wait_coro = asyncio.wait(to_do)</div><div class=\"line\">    res, _ = loop.run_until_complete(wait_coro)</div><div class=\"line\">    loop.close()</div><div class=\"line\"></div><div class=\"line\">    return len(res)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main(download_many):</div><div class=\"line\">    t0 = time.time()</div><div class=\"line\">    count = download_many(POP20_CC)</div><div class=\"line\">    elapsed = time.time() - t0</div><div class=\"line\">    msg = &apos;\\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class=\"line\">    print(msg.format(count, elapsed))</div><div class=\"line\">CN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE </div><div class=\"line\">19 flags download in 3.85s</div></pre></td></tr></table></figure>\n<p>asyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例<br>当事件循环运行时，loop.run<em> until</em> complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。</p>\n<p>这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get<em> flag里用yield from驱动aiohttp所以get</em> flag是一个coroutine，同样在download<em> one里用yield from驱动get</em> flag所以它也是一个coroutine，最后在download<em> many通过loop.run</em> until_ complete来驱动被asyncio.wait()方法实例过的Tasks。</p>\n<p>可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：</p>\n<ol>\n<li>每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.</li>\n<li>链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。</li>\n</ol>\n<p>当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：<br>驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run<em> until</em> complete(…) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。</p>\n<h2 id=\"How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\"><a href=\"#How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming\" class=\"headerlink\" title=\"How coroutines are a major improvement over callbacks for asynchronous programming\"></a>How coroutines are a major improvement over callbacks for asynchronous programming</h2><p>通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？</p>\n<p>对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：</p>\n<ol>\n<li>让阻塞操作在不同的线程中运行。</li>\n<li>让用非阻塞的异步操作来调用阻塞操作。</li>\n</ol>\n<p>我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。</p>\n<p>使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">```</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## How to avoid blocking the event loop by offloading blocking operations to a thread pool</div><div class=\"line\">尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？</div><div class=\"line\">在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。</div></pre></td></tr></table></figure>\n<p>@asyncio.coroutine<br>def download_one(cc, base_url, semaphore, verbose):<br>    try:<br>        with (yield from semaphore):<br>            image = yield from get_flag(base_url, cc)<br>    except web.HTTPNotFound:<br>        status = HTTPStatus.NOT_FOUND<br>        msg = ‘not found’<br>    except Exception as exc:<br>        raise FetchError(cc) from exc<br>    else:<br>        loop = asyncio.get_event_loop()<br>        loop.run_in_executor(None, save_flags, image, cc.lower() + ‘.gif’) # Avoiding blocking.<br>        status = HTTPStatus.OK<br>        msg = ‘OK’</p>\n<pre><code>if verbose and msg:\n    print(cc, msg)\n\nreturn Result(status, cc)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## Callback Hell</div><div class=\"line\">关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</div></pre></td></tr></table></figure>\n<p>def stage1(response1):<br>    request2 = step1(response1)<br>    api_call2(request2, stage2)</p>\n<p>def stage2(response2):<br>    request3 = step2(response2)<br>    api_call3(request3, stage3)</p>\n<p>def stage3(response3):<br>    step(response3)</p>\n<p>api_call(request1, stage1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">分析一下这种风格的代码：</div><div class=\"line\">读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。</div><div class=\"line\">接下来我们再用coroutine来完成上述逻辑。</div></pre></td></tr></table></figure></p>\n<p>@asyncio.coroutine<br>def three_stages(request1):<br>    response1 = yield from api_call1(request1)</p>\n<pre><code>request2 = step1(response1)\nresponse2 = yield from api_call2(request2)\n\nrequest3 = step2(response2)\nresponse3 = yield from api_call3(request3)\n\nstep3(request3)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</div><div class=\"line\"></div><div class=\"line\">尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">## Writing asyncio servers, and how to rethink Web applications for high concurrency </div><div class=\"line\">接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</div></pre></td></tr></table></figure>\n<p>import sys<br>import asyncio</p>\n<p>from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</p>\n<p>CRLF = b’\\r\\n’<br>PROMPT = b’?&gt;’<br>index = UnicodeNameIndex()</p>\n<p>@asyncio.coroutine<br>def handle_queries(reader, writer):<br>    while True:<br>        writer.write(PROMPT)<br>        yield from writer.drain()<br>        data = yield from reader.readline()<br>        try:<br>            query = data.decode().strip()<br>        except UnicodeDecodeError:<br>            query = ‘\\x00’<br>        client = writer.get_extra_info(‘peername’)<br>        print(‘Received from {}: {!r}’.format(client, query))<br>        if query:<br>            if ord(query[:1]) &lt; 32:<br>                break<br>            lines = list(index.find_description_strs(query))<br>            if lines:<br>                writer.writelines(line.encode() + CRLF for line in lines)<br>            writer.write(index.status(query, len(lines)).encode() + CRLF)</p>\n<pre><code>        yield from writer.drain()\n        print(&apos;Sent {} results&apos;.format(len(lines)))\nprint(&apos;Close the client socket&apos;)\nwriter.close()\n</code></pre><p>def main(address=’127.0.0.1’, port=2323):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)<br>    server = loop.run_until_complete(server_coro)</p>\n<pre><code>host = server.sockets[0].getsockname()\nprint(&apos;Serving on {} Hit CTRL-C to stop.&apos;.format(host))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nprint(&apos;Server shutting down.&apos;)\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()\n</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main(*sys.argv[1:])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</div><div class=\"line\"></div><div class=\"line\">Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">接下来再看一下http版本的：</div></pre></td></tr></table></figure></p>\n<p>@asyncio.coroutine<br>def init(loop, address, port):<br>    app = web.Application(loop=loop)<br>    app.router.add_route(‘GET’, ‘/‘, home)<br>    handler = app.make_handler()<br>    server = yield from loop.create_server(handler, address, port)</p>\n<pre><code>return server.sockets[0].getsockname()\n</code></pre><p>def main(address=’127.0.0.1’, port=8888):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    host = loop.run_until_complete(init(loop, address, port))<br>    print(‘Servering on {}. Hit CTRL-C to stop.’.format(host))<br>    try:<br>        loop.run_forever()<br>    except KeyboardInterrupt:<br>        pass<br>    print(‘Server shutting down.’)<br>    loop.close()</p>\n<p>def home(request):<br>    query = request.GET.get(‘query’, ‘’).strip()<br>    print(‘Query: {!r}’.format(query))<br>    if query:<br>        descriptions = list(index.find_descriptions(query))<br>        res = ‘\\n’.join(ROW_TPL.format(**vars(descr))<br>                        for descr in descriptions)<br>        msg = index.status(query, len(descriptions))</p>\n<pre><code>else:\n    descriptions = []\n    res = &apos;&apos;\n    msg = &apos;Enter words describing characters.&apos;\n\nhtml = template.format(query, res, msg)\n\nprint(&apos;Sending {} results&apos;.format(len(descriptions)))\nreturn web.Response(content_type=CONTENT_TYPE, text=html)\n</code></pre><p>```</p>\n<p>对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。</p>\n<h2 id=\"Parallelism-and-Concurrency\"><a href=\"#Parallelism-and-Concurrency\" class=\"headerlink\" title=\"Parallelism and Concurrency\"></a>Parallelism and Concurrency</h2><p>给大家分享《Fluent Python》中的一则quote.</p>\n<p><em>Concurrency is about dealing with lots of things at once.</em></p>\n<p><em>Parallelism is about doing lots of things at once.</em></p>\n<p><em>Not the same, but related.</em></p>\n<p><em>One is about structure, one is about execution.</em></p>\n<p><em>Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.</em>  </p>\n<pre><code>-----Rob Pike\n</code></pre><p>这段quote揭示了中文里的<strong>并行</strong>和<strong>并发</strong>的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。</p>\n<p>对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)</p>\n<p>本文代码地址：<a href=\"https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo\" target=\"_blank\" rel=\"external\">asycnio_demo</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjb4j8opl0006lvtlgj1i5r7e","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opn0009lvtla203u6yl"},{"post_id":"cjb4j8opf0002lvtlssnrk5o3","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opn000blvtlugx2qow1"},{"post_id":"cjb4j8opl0007lvtlvq5y13cc","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opp000elvtlufqncnlm"},{"post_id":"cjb4j8opn000alvtl49om4z64","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opp000glvtlmrxucjma"},{"post_id":"cjb4j8opi0003lvtltmbypsog","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opq000ilvtl4z45l0ah"},{"post_id":"cjb4j8opo000clvtlsn92mifa","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opr000klvtl46xoc7aq"},{"post_id":"cjb4j8opp000flvtl02oiywh6","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opr000mlvtldpjq7mn6"},{"post_id":"cjb4j8opk0005lvtlziunbbum","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opt000olvtlblf620kd"},{"post_id":"cjb4j8opp000hlvtlulvj8pnf","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opt000qlvtlxywlc6sv"},{"post_id":"cjb4j8opq000jlvtlmb3215fz","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opv000slvtlix5b8ena"},{"post_id":"cjb4j8opr000llvtl2kn74w3h","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opw000ulvtl2z3x38zx"},{"post_id":"cjb4j8ops000nlvtl9o5i7yoy","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opw000wlvtldnu602wn"},{"post_id":"cjb4j8opt000plvtl3qecbx8f","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opx000ylvtl755axfcn"},{"post_id":"cjb4j8opu000rlvtlgc5re36z","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opy0010lvtl70xkdjty"},{"post_id":"cjb4j8opv000tlvtlgtdyussx","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opz0012lvtl2r51yn39"},{"post_id":"cjb4j8opw000vlvtlq95ktlcp","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8opz0014lvtlevy5xr1y"},{"post_id":"cjb4j8opw000xlvtlo8i4i2l2","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq00016lvtl4a46uxz0"},{"post_id":"cjb4j8opx000zlvtl81adp53n","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq10018lvtl25dqwaf5"},{"post_id":"cjb4j8opy0011lvtlqwpmvckd","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq2001alvtld1jpqpu7"},{"post_id":"cjb4j8opz0013lvtl5hbw916e","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq2001clvtl4i022ajb"},{"post_id":"cjb4j8oq00015lvtlxyaisyaz","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq3001elvtlgh4pqrbf"},{"post_id":"cjb4j8oq00017lvtlmf3o4boo","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq5001glvtlgkkyetus"},{"post_id":"cjb4j8oq10019lvtl8y7154qv","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq6001ilvtlbdpoi7ly"},{"post_id":"cjb4j8oq2001blvtl7ufwaueh","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq6001klvtlapk8nwpx"},{"post_id":"cjb4j8oq2001dlvtlmlquakcc","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq7001mlvtl9058qxsw"},{"post_id":"cjb4j8oq3001flvtlor66h5a0","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq8001olvtlom9rjspc"},{"post_id":"cjb4j8oq5001hlvtlwi9asgoe","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq8001qlvtlivipqpyy"},{"post_id":"cjb4j8oq6001jlvtlwf59i37k","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oq9001slvtl852d8aff"},{"post_id":"cjb4j8oq7001llvtluwk5d1vt","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqa001ulvtlq8758bg7"},{"post_id":"cjb4j8oq7001nlvtl2shdz0sg","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqb001wlvtl5a2pbguv"},{"post_id":"cjb4j8oq8001plvtl0sr0m88v","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqc001ylvtlnpkor9rj"},{"post_id":"cjb4j8oq9001rlvtle2wg9oa7","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqd0021lvtlhbhgmw7e"},{"post_id":"cjb4j8oq9001tlvtlgqyv6jmm","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqd0023lvtl5ltxl535"},{"post_id":"cjb4j8oqa001vlvtlb8de9xzt","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqe0025lvtlrmzz30gd"},{"post_id":"cjb4j8oqd0024lvtl18uy4ccj","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqf0028lvtlsgtky1ol"},{"post_id":"cjb4j8oqb001xlvtl8nnpp8b6","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqg002alvtlsixygsre"},{"post_id":"cjb4j8oqe0026lvtlhf6bnnlv","tag_id":"cjb4j8opj0004lvtld586h3yf","_id":"cjb4j8oqh002dlvtlcjerg9rc"},{"post_id":"cjb4j8oqf0029lvtly0cd1gts","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqh002flvtl1ngd8wma"},{"post_id":"cjb4j8oqc001zlvtllye91exk","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqi002ilvtlc5o6fi1y"},{"post_id":"cjb4j8oqd0022lvtlq9y65mwz","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqj002klvtlu183dc0t"},{"post_id":"cjb4j8oqh002glvtllcyjfdqk","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjb4j8oqk002nlvtlxa587zle"},{"post_id":"cjb4j8oqg002blvtl7uwkl7aw","tag_id":"cjb4j8oqi002hlvtlzzwlof2s","_id":"cjb4j8oqk002plvtlqcwem7wj"},{"post_id":"cjb4j8oqi002jlvtl2ivkz992","tag_id":"cjb4j8oql002rlvtl3c2puc8t","_id":"cjb4j8oql002ulvtl2okf3k2e"},{"post_id":"cjb4j8oqj002llvtl9rvhvuwz","tag_id":"cjb4j8oql002tlvtlpdeje0lb","_id":"cjb4j8oqm002wlvtl5dccojob"},{"post_id":"cjb4j8oqk002olvtl2uw8nc91","tag_id":"cjb4j8oql002rlvtl3c2puc8t","_id":"cjb4j8oqm002ylvtl31qfzo31"},{"post_id":"cjb4j8oqk002qlvtlg0ciqa7j","tag_id":"cjb4j8oqm002xlvtlqr1alxkv","_id":"cjb4j8oqm002zlvtlimyvj7he"},{"post_id":"cjctavxgm0000i6vvls9vzxyd","tag_id":"cjb4j8oqd0020lvtlpn1ump1k","_id":"cjctavxgp0001i6vvazaq5teg"}],"Tag":[{"name":"daily report","_id":"cjb4j8opj0004lvtld586h3yf"},{"name":"Python","_id":"cjb4j8oqd0020lvtlpn1ump1k"},{"name":"实习面试","_id":"cjb4j8oqi002hlvtlzzwlof2s"},{"name":"读书笔记","_id":"cjb4j8oqj002mlvtl4rb0u06d"},{"name":"清单","_id":"cjb4j8oql002rlvtl3c2puc8t"},{"name":"函数式","_id":"cjb4j8oql002tlvtlpdeje0lb"},{"name":"算法","_id":"cjb4j8oqm002xlvtlqr1alxkv"}]}}
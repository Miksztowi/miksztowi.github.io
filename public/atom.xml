<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miks</title>
  <subtitle>Don‘t be a loser. Be a superloser.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miks.top/"/>
<<<<<<< HEAD
  <updated>2018-01-24T16:35:23.000Z</updated>
=======
  <updated>2018-01-24T16:05:14.000Z</updated>
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
  <id>http://miks.top/</id>
  
  <author>
    <name>Miks</name>
    <email>binwengan@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
<<<<<<< HEAD
=======
    <title>系统级I/O及Linux-I/O模式解释</title>
    <link href="http://miks.top/2018/01/25/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O%E5%8F%8ALinux-I-O%E6%A8%A1%E5%BC%8F%E8%A7%A3%E9%87%8A/"/>
    <id>http://miks.top/2018/01/25/系统级I-O及Linux-I-O模式解释/</id>
    <published>2018-01-24T16:03:41.000Z</published>
    <updated>2018-01-24T16:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*</code></p>
<h2 id="UNIX-I-O"><a href="#UNIX-I-O" class="headerlink" title="UNIX I/O"></a>UNIX I/O</h2><p>Linux中，所有的输入和输出都被当作对相应的文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O：</p>
<ul>
<li><strong>打开文件</strong>：当应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做<strong>描述符</strong>(后面用fd代替)，它在后续对此文件的所有操作中标识这个文件。</li>
<li>Linux shell创建每个进程开始时都有三个打开的文件，标准输入（fd为0），标准输出（fd为1），标准错误（fd为2）。</li>
<li><strong>改变当前的文件位置</strong>：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行<strong>seek</strong>操作，显式地设置文件的当前位置k。</li>
<li><strong>读写文件</strong>：一个读操作就是从文件复制n &gt; 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k &gt;= m时执行读操作会触发一个称为end-of-file(EOF)的条件。类似的，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li>
<li><strong>关闭文件</strong>: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。</li>
</ul>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享Linux文件，但是内核用三个相关的数据结构来表示打开的文件。</p>
<ul>
<li><strong>描述符表</strong>：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li>
<li><strong>文件表</strong>：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。内核会在引用计数为零时，删除对应表项。</li>
<li><strong>v-node表</strong>：同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息（文件的元数据，比如大小，创建时间）。</li>
</ul>
<h2 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h2><p>C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别的替代。这个库提供了打开和关闭文件的函数(fopen和fclose)、读和写字节的函数（fread和fwrite）、读和写字符串的函数(fgets和fputs)，以及复杂的格式化的I/O函数（scanf和printf）。标准的I/O库将一个打开的文件模型化为一个流。对程序员而言，一个流就是一个指向FILE类型的结构的指针。</p>
<p>类型为FILE的流是对文件描述符和<strong>流缓冲区</strong>的抽象。流缓冲区的目的是：使开销较高的Linux I/O系统调用的数量尽可能的小。例如，假设我们有一个程序，它反复调用标准I/O的getc函数，每次调用返回文件的下个字符。当第一次调用getc时，库通过调用一次read函数来填满流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。</p>
<p>虽然以上是通过C语言的标准I/O函数来讲解的，但是从概念上理解，与别的编程语言也是相通的。</p>
<h2 id="I-O的模式"><a href="#I-O的模式" class="headerlink" title="I/O的模式"></a>I/O的模式</h2><p>理解了I/O的基本概念后，接下来我们来谈论关于I/O不同模式的概念，优缺点以及它们彼此间的相同与不同点。</p>
<ol>
<li>阻塞I/O(Blocking I/O)：<img src="https://segmentfault.com/img/bVm1c3" alt="">默认情况下，所有Linux中套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：（1）等待数据准备好；<br>（2）从内核向进程复制数据。当用户进程调用了recvfrom操作时，kernel就开始准备数据了。这是需要等待的，也就是说数据被拷贝到操作系统内的<strong>流缓冲区</strong>是需要一个过程的，而此时在用户进程的角度，就是被阻塞了。等到数据被准备好时，将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程此时解除阻塞状态。</li>
<li>非阻塞I/O(Non-blocking I/O)：<img src="https://segmentfault.com/img/bVm1c4" alt="">：当用户发起非阻塞I/O操作时，如果数据还没有从kernel拷贝到用户内存中，那么kernel会立即返回一个error的信号，而用户进程得到这个信号后，就理解了此时数据还在等待中，之后会立即重新发送一个recvfrom的请求，直到数据被拷贝到用户内存中并且得到一个正确的返回。</li>
<li><p>I/O多路复用(I/O multiplexing)：<img src="https://segmentfault.com/img/bVm1c5" alt="">I/O多路复用也是并发的一种手段，基本思想就是使用select函数，要求内核挂起进程，只有在一个或者多个I/O时间发生后，才将控制返回给应用程序，比如：当集合{0，5}中任意描述符准备好读时返回。要注意使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
</li>
<li><p>异步I/O(asynchronous I/O)：<img src="https://segmentfault.com/img/bVm1c8" alt=""> 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
</li>
</ol>
<h2 id="阻塞和非阻塞的区别"><a href="#阻塞和非阻塞的区别" class="headerlink" title="阻塞和非阻塞的区别"></a>阻塞和非阻塞的区别</h2><p>调用阻塞I/O会一直阻塞住对应的进程直到操作完成，而非阻塞I/O在kernel还准备数据的情况下会立刻返回。</p>
<h2 id="同步I-O和异步I-O的区别"><a href="#同步I-O和异步I-O的区别" class="headerlink" title="同步I/O和异步I/O的区别"></a>同步I/O和异步I/O的区别</h2><p>同步I/O:导致请求进程阻塞，直到I/O操作完成。</p>
<p>异步I/O:不导致请求进程阻塞。<br><img src="https://pic4.zhimg.com/80/7d3eb389b7724878bd7e12ebc6dbcdb5_hd.jpg" alt=""><br>可能有人看完上图后，会很疑惑为啥非阻塞I/O也属于同步I/O了呢，它不是请求后直接返回了吗，尽管数据未准备好时它得到的error返回，那么也没有被阻塞啊。这里就是概念没有理解透彻导致的思想啦，其实不仅是kernel数据等待会阻塞进程，把kernel中的数据拷贝到用户内存中，也同样是阻塞用户进程的，你可以再仔细看一下上面I/O模式的介绍图，它是在两个过程结束后才返回OK的。所以非阻塞I/O也定义为同步I/O.</p>
<p>而异步I／O则不一样，当进程发起I／O操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说I/O完成。在这整个过程中，进程完全没有被阻塞。而这个过程就如同Python中的async/await一样。</p>
<h2 id="各个I-O模式的对比"><a href="#各个I-O模式的对比" class="headerlink" title="各个I/O模式的对比"></a>各个I/O模式的对比</h2><p><img src="https://segmentfault.com/img/bVm1c9" alt=""><br>通过上面图片，可以发现非阻塞I/O和异步I/O的区别还是很明显的。在非阻塞I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步I/O则完全不同。它就像是用户进程将整个I/O操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解计算机系统》第三版，第十章。</p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux I/O模式</a></p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文没有用任何代码，希望先用文字将这些概念梳理清楚。对于I/O复用，以及系统级别的并发，会在后面用实际的代码来提供完整的参考与理解。</p>
<p>如有纰漏之处，希望大家不吝赐教。Have fun :)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;*注：本文是对众多资料的学习和总结，可能存在理解错误。请带着怀疑的眼光，同时如果有错误希望能指出，谢谢您。*&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;UNIX-I-O&quot;&gt;&lt;a href=&quot;#UNIX-I-O&quot; class=&quot;headerlink&quot; title=&quot;U
    
    </summary>
    
    
      <category term="计算机系统、并发" scheme="http://miks.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%81%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
    <title>Python asyncio模块介绍</title>
    <link href="http://miks.top/2017/12/19/Python-asyncio%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/12/19/Python-asyncio模块介绍/</id>
    <published>2017-12-19T15:00:51.000Z</published>
<<<<<<< HEAD
    <updated>2018-01-24T16:35:23.000Z</updated>
=======
    <updated>2018-01-24T15:59:00.000Z</updated>
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。</p>
<p>注意：本文的思路来自于Fluent Python，这也是我对书中asyncio章节的总结。</p>
<h2 id="A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent"><a href="#A-comparison-between-a-simple-threaded-program-and-the-asyncio-equivalent" class="headerlink" title="A comparison between a simple threaded program and the asyncio equivalent"></a>A comparison between a simple threaded program and the asyncio equivalent</h2><p>我们接下来做一个在线程中的循环打印出类似gif动画效果的demo,并且用一个time.sleep(3)的函数来模拟阻塞。</p>
<p>Thread demo:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Signal:</div><div class="line">    go = True</div><div class="line"></div><div class="line"></div><div class="line">def spin(msg, signal):</div><div class="line">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class="line">    for char in itertools.cycle(&apos;|/-\\&apos;):</div><div class="line">        status = char + &apos; &apos; + msg</div><div class="line">        write(status)</div><div class="line">        flush()</div><div class="line">        write(&apos;\x08&apos; * len(status))</div><div class="line">        time.sleep(.1)</div><div class="line">        if not signal.go:</div><div class="line">            break</div><div class="line">    write(&apos; &apos; * len(status) + &apos;\x08&apos; * len(status))</div><div class="line"></div><div class="line"></div><div class="line">def slow_function():</div><div class="line">    time.sleep(3)</div><div class="line">    return 42</div><div class="line"></div><div class="line"></div><div class="line">def supervisor():</div><div class="line">    signal = Signal()</div><div class="line">    spinner = threading.Thread(target=spin,</div><div class="line">                               args=(&apos;thinkg!&apos;, signal))</div><div class="line">    print(&apos;spinner object:&apos;, spinner)</div><div class="line">    spinner.start()</div><div class="line">    result = slow_function()</div><div class="line">    signal.go = False</div><div class="line">    spinner.join()</div><div class="line">    return result</div><div class="line"></div><div class="line">def main():</div><div class="line">    result = supervisor()</div><div class="line">    print(&apos;Answer:&apos;, result)</div><div class="line">因为用sys.stdout.write和sys.stdout.flush，所以输出结果类似于gif动画。为了观察demo的运行结果，最好尝试在电脑上运行一下这个demo。</div></pre></td></tr></table></figure>
<p>注意itertools.cycle是无限的循环迭代，所以我们用一个signal来控制循环的结束。</p>
<h3 id="关于asyncio版本的代码做几点解释："><a href="#关于asyncio版本的代码做几点解释：" class="headerlink" title="关于asyncio版本的代码做几点解释："></a>关于asyncio版本的代码做几点解释：</h3><ol>
<li>Coroutines要被asyncio模块使用的话，应该要使用asyncio.coroutine装饰器。这不是强制的，但是为了突出coroutine不同与一般函数，并且在被垃圾回收时，如果没有调用yield from那么在debug时会被当作bug抛出来，所以推荐使用asyncio.coroutine装饰器.</li>
<li>使用yield from asyncio.sleep(.1) 替换了 time.sleep(.1)。即使后者可以在I/O操作时释放GIL，但是Coroutine的操作时在单线程中进行的。所以必须要使用前者，否则当前线程会被阻塞。</li>
<li>当yield from asyncio.sleep()挂起当前操作时，程序的控制流会返回到主循环内，直到当前休眠时间结束，才会重新被唤醒。</li>
<li>aysncio.async(…)安排spin coroutine去运行，将其封装成Task对象后立即返回。</li>
<li>Task对象可以被结束，asyncio.CancelledError异常会在程序被挂起的地方抛出，但是异常被coroutine捕获后可能会被延迟结束或者拒绝结束。</li>
<li>run<em> until</em> complete()会驱动coroutine运行，返回的结果是coroutine的返回值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@asyncio.coroutine</div><div class="line">def spin(msg):</div><div class="line">    write, flush = sys.stdout.write, sys.stdout.flush</div><div class="line">    for char in itertools.cycle(&apos;|/-\\&apos;):</div><div class="line">        status = char + &apos; &apos; + msg</div><div class="line">        write(status)</div><div class="line">        flush()</div><div class="line">        write(&apos;\x08&apos; * len(status))</div><div class="line">        try:</div><div class="line">            yield from asyncio.sleep(.1)</div><div class="line">        except asyncio.CancelledError:</div><div class="line">            break</div><div class="line">    write(&apos; &apos; * len(status) + &apos;\x08&apos; * len(status))</div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def slow_function():</div><div class="line">    yield from asyncio.sleep(3)</div><div class="line">    return 42</div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def supervisor():</div><div class="line">    spinner = asyncio.ensure_future(spin(&apos;thinking!&apos;))</div><div class="line">    print(&apos;spinner object:&apos;, spinner)</div><div class="line">    result = yield from slow_function()</div><div class="line">    spinner.cancel()</div><div class="line">    return result</div><div class="line"></div><div class="line"></div><div class="line">def main():</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    result = loop.run_until_complete(supervisor())</div><div class="line">    loop.close()</div><div class="line">    print(&apos;Answer:&apos;, result)</div></pre></td></tr></table></figure>
<p>对比上面两个版本的demo,解释一下它们之间的区别：</p>
<ol>
<li>一个Task驱动一个coroutine,一个线程调用一个callable.</li>
<li>我们不能实例一个Task对象，只能通过传递coroutine给asyncio.async(…)或者loop.create_ task(…)来获得Task对象。</li>
<li>当你得到一个Task对象时，说明当前任务已经被安排运行了；一个线程实例的运行，必须要显示的调用.start()方法。</li>
<li>在Thread demo中，slow_function是一个普通的函数，直接被当前线程调用；在asyncio中，slow_funciton是一个coroutine，被yield from驱动。</li>
<li>没有从线程外部终结线程的API,因为强制的终结会让该线程系统处于一个不清晰的状态。对于Task来说，Task.cancle()的实例方法，可以在coroutine中抛出cancelledError，这个异常会在coroutine的yield语句处被捕捉。</li>
<li>supervisor必须在main函数中通过loop.run<em> until</em> complete()调用。</li>
<li>在threads项目时，由于一个线程可能会在任一时刻被杀死，从而导致数据／系统状态变的不清晰。所以必须记得加锁去保护程序中重要的操作，避免在多个操作步骤中突然被终止的弊端；在coroutine中，避免意外的终止带来的弊端，所有的操作都被保护了。由于一个coroutine只有在被yield语句挂起时终止，所以我们可以在处理CancelledError异常时清理掉「不干净」的操作。</li>
</ol>
<h2 id="How-the-asyncio-Future-class-differs-from-concurrent-futures-Future"><a href="#How-the-asyncio-Future-class-differs-from-concurrent-futures-Future" class="headerlink" title="How the asyncio.Future class differs from concurrent.futures.Future"></a>How the asyncio.Future class differs from concurrent.futures.Future</h2><p>如果你还不清楚future的概念，你可以参考我写的另一篇文章<a href="http://www.ganbinwen.com/2017/12/13/Python-concurrency-with-futures/" target="_blank" rel="external">Python concurrency with futures</a>，里面有相关介绍，或者可以自行参考官方文档/wiki。</p>
<p>请务必确认已经清楚了future的概念后再阅读下面内容 :)</p>
<p>asyncio中的future：</p>
<ul>
<li>asyncio中Task是Future的子类,故Task也是Future。</li>
<li>对future用yield from时，不会阻塞事件循环，因为在asyncio中yield from会将控制流返回到事件循环内。</li>
<li>对future进行yield from就相当于add _done _callback()函数，当延迟操作结束后，事件循环会设置future的结果，然后yield from表达式会在被挂起的coroutine内部产生一个返回值，并且重新唤起它。</li>
<li>yield from my<em> future 相当于 my</em> future.add<em> done</em> callback()函数， result = yield from my_future,相当于my _future.result()函数，可见yield from在asyncio中是非常重要的。</li>
</ul>
<p>asyncio中我们可以通过yield from得到asyncio.Future中的结果，这意味着res = yield from foo()中foo是一个coroutine函数的话可以返回一个coroutine，如果foo只是一个普通函数，那么返回一个Future或者Task实例。<br>为了执行操作，一个coroutine必须要被安排，然后将其封装成aysncio.Task对象，有两种方式可以得到一个Task对象：</p>
<ol>
<li><p>aysncio.async(coro_or_future, *, loop=None)</p>
<ul>
<li>这个函数的第一个参数可以是coroutines或者futures。如果是Future/Task那么不做修改的返回。如果是一个coroutine，aysnc通过loop.create<em> task()来创建一个Task对象返回。一个可选的关键字参数是loop,如果忽略这个参数，async会通过asyncio.get</em> event_ loop()来的到一个loop对象。</li>
</ul>
</li>
</ol>
<ol>
<li><p>BaseEventLoop.create_task(coro)</p>
<ul>
<li>这个方法安排coroutine操作，并且返回一个asyncio.Task对象。</li>
</ul>
</li>
</ol>
<p>几个不同的asyncio函数接受coroutines并将其封装为asyncio.Task对象。在内部使用asyncio.async自动完成封装,如接下来的demo中run_ until_complete()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import asyncio</div><div class="line"></div><div class="line"></div><div class="line">def run_sync(coro_or_future):</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    return loop.run_until_complete(coro_or_future)</div><div class="line"></div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def coro():</div><div class="line">    yield from asyncio.sleep(1)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    a = run_sync(coro())</div></pre></td></tr></table></figure>
<h2 id="Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes"><a href="#Asynchronous-programming-manages-high-concurrency-in-network-applications-without-using-threads-or-processes" class="headerlink" title="Asynchronous programming manages high concurrency in network applications, without using threads or processes"></a>Asynchronous programming manages high concurrency in network applications, without using threads or processes</h2><p>我们使用aiohttp这个第三方库来完善我们的Http Client。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import asyncio</div><div class="line">import aiohttp</div><div class="line">import time</div><div class="line">import os</div><div class="line">import sys</div><div class="line"></div><div class="line">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class="line">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class="line">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class="line"></div><div class="line">DEST_DIR = &apos;downloads/&apos;</div><div class="line"></div><div class="line"></div><div class="line">def save_flags(img, filename):</div><div class="line">    path = os.path.join(DEST_DIR, filename)</div><div class="line">    with open(path, &apos;wb&apos;) as fp:</div><div class="line">        fp.write(img)</div><div class="line"></div><div class="line"></div><div class="line">def show(text):</div><div class="line">    print(text, end=&apos; &apos;)</div><div class="line">    sys.stdout.flush()</div><div class="line"></div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def get_flag(cc):</div><div class="line">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class="line">    session = aiohttp.ClientSession()</div><div class="line">    res = yield from session.get(url)</div><div class="line">    # res = yield from aiohttp.request(&apos;GET&apos;, url) will occur error with &apos;Unclosed client session&apos;.</div><div class="line">    image = yield from res.read()</div><div class="line">    session.close()</div><div class="line">    return image</div><div class="line"></div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def download_one(cc):</div><div class="line">    image = yield from get_flag(cc)</div><div class="line">    show(cc)</div><div class="line">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class="line">    return cc</div><div class="line"></div><div class="line"></div><div class="line"># @asyncio.coroutine</div><div class="line">def download_many(cc_list):</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    to_do = [download_one(cc) for cc in sorted(cc_list)]</div><div class="line">    wait_coro = asyncio.wait(to_do)</div><div class="line">    res, _ = loop.run_until_complete(wait_coro)</div><div class="line">    loop.close()</div><div class="line"></div><div class="line">    return len(res)</div><div class="line"></div><div class="line"></div><div class="line">def main(download_many):</div><div class="line">    t0 = time.time()</div><div class="line">    count = download_many(POP20_CC)</div><div class="line">    elapsed = time.time() - t0</div><div class="line">    msg = &apos;\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class="line">    print(msg.format(count, elapsed))</div><div class="line">CN EG FR BR JPMX NG RU BD VN IN ID PK TR ET IR US CD PH DE </div><div class="line">19 flags download in 3.85s</div></pre></td></tr></table></figure>
<p>asyncio.wait()不是一个阻塞函数，它会等到所有传递给它的coroutines操作结束。它接受coroutines/futures的iterable，将每个coroutine封装成Task实例<br>当事件循环运行时，loop.run<em> until</em> complete(wait_ coro)会阻塞。这个函数会返回2-tuple，tuple[0]是完成的集合，tuple[1]是未完成的集合。未完成的值可以通过在.wait()函数里传timeout关键字参数或者return_when关键字参数得到。</p>
<p>这个demo里包含了很多新的概念，但是简单的驱动流程就是，在get<em> flag里用yield from驱动aiohttp所以get</em> flag是一个coroutine，同样在download<em> one里用yield from驱动get</em> flag所以它也是一个coroutine，最后在download<em> many通过loop.run</em> until_ complete来驱动被asyncio.wait()方法实例过的Tasks。</p>
<p>可能明白了上述的驱动流程，但是对何时使用yield from还有困惑，那么我们再总结一下，yield from的使用：</p>
<ol>
<li>每一个用yield from排列好的coroutine链，最后调用的caller自身一定不能是coroutine。caller需要用next()/.send()来调用最外层的delegating generator.（隐式的for循环也可以）.</li>
<li>链中最内层的subgenerator一定要是一个简单的generator，它只能使用yield或者它是一个iterable对象。</li>
</ol>
<p>当在asyncio中使用yield from时不仅要注意以上两点，还有一些需要注意：<br>驱动最外层的delegating generator我们一般使用asyncio的API来完成，比如loop.run<em> until</em> complete(…) ；最里面的subgenerator通常yield from一些asyncio coroutine函数或者coroutine函数，总之就是最内部的subgenerator通常会是一些第三方的库函数来进行I/O操作。</p>
<h2 id="How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming"><a href="#How-coroutines-are-a-major-improvement-over-callbacks-for-asynchronous-programming" class="headerlink" title="How coroutines are a major improvement over callbacks for asynchronous programming"></a>How coroutines are a major improvement over callbacks for asynchronous programming</h2><p>通过上面的demo及介绍，细心的你有没有发现所有的操作都是在同一个线程中完成的？如果都在同一个线程里完成操作，那么如何提高5x的运行速度？</p>
<p>对于I/O操作有两种方法可以避免阻塞的方法去停止程序的整个进程：</p>
<ol>
<li>让阻塞操作在不同的线程中运行。</li>
<li>让用非阻塞的异步操作来调用阻塞操作。</li>
</ol>
<p>我们知道多线程的方式是有效的，但是每个线程都要消耗系统内存，当需要处理的线程数量级非常大时，我们承担不起每个线程连接需要耗费的资源。</p>
<p>使用coroutines时，generator提供了可选的方式去进行异步编程，用事件循环来回调或者使用.send()操作挂起的coroutine即可。每个挂起的coroutine都需要消耗内存资源，但开销远小于线程的开销。</p>
<<<<<<< HEAD
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line"></div><div class="line">## How to avoid blocking the event loop by offloading blocking operations to a thread pool</div><div class="line">尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？</div><div class="line">在asyncio中，有一个thread pool executor，我们可以将callable通过run _in _ executor()传递。</div></pre></td></tr></table></figure>
<p>@asyncio.coroutine<br>def download_one(cc, base_url, semaphore, verbose):<br>    try:<br>        with (yield from semaphore):<br>            image = yield from get_flag(base_url, cc)<br>    except web.HTTPNotFound:<br>        status = HTTPStatus.NOT_FOUND<br>        msg = ‘not found’<br>    except Exception as exc:<br>        raise FetchError(cc) from exc<br>    else:<br>        loop = asyncio.get_event_loop()<br>        loop.run_in_executor(None, save_flags, image, cc.lower() + ‘.gif’) # Avoiding blocking.<br>        status = HTTPStatus.OK<br>        msg = ‘OK’</p>
<pre><code>if verbose and msg:
    print(cc, msg)

return Result(status, cc)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## Callback Hell</div><div class="line">关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</div></pre></td></tr></table></figure>
<p>def stage1(response1):<br>    request2 = step1(response1)<br>    api_call2(request2, stage2)</p>
<p>def stage2(response2):<br>    request3 = step2(response2)<br>    api_call3(request3, stage3)</p>
<p>def stage3(response3):<br>    step(response3)</p>
<p>api_call(request1, stage1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">分析一下这种风格的代码：</div><div class="line">读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。</div><div class="line">接下来我们再用coroutine来完成上述逻辑。</div></pre></td></tr></table></figure></p>
<p>@asyncio.coroutine<br>def three_stages(request1):<br>    response1 = yield from api_call1(request1)</p>
<pre><code>request2 = step1(response1)
response2 = yield from api_call2(request2)

request3 = step2(response2)
response3 = yield from api_call3(request3)

step3(request3)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</div><div class="line"></div><div class="line">尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create_ task(three_ stages(request1))来调用。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Writing asyncio servers, and how to rethink Web applications for high concurrency </div><div class="line">接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</div></pre></td></tr></table></figure>
<p>import sys<br>import asyncio</p>
<p>from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</p>
<p>CRLF = b’\r\n’<br>PROMPT = b’?&gt;’<br>index = UnicodeNameIndex()</p>
<p>@asyncio.coroutine<br>def handle_queries(reader, writer):<br>    while True:<br>        writer.write(PROMPT)<br>        yield from writer.drain()<br>        data = yield from reader.readline()<br>        try:<br>            query = data.decode().strip()<br>        except UnicodeDecodeError:<br>            query = ‘\x00’<br>        client = writer.get_extra_info(‘peername’)<br>        print(‘Received from {}: {!r}’.format(client, query))<br>        if query:<br>            if ord(query[:1]) &lt; 32:<br>                break<br>            lines = list(index.find_description_strs(query))<br>            if lines:<br>                writer.writelines(line.encode() + CRLF for line in lines)<br>            writer.write(index.status(query, len(lines)).encode() + CRLF)</p>
<pre><code>        yield from writer.drain()
        print(&apos;Sent {} results&apos;.format(len(lines)))
print(&apos;Close the client socket&apos;)
writer.close()
</code></pre><p>def main(address=’127.0.0.1’, port=2323):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)<br>    server = loop.run_until_complete(server_coro)</p>
<pre><code>host = server.sockets[0].getsockname()
print(&apos;Serving on {} Hit CTRL-C to stop.&apos;.format(host))
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

print(&apos;Server shutting down.&apos;)
server.close()
loop.run_until_complete(server.wait_closed())
loop.close()
</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main(*sys.argv[1:])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">希望你尝试运行上面的代码后再继续阅读，用loop.run_ forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle_ queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</div><div class="line"></div><div class="line">Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</div><div class="line"></div><div class="line"></div><div class="line">接下来再看一下http版本的：</div></pre></td></tr></table></figure></p>
<p>@asyncio.coroutine<br>def init(loop, address, port):<br>    app = web.Application(loop=loop)<br>    app.router.add_route(‘GET’, ‘/‘, home)<br>    handler = app.make_handler()<br>    server = yield from loop.create_server(handler, address, port)</p>
<pre><code>return server.sockets[0].getsockname()
</code></pre><p>def main(address=’127.0.0.1’, port=8888):<br>    port = int(port)<br>    loop = asyncio.get_event_loop()<br>    host = loop.run_until_complete(init(loop, address, port))<br>    print(‘Servering on {}. Hit CTRL-C to stop.’.format(host))<br>    try:<br>        loop.run_forever()<br>    except KeyboardInterrupt:<br>        pass<br>    print(‘Server shutting down.’)<br>    loop.close()</p>
<p>def home(request):<br>    query = request.GET.get(‘query’, ‘’).strip()<br>    print(‘Query: {!r}’.format(query))<br>    if query:<br>        descriptions = list(index.find_descriptions(query))<br>        res = ‘\n’.join(ROW_TPL.format(**vars(descr))<br>                        for descr in descriptions)<br>        msg = index.status(query, len(descriptions))</p>
<pre><code>else:
    descriptions = []
    res = &apos;&apos;
    msg = &apos;Enter words describing characters.&apos;

html = template.format(query, res, msg)

print(&apos;Sending {} results&apos;.format(len(descriptions)))
return web.Response(content_type=CONTENT_TYPE, text=html)
</code></pre><p>```</p>
=======
<h2 id="How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool"><a href="#How-to-avoid-blocking-the-event-loop-by-offloading-blocking-operations-to-a-thread-pool" class="headerlink" title="How to avoid blocking the event loop by offloading blocking operations to a thread pool"></a>How to avoid blocking the event loop by offloading blocking operations to a thread pool</h2><p>尽管我们已经可以处理网络I/O的延迟了，但是对于文件I/O操作的延迟，要如何处理呢？<br>在asyncio中，有一个thread pool executor，我们可以将callable通过run <em>in </em> executor()传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@asyncio.coroutine</div><div class="line">def download_one(cc, base_url, semaphore, verbose):</div><div class="line">    try:</div><div class="line">        with (yield from semaphore):</div><div class="line">            image = yield from get_flag(base_url, cc)</div><div class="line">    except web.HTTPNotFound:</div><div class="line">        status = HTTPStatus.NOT_FOUND</div><div class="line">        msg = &apos;not found&apos;</div><div class="line">    except Exception as exc:</div><div class="line">        raise FetchError(cc) from exc</div><div class="line">    else:</div><div class="line">        loop = asyncio.get_event_loop()</div><div class="line">        loop.run_in_executor(None, save_flags, image, cc.lower() + &apos;.gif&apos;) # Avoiding blocking.</div><div class="line">        status = HTTPStatus.OK</div><div class="line">        msg = &apos;OK&apos;</div><div class="line"></div><div class="line">    if verbose and msg:</div><div class="line">        print(cc, msg)</div><div class="line"></div><div class="line">    return Result(status, cc)</div></pre></td></tr></table></figure>
<h2 id="Callback-Hell"><a href="#Callback-Hell" class="headerlink" title="Callback Hell"></a>Callback Hell</h2><p>关于这个话题，我有自己的亲身体验。之前写FireStone的胎压信息的爬虫时，需要连续构造异步请求，才能从车的厂商信息获取到每台特定型号车辆的胎压信息。类似的逻辑如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def stage1(response1):</div><div class="line">    request2 = step1(response1)</div><div class="line">    api_call2(request2, stage2)</div><div class="line"></div><div class="line">def stage2(response2):</div><div class="line">    request3 = step2(response2)</div><div class="line">    api_call3(request3, stage3)</div><div class="line"></div><div class="line">def stage3(response3):</div><div class="line">    step(response3)</div><div class="line"></div><div class="line">api_call(request1, stage1)</div></pre></td></tr></table></figure>
<p>分析一下这种风格的代码：<br>读起来麻烦，写起来更麻烦。每个函数都在执行整个任务的一部分，同时为下一次callback做配置及调用。这意味着下一次callback时，本地的上下文就已经丢失了。比如当stage2运行时，request2这个变量已经不存在了。如果需要保存这个变量，那必须要依赖闭包操作或者是用外部的数据结构来保存。<br>接下来我们再用coroutine来完成上述逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@asyncio.coroutine</div><div class="line">def three_stages(request1):</div><div class="line">    response1 = yield from api_call1(request1)</div><div class="line"></div><div class="line">    request2 = step1(response1)</div><div class="line">    response2 = yield from api_call2(request2)</div><div class="line">    </div><div class="line">    request3 = step2(response2)</div><div class="line">    response3 = yield from api_call3(request3)</div><div class="line">    </div><div class="line">    step3(request3)</div></pre></td></tr></table></figure>
<p>不需要callbacks，也可以异步的完成三个连续操作。普通的callbacks对于异常的处理，需要在每个函数里写好两种处理情况：操作正常的返回和操作不正常的返回。这样大大加大了函数的繁琐程度。而coroutine版本的只需要在同一个函数里用try/except来处理就可以了。</p>
<p>尽管coroutine对比普通的版本，避免了callback hell，但是一旦使用coroutine,意味着所有的函数都需要发生改动。要让整个调用流程必须符合coroutine chain的规则，如最内部的函数需要被安排进任务里，最外部的需要用loop.create<em> task(three</em> stages(request1))来调用。</p>
<h2 id="Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency"><a href="#Writing-asyncio-servers-and-how-to-rethink-Web-applications-for-high-concurrency" class="headerlink" title="Writing asyncio servers, and how to rethink Web applications for high concurrency"></a>Writing asyncio servers, and how to rethink Web applications for high concurrency</h2><p>接下来我们一起创造一个TCP Server，这个server允许client用名称单词来查询Unicode自字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">import asyncio</div><div class="line"></div><div class="line">from Fluent_Python_demo.Asyncio_demo.charfinder import UnicodeNameIndex</div><div class="line"></div><div class="line">CRLF = b&apos;\r\n&apos;</div><div class="line">PROMPT = b&apos;?&gt;&apos;</div><div class="line">index = UnicodeNameIndex()</div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def handle_queries(reader, writer):</div><div class="line">    while True:</div><div class="line">        writer.write(PROMPT)</div><div class="line">        yield from writer.drain()</div><div class="line">        data = yield from reader.readline()</div><div class="line">        try:</div><div class="line">            query = data.decode().strip()</div><div class="line">        except UnicodeDecodeError:</div><div class="line">            query = &apos;\x00&apos;</div><div class="line">        client = writer.get_extra_info(&apos;peername&apos;)</div><div class="line">        print(&apos;Received from &#123;&#125;: &#123;!r&#125;&apos;.format(client, query))</div><div class="line">        if query:</div><div class="line">            if ord(query[:1]) &lt; 32:</div><div class="line">                break</div><div class="line">            lines = list(index.find_description_strs(query))</div><div class="line">            if lines:</div><div class="line">                writer.writelines(line.encode() + CRLF for line in lines)</div><div class="line">            writer.write(index.status(query, len(lines)).encode() + CRLF)</div><div class="line"></div><div class="line">            yield from writer.drain()</div><div class="line">            print(&apos;Sent &#123;&#125; results&apos;.format(len(lines)))</div><div class="line">    print(&apos;Close the client socket&apos;)</div><div class="line">    writer.close()</div><div class="line"></div><div class="line">def main(address=&apos;127.0.0.1&apos;, port=2323):</div><div class="line">    port = int(port)</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    server_coro = asyncio.start_server(handle_queries, address, port, loop=loop)</div><div class="line">    server = loop.run_until_complete(server_coro)</div><div class="line"></div><div class="line">    host = server.sockets[0].getsockname()</div><div class="line">    print(&apos;Serving on &#123;&#125; Hit CTRL-C to stop.&apos;.format(host))</div><div class="line">    try:</div><div class="line">        loop.run_forever()</div><div class="line">    except KeyboardInterrupt:</div><div class="line">        pass</div><div class="line"></div><div class="line">    print(&apos;Server shutting down.&apos;)</div><div class="line">    server.close()</div><div class="line">    loop.run_until_complete(server.wait_closed())</div><div class="line">    loop.close()</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main(*sys.argv[1:])</div></pre></td></tr></table></figure>
<p>希望你尝试运行上面的代码后再继续阅读，用loop.run<em> forever()来阻塞代码，控制流在事件循环中，一直停留在这。直到需要处理handle</em> queries coroutine时，将控制流跳到yield中等待client发送数据。当事件循环存在的时候，每个client连接到server时都会实例一个新的handle_ queries，这样简单的server也可以并发处理多个client了。</p>
<p>Tips: 在上面的代码中，我们使用了高级的asyncio Streams API，它已经准备好应用在server中了，所以我们只需要去写好handler函数即可(普通的函数 或者 coroutine).</p>
<p>接下来再看一下http版本的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@asyncio.coroutine</div><div class="line">def init(loop, address, port):</div><div class="line">    app = web.Application(loop=loop)</div><div class="line">    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, home)</div><div class="line">    handler = app.make_handler()</div><div class="line">    server = yield from loop.create_server(handler, address, port)</div><div class="line"></div><div class="line">    return server.sockets[0].getsockname()</div><div class="line"></div><div class="line"></div><div class="line">def main(address=&apos;127.0.0.1&apos;, port=8888):</div><div class="line">    port = int(port)</div><div class="line">    loop = asyncio.get_event_loop()</div><div class="line">    host = loop.run_until_complete(init(loop, address, port))</div><div class="line">    print(&apos;Servering on &#123;&#125;. Hit CTRL-C to stop.&apos;.format(host))</div><div class="line">    try:</div><div class="line">        loop.run_forever()</div><div class="line">    except KeyboardInterrupt:</div><div class="line">        pass</div><div class="line">    print(&apos;Server shutting down.&apos;)</div><div class="line">    loop.close()</div><div class="line"></div><div class="line"></div><div class="line">def home(request):</div><div class="line">    query = request.GET.get(&apos;query&apos;, &apos;&apos;).strip()</div><div class="line">    print(&apos;Query: &#123;!r&#125;&apos;.format(query))</div><div class="line">    if query:</div><div class="line">        descriptions = list(index.find_descriptions(query))</div><div class="line">        res = &apos;\n&apos;.join(ROW_TPL.format(**vars(descr))</div><div class="line">                        for descr in descriptions)</div><div class="line">        msg = index.status(query, len(descriptions))</div><div class="line"></div><div class="line">    else:</div><div class="line">        descriptions = []</div><div class="line">        res = &apos;&apos;</div><div class="line">        msg = &apos;Enter words describing characters.&apos;</div><div class="line"></div><div class="line">    html = template.format(query, res, msg)</div><div class="line"></div><div class="line">    print(&apos;Sending &#123;&#125; results&apos;.format(len(descriptions)))</div><div class="line">    return web.Response(content_type=CONTENT_TYPE, text=html)</div></pre></td></tr></table></figure>
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
<p>对于server的启动以及handler大致都与上面TCP版本的相同，我们这里从home()函数开始介绍。仔细观察的你，能发现home()是一个普通的函数，这意味着，从request的处理到可能会进行的database查询都是阻塞的，如果database查询数量很大的话，通常是秒级以上的，我们不能容忍这样的情况。不过有过web开发的小伙伴通常都会想到AJAX技术，这确实是一种好的处理方法。我们可以将查询限制在200rows,在前端界面用滚动条来控制这个间隔。</p>
<h2 id="Parallelism-and-Concurrency"><a href="#Parallelism-and-Concurrency" class="headerlink" title="Parallelism and Concurrency"></a>Parallelism and Concurrency</h2><p>给大家分享《Fluent Python》中的一则quote.</p>
<p><em>Concurrency is about dealing with lots of things at once.</em></p>
<p><em>Parallelism is about doing lots of things at once.</em></p>
<p><em>Not the same, but related.</em></p>
<p><em>One is about structure, one is about execution.</em></p>
<p><em>Concurrency provides a way to structure a solution to solve a problem that may(but not necessarily)be parallelizable.</em>  </p>
<pre><code>-----Rob Pike
</code></pre><p>这段quote揭示了中文里的<strong>并行</strong>和<strong>并发</strong>的区别。对于真实的并行来说，你的CPU必须要有多核。笔记本大多是4核的，可实际上运行的进程数量远高于这个数量级，所以大多数的进程运行是并发而不是并行的。计算机即使同时处理100+进程，也可以保证每个进程都与机会去处理其中的任务。</p>
<p>对于这组概念，网络上有很多教材／wiki／视频，讲解的都远比我更详细和精准。如果你对它们很陌生或者心中仍存有困惑，请自行查阅资料:).</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>最后，感谢你的阅读。如果你认为文章中有描述不清楚，或者错误的地方，请务必告诉我。 期待你的feedback :)</p>
<p>本文代码地址：<a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Asyncio_demo" target="_blank" rel="external">asycnio_demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;本文介绍asyncio模块，这个模块使用事件轮询来驱动的coroutine对并发任务进行操作。&lt;/p
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python concurrency with futures</title>
    <link href="http://miks.top/2017/12/13/Python-concurrency-with-futures/"/>
    <id>http://miks.top/2017/12/13/Python-concurrency-with-futures/</id>
    <published>2017-12-13T03:42:48.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书中的两个Web下载实例来帮助你理解这个概念。</p>
<h2 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import time</div><div class="line">import sys</div><div class="line"></div><div class="line">import requests  # It&apos;s not the standard library, so separate it from top with a blank line.</div><div class="line"></div><div class="line">POP20_CC = (&apos;CN IN US ID BR PK NG BD RU JP&apos;</div><div class="line">            &apos;MX PH VN ET EG DE IR TR CD FR&apos;).split()</div><div class="line"></div><div class="line">BASE_URL = &apos;http://flupy.org/data/flags&apos;</div><div class="line"></div><div class="line">DEST_DIR = &apos;downloads/&apos;</div><div class="line"></div><div class="line"></div><div class="line">def save_flags(img, filename):</div><div class="line">    path = os.path.join(DEST_DIR, filename)</div><div class="line">    with open(path, &apos;wb&apos;) as fp:</div><div class="line">        fp.write(img)</div><div class="line"></div><div class="line"></div><div class="line">def get_flag(cc):</div><div class="line">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(BASE_URL, cc=cc.lower())</div><div class="line">    resp = requests.get(url)</div><div class="line">    return resp.content</div><div class="line"></div><div class="line"></div><div class="line">def show(text):</div><div class="line">    print(text, end=&apos; &apos;)</div><div class="line">    sys.stdout.flush()  # flush stdout buffter.</div><div class="line"></div><div class="line"></div><div class="line">def download_many(cc_list):</div><div class="line">    for cc in sorted(cc_list):</div><div class="line">        image = get_flag(cc)</div><div class="line">        show(cc)</div><div class="line">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class="line"></div><div class="line">    return len(cc_list)</div><div class="line"></div><div class="line"></div><div class="line">def main(download_many):</div><div class="line">    t0 = time.time()</div><div class="line">    count = download_many(POP20_CC)</div><div class="line">    elapsed = time.time() - t0</div><div class="line">    msg = &apos;\n&#123;&#125; flags download in &#123;:.2f&#125;s&apos;</div><div class="line">    print(msg.format(count, elapsed))</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main(download_many)</div><div class="line"></div><div class="line">BD BR CD CN DE EG ET FR ID IN IR JPMX NG PH PK RU TR US VN </div><div class="line">19 flags download in 21.66s</div></pre></td></tr></table></figure>
<h2 id="Concurrent-futures"><a href="#Concurrent-futures" class="headerlink" title="Concurrent.futures"></a>Concurrent.futures</h2><p>主要的Concurrent.futures的包是ThreadPoolExecutor和ProcessPoolExecutor，它们实现的接口允许你使用多个线程或者进程，但是不用去关心底层的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from concurrent import futures</div><div class="line"></div><div class="line">from Fluent_Python_demo.Concurrency_demo.sequential_script_demo import save_flags, get_flag, show, main</div><div class="line"></div><div class="line">MAX_WORKERS = 20</div><div class="line"></div><div class="line">def download_one(cc):</div><div class="line">    image = get_flag(cc)</div><div class="line">    show(cc)</div><div class="line">    save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class="line">    return cc</div><div class="line"></div><div class="line">def download_many(cc_list):</div><div class="line">    workers = min(MAX_WORKERS, len(cc_list))</div><div class="line">    with futures.ThreadPoolExecutor(workers) as executor:</div><div class="line">        res = executor.map(download_one, sorted(cc_list))</div><div class="line"></div><div class="line">    return len(list(res)) # 如果任意一个线程的发生了异常，由于隐式调用了next()方法得到返回值，所以异常会在这里被抛出。</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main(download_many)</div><div class="line">    </div><div class="line">TR RU IN JPMX BR VN DE EG FR NG ID CN PK PH CD IR ET US BD </div><div class="line">19 flags download in 1.69s</div></pre></td></tr></table></figure>
<ol>
<li>在上下文管理器中，executor的<strong>exit</strong>方法会调用executor.shutdown(wait=True),这个方法会阻塞直到所有的线程结束。</li>
<li>注意download_one()这个函数与上面的代码做个对比，我们可以发现将sequential的代码重构为concurrent时，可以直接将for循环里面的操作拆分成一个单独的函数，来支持后续的并发处理。</li>
</ol>
<p>看完了上面的代码，我们可能会产生一个困惑：future到底是啥？它背后的逻辑是怎么样的？</p>
<ul>
<li>future是本章以及后面介绍的asyncio的内部逻辑，但是作为用户是无法看到内部操作的。</li>
<li>它是Future class的实例，表示已经结束或者还未结束的计算的延时。</li>
<li>Futures是挂起操作，所以它们可以被放进队列中。它们的状态是可以被查询的，并且当挂起操作结束后，它们的结果是可以被保存或者调用的。</li>
<li>虽然它看起来很有意义，但是在使用时，应该让并发的框架来完成实例，而不是我们来控制。一个Future就代表一个最终会执行的操作，而唯一能确定某个操作会被执行的方法是这个操作已经被安排到任务中了。因此，Future实例是安排执行操作的Concurrent.futures.Future类创建的。</li>
<li>只有并发的框架会在future结束后改变它的状态，但是我们不能控制future何时发生，所以我们写的代码不支持改变future的状态。Future的.done()方法是非阻塞的，并且它会返回一个boolean类型的值来表明当前的future是否结束了。.add_done_callback()，需要我们来设定一个callable参数，当future结束后会将其当作参数传给callbale，并且调用它。.result()方法会返回callable的结果，或者抛出一些设定的异常。但是.result()这个方法在future没有结束前，在concurrency.futures.Future中，调用f.result()的话，将会阻塞线程，直到结果返回。如果我们设定了timeout参数话，结果没有在timeout内返回就会抛出TimeoutError异常。这个方法在asyncio中是非阻塞的，同时也不支持timeout设置，结果是通过yield from来返回的，这点与concurrency.futures.Future是不同的。</li>
</ul>
<p>接下来我们用concurrency.futures.as_completed()修改上面写过的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def download_many(cc_list):</div><div class="line">    cc_list = cc_list[:5]</div><div class="line">    with futures.ThreadPoolExecutor(max_workers=3) as executor:</div><div class="line">        to_do = []</div><div class="line">        for cc in sorted(cc_list):</div><div class="line">            future = executor.submit(download_one, cc)</div><div class="line">            to_do.append(future)</div><div class="line">            msg = &apos;Scheduled for &#123;&#125;: &#123;&#125;&apos;</div><div class="line">            print(msg.format(cc, future))</div><div class="line"></div><div class="line">        results = []</div><div class="line">        for future in futures.as_completed(to_do):</div><div class="line">            res = future.result()</div><div class="line">            msg = &apos;&#123;&#125; result: &#123;!r&#125;&apos;</div><div class="line">            print(msg.format(future, res))</div><div class="line">            results.append(res)</div><div class="line"></div><div class="line">    return len(results)</div><div class="line"></div><div class="line">Scheduled for BR: &lt;Future at 0x1020f2080 state=running&gt;</div><div class="line">Scheduled for CN: &lt;Future at 0x1020f27f0 state=running&gt;</div><div class="line">Scheduled for ID: &lt;Future at 0x1020f27b8 state=running&gt;</div><div class="line">Scheduled for IN: &lt;Future at 0x1020fe320 state=pending&gt;</div><div class="line">Scheduled for US: &lt;Future at 0x1020fe3c8 state=pending&gt;</div><div class="line">BR &lt;Future at 0x1020f2080 state=finished returned str&gt; result: &apos;BR&apos;</div><div class="line">ID &lt;Future at 0x1020f27b8 state=finished returned str&gt; result: &apos;ID&apos;</div><div class="line">IN &lt;Future at 0x1020fe320 state=finished returned str&gt; result: &apos;IN&apos;</div><div class="line">US &lt;Future at 0x1020fe3c8 state=finished returned str&gt; result: &apos;US&apos;</div><div class="line">CN &lt;Future at 0x1020f27f0 state=finished returned str&gt; result: &apos;CN&apos;</div><div class="line"></div><div class="line">5 flags download in 3.39s</div></pre></td></tr></table></figure>
<p>executor.submit(download_one, cc)安排download _one被执行，它会返回future。<br>注意看只有三个任务是runnning状态，另外的都是pending，这是因为只有三个worker导致的。</p>
<h5 id="Experimenting-with-Executor-map"><a href="#Experimenting-with-Executor-map" class="headerlink" title="Experimenting with Executor.map"></a>Experimenting with Executor.map</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">from time import sleep, strftime</div><div class="line">from concurrent import futures</div><div class="line"></div><div class="line"></div><div class="line">def display(*args):</div><div class="line">    print(strftime(&apos;[%H:%M:%S]&apos;), end=&apos; &apos;)</div><div class="line">    print(*args)</div><div class="line"></div><div class="line"></div><div class="line">def loiter(n):</div><div class="line">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): doing nothing for &#123;&#125;s...&apos;</div><div class="line">    display(msg.format(&apos;\t&apos; * n, n, n))</div><div class="line">    sleep(n)</div><div class="line">    msg = &apos;&#123;&#125;loiter(&#123;&#125;): done&apos;</div><div class="line">    display(msg.format(&apos;\t&apos; * n, n))</div><div class="line">    return n * 10</div><div class="line"></div><div class="line"></div><div class="line">def main():</div><div class="line">    display(&apos;Script starting.&apos;)</div><div class="line">    executor = futures.ThreadPoolExecutor(max_workers=3)</div><div class="line">    results = executor.map(loiter, range(5))</div><div class="line">    display(&apos;results:&apos;, results)</div><div class="line">    display(&apos;Wating for individual results:&apos;)</div><div class="line">    for i, result in enumerate(results):</div><div class="line">        display(&apos;result &#123;&#125;: &#123;&#125;&apos;.format(i, result))</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div><div class="line">[10:08:03] Script starting.</div><div class="line">[10:08:03] loiter(0): doing nothing for 0s...</div><div class="line">[10:08:03] loiter(0): done</div><div class="line">[10:08:03] 	loiter(1): doing nothing for 1s...</div><div class="line">[10:08:03] 		loiter(2): doing nothing for 2s...</div><div class="line">[10:08:03] results: &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x10d6ef468&gt;</div><div class="line">[10:08:03] Wating for individual results:</div><div class="line">[10:08:03] result 0: 0</div><div class="line">[10:08:03] 			loiter(3): doing nothing for 3s...</div><div class="line">[10:08:04] 	loiter(1): done</div><div class="line">[10:08:04] 				loiter(4): doing nothing for 4s...</div><div class="line">[10:08:04] result 1: 10</div><div class="line">[10:08:05] 		loiter(2): done</div><div class="line">[10:08:05] result 2: 20</div><div class="line">[10:08:06] 			loiter(3): done</div><div class="line">[10:08:06] result 3: 30</div><div class="line">[10:08:08] 				loiter(4): done</div><div class="line">[10:08:08] result 4: 40</div><div class="line">注意看打印时间。__iter__方法会阻塞代码，直到future返回结果。</div></pre></td></tr></table></figure>
<p>推荐你在你的电脑上运行一下这段代码，你很可能会发现尽管代码相同，但是打印顺序是不同的。由于YMMV(You Mileage May Vary):在多线程运行时，你永远不会准确的知道同一时刻内发生的事情。换台机器可能同一时刻内发生的情况就有所不同。</p>
<p>这段代码的阻塞情况与上面是不同的，它返回的结果是跟调用顺序完全相同的。比如你设定第一个任务需要等待10秒，其余任务执行时间为1秒，那么.map()会先阻塞10秒后再执行其余任务。所以如果你的任务需要按照顺序来执行，那么使用.map()是ok的，但是如果你的任务对调用顺序无所谓的话，Executor.submit,futures.as_completed()会更适合。</p>
<h2 id="Downloads-with-progress-display-and-error-handing"><a href="#Downloads-with-progress-display-and-error-handing" class="headerlink" title="Downloads with progress display and error handing"></a>Downloads with progress display and error handing</h2><p>我们先介绍python中一个有趣的库<strong>tqdm</strong>，利用这个库我们可以打印出运行的进度条，和接下来需要的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">from tqdm import tqdm</div><div class="line">    for i in tqdm(range(100)):</div><div class="line">        time.sleep(0.1)</div><div class="line">100%|██████████| 100/100 [00:10&lt;00:00,  9.70it/s]</div></pre></td></tr></table></figure>
<p>先看sequentially download</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def get_flag(base_url, cc):</div><div class="line">    url = &apos;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&apos;.format(base_url, cc=cc.lower())</div><div class="line">    resp = requests.get(url)</div><div class="line">    if resp.status_code != 200:</div><div class="line">        resp.raise_for_status()</div><div class="line">    return resp.content</div><div class="line"></div><div class="line"></div><div class="line">def download_one(cc, base_url, verbose=False):</div><div class="line">    try:</div><div class="line">        image = get_flag(base_url, cc)</div><div class="line">    except requests.exceptions.HTTPError as exc:</div><div class="line">        res = exc.response</div><div class="line">        if res.status_code == 404:</div><div class="line">            status = HTTPStatus.NOT_FOUND</div><div class="line">            msg = &apos;not found&apos;</div><div class="line">        else:</div><div class="line">            raise</div><div class="line"></div><div class="line">    else:</div><div class="line">        save_flags(image, cc.lower() + &apos;.gif&apos;)</div><div class="line">        status = HTTPStatus.OK</div><div class="line">        msg = &apos;OK&apos;</div><div class="line"></div><div class="line">    if verbose:</div><div class="line">        print(cc, msg)</div><div class="line"></div><div class="line">    return Result(status, cc)</div><div class="line"></div><div class="line"></div><div class="line">def download_many(cc_list, base_url, verbose, max_req):</div><div class="line">    counter = Counter()</div><div class="line">    cc_iter = sorted(cc_list)</div><div class="line">    if not verbose:</div><div class="line">        cc_iter = tqdm(cc_iter)</div><div class="line">    for cc in cc_iter:</div><div class="line">        try:</div><div class="line">            res = download_one(cc, base_url, verbose)</div><div class="line">        except requests.exceptions.HTTPError as exc:</div><div class="line">            error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class="line">            error_msg = error_msg.format(res=exc.response)</div><div class="line">        except requests.exceptions.ConnectionError as exc:</div><div class="line">            error_msg = &apos;Connection error&apos;</div><div class="line">        else:</div><div class="line">            error_msg = &apos;&apos;</div><div class="line">            status = res.status</div><div class="line"></div><div class="line">    if error_msg:</div><div class="line">        status = HTTPStatus.error</div><div class="line"></div><div class="line">    counter[status] += 1</div><div class="line">    if verbose and error_msg:</div><div class="line">        print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class="line"></div><div class="line">    return counter</div></pre></td></tr></table></figure>
<p>我们用futures.as_completed来做thread error handling。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">def download_many(cc_list, base_url, verbose, concur_req):</div><div class="line">    counter = collections.Counter()</div><div class="line">    with futures.ThreadPoolExecutor(max_workers=concur_req) as executor:</div><div class="line">        to_do_map = &#123;&#125;</div><div class="line">        for cc in sorted(cc_list):</div><div class="line">            future = executor.submit(</div><div class="line">                download_one,</div><div class="line">                cc, base_url, verbose</div><div class="line">            )</div><div class="line">            to_do_map[future] = cc</div><div class="line"></div><div class="line">        done_iter = futures.as_completed(to_do_map)</div><div class="line"></div><div class="line">        if not verbose:</div><div class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list))</div><div class="line"></div><div class="line">        for future in done_iter:</div><div class="line">            try:</div><div class="line">                res = future.result()</div><div class="line">            except requests.exceptions.HTTPError as exc:</div><div class="line">                error_msg = &apos;HTTP error &#123;res.status_code&#125; - &#123;res.reason&#125;&apos;</div><div class="line">                error_msg = error_msg.format(res=exc.response)</div><div class="line">            except requests.exceptions.ConnectionError as exc:</div><div class="line">                error_msg = &apos;Connection error&apos;</div><div class="line">            else:</div><div class="line">                error_msg = &apos;&apos;</div><div class="line">                status = res.status</div><div class="line"></div><div class="line">            if error_msg:</div><div class="line">                status = HTTPStatus.error</div><div class="line"></div><div class="line">            counter[status] += 1</div><div class="line"></div><div class="line">            if verbose and error_msg:</div><div class="line">                cc = to_do_map[future]</div><div class="line">                print(&apos;*** Error for &#123;&#125;: &#123;&#125;&apos;.format(cc, error_msg))</div><div class="line"></div><div class="line">    return counter</div></pre></td></tr></table></figure>
<h2 id="Blocking-I-O-and-the-GIL"><a href="#Blocking-I-O-and-the-GIL" class="headerlink" title="Blocking I/O and the GIL"></a>Blocking I/O and the GIL</h2><p>尽管上面concurrent版本相比sequential来说运行速度快了近13倍，但严格来说，concurrent也并非是<strong>并行的</strong>。这是因为CPython解释器中的GIL模式导致的。</p>
<p><strong>为什么要有GIL呢？</strong>因为CPython内部是线程不安全的，所以用Global Interpreter Lock来保证运行时只有一个线程在运行python的字节码，同时GIL也让python进程<strong>通常</strong>无法同时使用CPU的多核。</p>
<p>当我们写Python代码时，我们是无法控制GIL的，但是内置的函数或者由C扩展的函数可以在运行多任务时释放GIL，事实上Python里由C语言写的库是可以管理GIL的，启动它自己的系统线程并且控制所有可用的CPU核。不过这大大增加了库的复杂程度，所以大部分作者并不尝试这么做。</p>
<p>然而，所有的标准库在等待从OS返回阻塞的I/O结果时，<strong>都可以释放GIL<br>！</strong>这就意味着I/O限制的Python程序是可以在Python层面利用多线程的。当一个Python线程等待网络回应时，阻塞的I/O函数会释放GIL，这样另一个线程就可以运行了。<em>Tips: time.sleep()函数也会释放GIL.</em> </p>
<p>ProcessPoolExecutor和ThreadPoolExecutor的接口大致相同。需要注意的是后者可以设定规模较大的Worker数量，而前者默认是由os.cpu_count()来设定的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢阅读。</p>
<p>本文代码地址：<a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Concurrency_demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;当你想要高效地处理网络I/O时，你就需要理解「并发」的概念。本章计划列举Fluent Python书
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Coroutine介绍</title>
    <link href="http://miks.top/2017/12/11/Python-Coroutine%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/12/11/Python-Coroutine介绍/</id>
    <published>2017-12-11T06:58:15.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>通过对generator的了解，我们知道caller通过next()方法调用函数里的yield item来生成一个值。</p>
<p>在coroutine里</p>
<ol>
<li>yield item通常放在=的右边，比如datum = yield item，item可以为None.</li>
<li>对于coroutine的调用，caller通过.send(datum)而不是next()，意味着caller把值传递给coroutine。</li>
<li>yield 有挂起的作用，而正是这一点可以使的coroutine可以控制程序流。</li>
<li>增加了.throw()和.close()方法来扩展caller对coroutine的控制。</li>
</ol>
<h2 id="The-behavior-and-states-of-a-generator-operating-as-a-coroutine"><a href="#The-behavior-and-states-of-a-generator-operating-as-a-coroutine" class="headerlink" title="The behavior and states of a generator operating as a coroutine."></a>The behavior and states of a generator operating as a coroutine.</h2><p>我们先看一个基础的coroutine demo。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def simple_generator():</div><div class="line">    print(&apos; coroutine start.&apos;)</div><div class="line">    x = yield</div><div class="line">    print(&apos; coroutine received &apos;, x)</div><div class="line"></div><div class="line">my_coro = simple_generator()</div><div class="line">print(my_coro)</div><div class="line">&lt;generator object simple_generator at 0x1093572b0&gt;</div><div class="line">next(my_coro)</div><div class="line">my_coro.send(42)</div><div class="line"></div><div class="line">注意这里传递值时使用了.send()</div></pre></td></tr></table></figure>
<p>看完代码，思考一下为什么要先next()，为什么要用.send()而不是继续使用next呢？接下来理解一些coroutine的概念，来帮助我们找出问题的答案。</p>
<p>coroutine只有四种状态：</p>
<ol>
<li>‘GEN_CREATED’ 此时等待开始操作。</li>
<li>‘GEN_RUINNING’ 当前正在被解释器执行。</li>
<li>‘GEN_SUSPENDED’ 当前被一条yield语句挂起。</li>
<li>‘GEN_CLOSED’ coroutine已经全部执行完毕。</li>
</ol>
<p>通过状态的定义，上面问题的答案是： 当coroutine处于挂起状态时，通过.send()来给挂起coroutine的那条yield语句传递值，而这个操作在’GEN_CREATED’状态的coroutine里是无法操作的。<br><code>TypeError: can&#39;t send non-None value to a just-started generator</code>, 此时需要先通过next()来唤醒。</p>
<p>接下来我们打印出coroutine的状态来验证答案是否如我们解释的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">from inspect import getgeneratorstate</div><div class="line">def simple_coro2(a):</div><div class="line">    print(&apos;-&gt; started: a =&apos;, a)</div><div class="line">    b = yield a</div><div class="line">    print(&apos;-&gt; received: b =&apos;, b)</div><div class="line">    c = yield a + b</div><div class="line">    print(&apos;-&gt; received: c = &apos;, c)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    my_coro2 = simple_coro2(10)</div><div class="line">    print(getgeneratorstate(my_coro2))</div><div class="line">    next(my_coro2)</div><div class="line">    print(getgeneratorstate(my_coro2))</div><div class="line">    my_coro2.send(20)</div><div class="line">    print(getgeneratorstate(my_coro2))</div><div class="line">    my_coro2.send(30)</div><div class="line">    </div><div class="line">GEN_CREATED</div><div class="line">-&gt; started: a = 10</div><div class="line">GEN_SUSPENDED</div><div class="line">-&gt; received: b = 20</div><div class="line">GEN_SUSPENDED</div><div class="line">-&gt; received: c =  30</div><div class="line">Traceback (most recent call last):</div><div class="line">StopIteration</div><div class="line"></div><div class="line">通过打印，看到代码运行的流程跟我们的答案符合。</div></pre></td></tr></table></figure>
<p>顺便提起一个python赋值的概念，=右边的语句执行是在赋值操作之前的，<br>所以’b = yield a‘中b的只有caller唤醒后才会赋值。</p>
<p>接下来，我们来看一下如何终止一个coroutine.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def averager():</div><div class="line">    total = count = 0</div><div class="line">    average = None</div><div class="line">    while True:  # 注意看这里，这意味着这个循环会一直进行下去。</div><div class="line">        term = yield average</div><div class="line">        total += term</div><div class="line">        count += 1</div><div class="line">        average = total / count</div><div class="line">coro_avg = averager()</div><div class="line">next(coro_avg)</div><div class="line">print(coro_avg.send(10))</div><div class="line">print(coro_avg.send(11))</div><div class="line">print(coro_avg.send(12))</div><div class="line">coro_avg.close()</div><div class="line">10.0</div><div class="line">10.5</div><div class="line">11.0</div><div class="line">调用.close()后，将其终止。</div><div class="line">print(coro_avg.send(14))</div><div class="line">Traceback (most recent call last):</div><div class="line">    print(coro_avg.send(14))</div><div class="line">StopIteration</div><div class="line">调用已经终止的coroutine会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>
<h2 id="Priming-a-coroutine-automaticall-with-a-decorator"><a href="#Priming-a-coroutine-automaticall-with-a-decorator" class="headerlink" title="Priming a coroutine automaticall with a decorator."></a>Priming a coroutine automaticall with a decorator.</h2><p>通过上面的学习，我们知道了，如果我们不启动coroutine，后续的操作是无法进行的。这样的mechanism对于’慵懒’的我们，是拒绝的！！！ok,那就使用decorator来解决这个烦恼吧！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">from inspect import getgeneratorstate</div><div class="line"></div><div class="line">def coroutine(func):</div><div class="line">    @wraps(func)</div><div class="line">    def primer(*args, **kwargs):</div><div class="line">        gen = func(*args, **kwargs)</div><div class="line">        next(gen)</div><div class="line">        return gen</div><div class="line">    return primer</div><div class="line"></div><div class="line">@coroutine</div><div class="line">def simple_generator():</div><div class="line">    print(&apos; coroutine start.&apos;)</div><div class="line">    x = yield</div><div class="line">    print(&apos; coroutine received &apos;, x)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    my_coro = simple_generator()</div><div class="line">    print(getgeneratorstate(my_coro))</div><div class="line">    print(my_coro.send(10))</div><div class="line">coroutine start.</div><div class="line">GEN_SUSPENDED # 已经是挂起状态了!</div><div class="line">coroutine received  10</div></pre></td></tr></table></figure>
<p>我们通过decorator实现了一个小小的trick，不过很遗憾，这个trick与接下来学习的yield from是冲突的！</p>
<h2 id="How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object"><a href="#How-the-caller-can-control-a-coroutine-through-close-and-throw-methods-of-the-generator-object" class="headerlink" title="How the caller can control a coroutine through .close() and .throw() methods of the generator object."></a>How the caller can control a coroutine through .close() and .throw() methods of the generator object.</h2><p>对于每一种机制的学习，缺少了终止／异常处理都是不完整的。当然coroutine也不会例外，如果上面的avg内部发生了异常会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">coro_avg = averager()</div><div class="line">next(coro_avg)</div><div class="line">print(coro_avg.send(10))</div><div class="line">print(coro_avg.send(11))</div><div class="line">print(coro_avg.send(&apos;a&apos;))</div><div class="line">10.0</div><div class="line">10.5</div><div class="line">TypeError: unsupported operand type(s) for +=: &apos;int&apos; and &apos;str&apos;</div><div class="line">coro_avg.send(12)</div><div class="line">StopIteration    ## 后续的调用会抛出Stopiteration的异常。</div></pre></td></tr></table></figure>
<p>当avg出错后，任何尝试重新激活它的操作都会抛出StopIteration。<br>所以，当我们想终止一个coroutine时，我们可以.send()一些bad数据，或者直接.send(Stopiteration)</p>
<p>当然，generator对象有两种方法可以发送异常。</p>
<ol>
<li>generator.throw(exc_type[, exc_value[, traceback]])如果传递的异常被内部处理了，那么仍然允许后续的调用。没有处理的话，异常会传递给caller。</li>
<li>generator.close()当接受到GeneratorExit的异常时，generator不能yield值，并且抛出RuntimeError的异常。但是如果generator抛出了其他的异常，那么会传递给caller。</li>
</ol>
<p>介绍完这个两个概念后，我们用一个例子来更详细的解释一下这些概念。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">from inspect import getgeneratorstate</div><div class="line">class DemoException(Exception):</div><div class="line">    &quot;&quot;&quot;&quot;An exception type for the  demonstration.&quot;&quot;&quot;</div><div class="line"></div><div class="line">def demo_exc_handling():</div><div class="line">    print(&apos;-&gt; coroutine started&apos;)</div><div class="line">    while True:</div><div class="line">        try:</div><div class="line">            x = yield</div><div class="line">        except DemoException:</div><div class="line">            print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class="line">        else:</div><div class="line">            print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class="line"></div><div class="line">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class="line">exc_coro = demo_exc_handling()</div><div class="line">next(exc_coro)</div><div class="line"></div><div class="line">	# Demo 1</div><div class="line">	print(exc_coro.send(11))</div><div class="line">	print(exc_coro.send(22))</div><div class="line">	exc_coro.close()</div><div class="line">	print(getgeneratorstate(exc_coro))</div><div class="line"></div><div class="line">-&gt; coroutine started</div><div class="line">-&gt; coroutine received: 11</div><div class="line">-&gt; coroutine received: 22</div><div class="line">GEN_CLOSED</div><div class="line"></div><div class="line">    # Demo 2</div><div class="line">    exc_coro.send(11)</div><div class="line">    exc_coro.send(22)</div><div class="line">    exc_coro.throw(DemoException)</div><div class="line">    print(getgeneratorstate(exc_coro))</div><div class="line">    </div><div class="line">-&gt; coroutine started</div><div class="line">-&gt; coroutine received: 11</div><div class="line">-&gt; coroutine received: 22</div><div class="line">*** DemoException handled. Continuing...</div><div class="line">GEN_SUSPENDED</div><div class="line"></div><div class="line">    # Demo 3</div><div class="line">    exc_coro.send(11)</div><div class="line">    exc_coro.send(22)</div><div class="line">    exc_coro.throw(ZeroDivisionError)</div><div class="line">    print(getgeneratorstate(exc_coro))</div><div class="line"></div><div class="line">-&gt; coroutine started</div><div class="line">-&gt; coroutine received: 11</div><div class="line">-&gt; coroutine received: 22</div><div class="line">&apos;GEN_CLOSED&apos;</div></pre></td></tr></table></figure>
<p>注意看上面三种异常的打印，以及异常发生后的generator的状态。</p>
<p>如果我们有：不论generator的结束状态如何，环境的清除代码都必须执行的话。那么不妨尝试用try/finally来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def demo_exc_handling():</div><div class="line">    print(&apos;-&gt; coroutine started&apos;)</div><div class="line">    try:</div><div class="line">        while True:</div><div class="line">            try:</div><div class="line">                x = yield</div><div class="line">            except DemoException:</div><div class="line">                print(&apos;*** DemoException handled. Continuing...&apos;)</div><div class="line">            else:</div><div class="line">                print(&apos;-&gt; coroutine received: &#123;!r&#125;&apos;.format(x))</div><div class="line">    finally:</div><div class="line">        print(&apos;Coroutine ending...&apos;)</div><div class="line">    raise RuntimeError(&apos;This line should never run.&apos;)</div><div class="line">    </div><div class="line">    exc_coro.send(11)</div><div class="line">    exc_coro.send(22)</div><div class="line">    exc_coro.throw(DemoException)</div><div class="line">    print(getgeneratorstate(exc_coro))</div><div class="line">    </div><div class="line">-&gt; coroutine started</div><div class="line">-&gt; coroutine received: 11</div><div class="line">-&gt; coroutine received: 22</div><div class="line">*** DemoException handled. Continuing...</div><div class="line">GEN_SUSPENDED</div><div class="line">Coroutine ending...</div></pre></td></tr></table></figure>
<p>OK，虽然try/finally可以解决我们的需求，但是python的yield from可以更好的解决这个问题。</p>
<h2 id="How-coroutines-can-return-value-upon-termination"><a href="#How-coroutines-can-return-value-upon-termination" class="headerlink" title="How coroutines can return value upon termination."></a>How coroutines can return value upon termination.</h2><p>当coroutine终止时，是如何返回结果的呢？我们修改一下上面的averager的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"></div><div class="line">Result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class="line">def averager():</div><div class="line">    total = count = 0</div><div class="line">    average = None</div><div class="line">    while True:</div><div class="line">        term = yield</div><div class="line">        if term is None:</div><div class="line">            break</div><div class="line">        total += term</div><div class="line">        count += 1</div><div class="line">        average = total / count</div><div class="line">    return Result(count, average)</div><div class="line">    </div><div class="line">    coro_avg = averager()</div><div class="line">    next(coro_avg)</div><div class="line">    coro_avg.send(10)</div><div class="line">    coro_avg.send(11)</div><div class="line">    print(coro_avg.send(None))</div><div class="line">    </div><div class="line">Traceback (most recent call last):</div><div class="line">StopIteration: result(count=2, average=10.5)</div><div class="line">注意这里的StopIteration.它将Result也一起打印了出来。</div><div class="line"></div><div class="line">    try:</div><div class="line">        coro_avg.send(None)</div><div class="line">    except StopIteration as exec:</div><div class="line">        print(exec.value)</div><div class="line">result(count=2, average=10.5)</div><div class="line">借助try/except我们可以的到正确的result.</div></pre></td></tr></table></figure>
<p>后续的操作就是yield from和for循环在内部的处理，这样的mechanism使得StopIteration的值是value而不是它本身。</p>
<h2 id="Usage-and-semantics-of-the-new-yield-from-syntax"><a href="#Usage-and-semantics-of-the-new-yield-from-syntax" class="headerlink" title="Usage and semantics of the new yield from syntax."></a>Usage and semantics of the new yield from syntax.</h2><p>前面铺垫了那么久的yield from，现在终于轮到正式介绍它了。</p>
<p><strong>yield from</strong>是python里全新的constrcut，在generator里调用yield from subgen()时，subgen会控制程序流，将值直接返回给caller而不是调用它的generator.这就意味着，此时generator是被阻塞的，只有当subgen结束时，才会恢复阻塞。</p>
<p><strong>yield from x</strong>这个表达式，是x先调用它的iter(x)函数去得到iterator。这意味着x可以是任何iterable对象。但是只通过这个角度去理解，是不足以说明yield from的神奇之处的。它最主要的功能是“委托给一个subgenerator”，它在最外层的caller和最内部的subgenerator之间开启了一个通道，所以值可以直接在通道之间进行传递，同理异常代码的处理也可以直接进行，而无需大量的try/except来完成。</p>
<p><strong>delegating generator</strong>是指函数里包含了yield from <iterable>表达式。</iterable></p>
<p><strong>subgenerator</strong>指yield from <iterable>表达式里<iterable>得到的generator。</iterable></iterable></p>
<p><strong>caller</strong>指调用delagating generator的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"></div><div class="line">result = namedtuple(&apos;result&apos;, &apos;count average&apos;)</div><div class="line"></div><div class="line"></div><div class="line"># subgenerator</div><div class="line">def averager():</div><div class="line">    total = count = 0</div><div class="line">    average = None</div><div class="line">    while True:</div><div class="line">        term = yield</div><div class="line">        if term is None:</div><div class="line">            break</div><div class="line">        total += term</div><div class="line">        count += 1</div><div class="line">        average = total / count</div><div class="line">    return result(count, average)</div><div class="line"></div><div class="line"></div><div class="line"># delegating generator</div><div class="line">def grouper(results, key):</div><div class="line">    while True:</div><div class="line">        results[key] = yield from averager()</div><div class="line"></div><div class="line"># caller</div><div class="line">def main(data):</div><div class="line">    results = &#123;&#125;</div><div class="line">    for key, values in data.items():</div><div class="line">        group = grouper(results, key)</div><div class="line">        next(group)</div><div class="line">        for value in values:</div><div class="line">            group.send(value)</div><div class="line">        group.send(None)  ## important</div><div class="line"></div><div class="line">    report(results)</div><div class="line"></div><div class="line"></div><div class="line">def report(results):</div><div class="line">    for key, values in sorted(results.items()):</div><div class="line">        group, unit = key.split(&apos;;&apos;)</div><div class="line">        print(&apos;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&apos;.format(</div><div class="line">            values.count, group, values.average, unit</div><div class="line">        ))</div><div class="line">        </div><div class="line">data = &#123;</div><div class="line">    &apos;girls;kg&apos;:</div><div class="line">        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],</div><div class="line">    &apos;girls;m&apos;:</div><div class="line">        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],</div><div class="line">    &apos;boys;kg&apos;:</div><div class="line">        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],</div><div class="line">    &apos;boys;m&apos;:</div><div class="line">        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],</div><div class="line">&#125;</div><div class="line">main(data)</div><div class="line"></div><div class="line"> 9 boys  averaging 40.42</div><div class="line"> 9 boys  averaging 1.39</div><div class="line">10 girls averaging 42.04</div><div class="line">10 girls averaging 1.43</div></pre></td></tr></table></figure>
<p>理解一下上面的代码：</p>
<ul>
<li>每一次迭代，调用grouper()创建的实例就是delegating generator.</li>
<li>调用next(group)启动delegating generator，之后进入循环中，在yield from处挂起。</li>
<li>group.send(value)是直接调用subgenerator averager的，值是直接传递过去的，因此此时的results[key]还没有被赋值。</li>
<li>当赋值循环结束后，如果没有group.send(None),subgenerator永远不会结束，delegating generator就不再会被激活，那么results[key]的赋值也不会成功。</li>
<li>当执行一次内循环后，重新创建一个group实例，之前的实例也被垃圾回收机制给回收了，就算内部的subgenerator没有执行完，也同样会被回收。</li>
</ul>
<p>上面代码的<strong>核心</strong>概念是：如果subgenerator没有结束，那么delegating generator就会永远在yield from处挂起。</p>
<p>如果还没有完全理解yield from,我们再从<strong>PEP 380</strong>中给出的介绍来理解：</p>
<ol>
<li>任何subgenerator中yield的值都会直接传递给caller.</li>
<li>任何通过delegating generator的send()方法发送的值都会直接传递给subgenerator。如果传递的值是None, subgenerator的<strong>next</strong>()方法会被调用，如果抛出了StopIteration，那么delegating generator就会恢复。除此之外，抛出的其他类型异常都会被传递给delegating generator.</li>
<li>return expr在generator里会抛出StopIteration，并且退出这个generator.</li>
<li>yield from表达式返回的值，是subgeneration终止时抛出的StopIteration中的第一个参数。</li>
<li>通过subgenerator的throw()方法传递异常，如果异常是StopIteration则delegating generator会恢复，否则其他异常会传递给delegating generator.</li>
<li>如果GeneratorExit异常被扔进了delegating generator里，或者是delegating generator的close()方法被调用。那么当subgenerator也存在close()方法时也会被调用，调用产生的异常会传递给delegating generator.否则GeneratorExit会在delegating generator中被抛出。</li>
</ol>
<p>为了更好的理解这些抽象的概念，我们用两个伪代码来看一下yield from内部的处理机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">RESULT = yield from EXPR</div><div class="line"></div><div class="line">_i = iter(EXPR)</div><div class="line">try:</div><div class="line">    _y = next(_i)</div><div class="line">except StopIteration as _e:</div><div class="line">    _r = _e.value</div><div class="line">else:</div><div class="line">    while 1:</div><div class="line">        _s = yield _y</div><div class="line">        try:</div><div class="line">            _y = _i.send(_s)</div><div class="line">        except StopIteration as _e:</div><div class="line">            _r = _e.value</div><div class="line">            break</div><div class="line"></div><div class="line">RESULT = _r</div><div class="line"></div><div class="line">_i是subgenerator.</div><div class="line">_y是subgenerator里yield出来的值.</div><div class="line">_r是最终结果.</div><div class="line">_s是caller传送给delegating generator的值，跳转给subgenerator.</div><div class="line">_e是一个异常.</div><div class="line"></div><div class="line">如果你已经理解了上面的代码，那么我们再来看yield from对于异常的处理。</div><div class="line">import sys</div><div class="line"></div><div class="line">RESULT = yield from EXPR</div><div class="line">_i = iter(EXPR)</div><div class="line">try:</div><div class="line">    _y = next(_i)</div><div class="line">except StopIteration as _e:</div><div class="line">    _r = _e.value</div><div class="line">else:</div><div class="line">    while 1:</div><div class="line">        try:</div><div class="line">            _s = yield _y</div><div class="line">        except GeneratorExit as _e:</div><div class="line">            try:</div><div class="line">                _m = _i.close</div><div class="line">            except AttributeError:</div><div class="line">                pass</div><div class="line">            else:</div><div class="line">                _m()</div><div class="line">            raise _e</div><div class="line">        except BaseException as _e:</div><div class="line">            _x = sys.exc_info()</div><div class="line">            try:</div><div class="line">                _m = _i.throw</div><div class="line">            except AttributeError:</div><div class="line">                raise _e</div><div class="line">            else:</div><div class="line">                try:</div><div class="line">                    _y = _m(*_x)</div><div class="line">                except Exception as _e:</div><div class="line">                    _r = _e.value</div><div class="line">                    break</div><div class="line">    else:</div><div class="line">        try:</div><div class="line">            if _s is None:</div><div class="line">                _y = next(_i)</div><div class="line">            else:</div><div class="line">                _y = _i.send(_s)</div><div class="line">        except StopIteration as _e:</div><div class="line">            _r = _e.value</div><div class="line">            break</div><div class="line">RESULT = _r</div></pre></td></tr></table></figure>
<h2 id="A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation"><a href="#A-use-case-coroutines-for-managing-concurrent-activities-in-a-simulation" class="headerlink" title="A use case: coroutines for managing concurrent activities in a simulation."></a>A use case: coroutines for managing concurrent activities in a simulation.</h2><p>最后我们通过一个写并发概念的简单demo来梳理一下概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"></div><div class="line">Event = namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</div><div class="line"></div><div class="line"></div><div class="line">def taxi_process(ident, trips, start_time=0):</div><div class="line">    &quot;&quot;&quot;Yield to simular issuing event at each state change.&quot;&quot;&quot;</div><div class="line">    time = yield Event(start_time, ident, &apos;leave garge.&apos;)</div><div class="line">    for i in range(trips):</div><div class="line">        time = yield Event(time, ident, &apos;pick up passenger.&apos;)</div><div class="line">        time = yield Event(time, ident, &apos;drop off passenger.&apos;)</div><div class="line">    yield Event(time, ident, &apos;going home.&apos;)</div><div class="line">    taxi = taxi_process(ident=1, trips=2)</div><div class="line">    print(next(taxi))</div><div class="line">    print(taxi.send(7))</div><div class="line">    print(taxi.send(15))</div><div class="line">    print(taxi.send(16))</div><div class="line">    print(taxi.send(23))</div><div class="line">    print(taxi.send(30))</div><div class="line">Event(time=0, proc=1, action=&apos;leave garge.&apos;)</div><div class="line">Event(time=7, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">Event(time=15, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">Event(time=16, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">Event(time=23, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">Event(time=30, proc=1, action=&apos;going home.&apos;)</div><div class="line">这是一辆出租车可以执行的事件循环，接下来我们看看多辆出租车的执行。</div><div class="line"></div><div class="line">import queue</div><div class="line"></div><div class="line"></div><div class="line">class Simulator(object):</div><div class="line">    def __init__(self, procs_map):</div><div class="line">        self.events = queue.PriorityQueue()</div><div class="line">        self.procs = dict(procs_map)</div><div class="line"></div><div class="line">    def run(self, end_time):</div><div class="line">        &quot;&quot;&quot;Schedule and display events utill time is up.&quot;&quot;&quot;</div><div class="line">        for _, proc in sorted(self.procs.items()):</div><div class="line">            first_event = next(proc)</div><div class="line">            self.events.put(first_event)</div><div class="line"></div><div class="line">        sim_time = 0</div><div class="line">        while sim_time &lt; end_time:</div><div class="line">            if self.events.empty():</div><div class="line">                print(&apos;*** end of events ***&apos;)</div><div class="line">                break</div><div class="line">            current_event = self.events.get()</div><div class="line">            sim_time, proc_id, previous_action = current_event</div><div class="line">            print(&apos;taxi:&apos;, proc_id, proc_id * &apos;  &apos;, current_event)</div><div class="line">            active_proc = self.procs[proc_id]</div><div class="line">            next_time = sim_time + compute_duration(previous_action)</div><div class="line">            try:</div><div class="line">                next_event = active_proc.send(next_time)</div><div class="line">            except StopIteration:</div><div class="line">                del self.procs[proc_id]</div><div class="line">            else:</div><div class="line">                self.events.put(next_event)</div><div class="line">        else:</div><div class="line">            msg = &apos;*** end of simulation time: &#123;&#125; events pending ***&apos;</div><div class="line">            print(msg.format(self.events.qsize()))</div><div class="line"></div><div class="line"></div><div class="line">def compute_duration(previous_action):</div><div class="line">    duration = 1</div><div class="line">    if previous_action == &apos;pick up passenger.&apos;:</div><div class="line">        duration = 3</div><div class="line">    elif previous_action == &apos;drop off passenger.&apos;:</div><div class="line">        duration = 5</div><div class="line">    return duration</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    DEPARTURE_INTERVAL = 2</div><div class="line">    num_taxis = 3</div><div class="line">    taxis = &#123;</div><div class="line">        i: taxi_process(i, (i + 2) * 2, i * DEPARTURE_INTERVAL)</div><div class="line">        for i in range(num_taxis)</div><div class="line">    &#125;</div><div class="line">    sim = Simulator(taxis)</div><div class="line">    print(sim.run(100))</div><div class="line">taxi: 0  Event(time=0, proc=0, action=&apos;leave garge.&apos;)</div><div class="line">taxi: 0  Event(time=1, proc=0, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=2, proc=1, action=&apos;leave garge.&apos;)</div><div class="line">taxi: 1    Event(time=3, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 0  Event(time=4, proc=0, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=4, proc=2, action=&apos;leave garge.&apos;)</div><div class="line">taxi: 2      Event(time=5, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=6, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=8, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 0  Event(time=9, proc=0, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=11, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 0  Event(time=12, proc=0, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=13, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=14, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=16, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 0  Event(time=17, proc=0, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=19, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 0  Event(time=20, proc=0, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=21, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=22, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=24, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 0  Event(time=25, proc=0, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=27, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 0  Event(time=28, proc=0, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=29, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=30, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=32, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 0  Event(time=33, proc=0, action=&apos;going home.&apos;)</div><div class="line">taxi: 1    Event(time=35, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 2      Event(time=37, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=38, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=40, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 1    Event(time=43, proc=1, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 2      Event(time=45, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 1    Event(time=46, proc=1, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=48, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 1    Event(time=51, proc=1, action=&apos;going home.&apos;)</div><div class="line">taxi: 2      Event(time=53, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 2      Event(time=56, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=61, proc=2, action=&apos;pick up passenger.&apos;)</div><div class="line">taxi: 2      Event(time=64, proc=2, action=&apos;drop off passenger.&apos;)</div><div class="line">taxi: 2      Event(time=69, proc=2, action=&apos;going home.&apos;)</div><div class="line">*** end of events ***</div></pre></td></tr></table></figure>
<p>请记住这个例子，之后在介绍<strong>asyncio</strong>时会进行详细的讲解。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>对于coroutine的介绍就到这里了，希望你已经理解了<strong>yield from</strong>的概念以及内部机制了。如果文章中有让你不理解或者介绍不清楚的地方，请务必让我知道！</p>
<p>感谢你的阅读，希望能收到你的feedback :)</p>
<p>本文代码地址: <a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Coroutines_demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;headerlink&quot; title=&quot;Concept&quot;&gt;&lt;/a&gt;Concept&lt;/h2&gt;&lt;p&gt;通过对generator的了解，我们知道caller通过next()方法调用函数里的yield it
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python generator 介绍</title>
    <link href="http://miks.top/2017/12/02/Python-generator-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/12/02/Python-generator-介绍/</id>
    <published>2017-12-02T09:12:38.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和iterator的概念已经有了认识。如果没有的话建议先阅读本人的另一篇文章：<a href="http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">http://www.ganbinwen.com/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/</a></p>
<h2 id="How-a-generator-function-works-in-detail-with-line-by-line-descriptions"><a href="#How-a-generator-function-works-in-detail-with-line-by-line-descriptions" class="headerlink" title="How a generator function works in detail, with line by line descriptions."></a>How a generator function works in detail, with line by line descriptions.</h2><p>介绍相关概念前，我们先看一个Pythonic的Iterator实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Sentence(object):</div><div class="line">    def __init__(self, text):</div><div class="line">        self.text = text</div><div class="line">        self.words = RE_WORD.findall(self.text)</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        for word in self.words:</div><div class="line">            yield word</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class="line">    print(s)</div><div class="line">    for word in s:</div><div class="line">        print(word)</div><div class="line">    print(list(s))</div><div class="line">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class="line">The</div><div class="line">time</div><div class="line">has</div><div class="line">come</div><div class="line">the</div><div class="line">Walrus</div><div class="line">said</div><div class="line">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class="line"></div><div class="line">对比之前实现的例子，可以看到已经简洁很多了！！ </div><div class="line">tip: 最简洁的是 return iter(self.words)</div></pre></td></tr></table></figure>
<p>在Python中，如果函数里有yield关键字，那么代表这个函数就是一个生成器函数，生成器函数会返回一个generator。也就是说生成器函数是一个生成器工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">def gen_123():</div><div class="line">    yield 1</div><div class="line">    yield 2</div><div class="line">    yield 3</div><div class="line"></div><div class="line">print(gen_123)</div><div class="line">print(gen_123())</div><div class="line">for i in gen_123():</div><div class="line">    print(i)</div><div class="line">g = gen_123()</div><div class="line">print(next(g))</div><div class="line">print(next(g))</div><div class="line">print(next(g))</div><div class="line">print(next(g))</div><div class="line"></div><div class="line">&lt;function gen_123 at 0x10a6661e0&gt;</div><div class="line">&lt;generator object gen_123 at 0x10a5d8258&gt;</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Users/wukong/Python/Git/CorePython/Fluent_Python_demo/Iterators_and_generators_demo/generator_demo.py&quot;, line 45, in &lt;module&gt;</div><div class="line">    print(next(g))</div><div class="line">StopIteration</div><div class="line">当函数调用结束后，会抛出StopIteration.这是实现了Iterabtor的协议。不过for操作会捕获这个异常。</div></pre></td></tr></table></figure>
<p>调用生成器函数会返回一个生成器，生成器通过关键字yield来产生值。</p>
<p>明白了生成器的概念后，我们再来了解一个跟生成器有关的Trick—lazy Implementation.A lazy implementation延迟了值的生成，直到使用时才会产生。这样的操作可以节约内存和避免不需要的生成。</p>
<p>我们用re模块自带的re.finditer来改造上面的例子，使其具有lazy属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import reprlib</div><div class="line"></div><div class="line">RE_WORD = re.compile(r&apos;\w+&apos;)</div><div class="line"></div><div class="line"></div><div class="line">class Sentence(object):</div><div class="line">    def __init__(self, text):</div><div class="line">        self.text = text</div><div class="line">        self.words = RE_WORD.findall(self.text)</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        for match in RE_WORD.finditer(self.text):</div><div class="line">            yield match.group()</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div></pre></td></tr></table></figure>
<h2 id="How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression"><a href="#How-the-classic-Iterator-can-be-repalced-by-a-generator-function-or-generator-expression" class="headerlink" title="How the classic Iterator can be repalced by a generator function or generator expression."></a>How the classic Iterator can be repalced by a generator function or generator expression.</h2><p>尽管用generator function以及比iterator简洁很多了，但是generator expression可以更简洁！</p>
<p>generator expression会产生一个惰性list，只有当需要生成值时才会生成。同时generator expression也是generators的工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">def gen_AB():</div><div class="line">    print(&apos;start&apos;)</div><div class="line">    yield &apos;A&apos;</div><div class="line">    print(&apos;continue&apos;)</div><div class="line">    yield &apos;B&apos;</div><div class="line">    print(&apos;end.&apos;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    res1 = [x*3 for x in gen_AB()]</div><div class="line">    for i in res1:</div><div class="line">        print(i)</div><div class="line">    res2 = (x*3 for x in gen_AB())</div><div class="line">    for i in res2:</div><div class="line">        print(i)</div><div class="line">start</div><div class="line">continue</div><div class="line">end.</div><div class="line">AAA</div><div class="line">BBB</div><div class="line"></div><div class="line"></div><div class="line">start</div><div class="line">AAA</div><div class="line">continue</div><div class="line">BBB</div><div class="line">end.</div><div class="line"></div><div class="line">通过打印结果，可以验证generator expression是lazy的。</div></pre></td></tr></table></figure>
<p>generator expression是python的语法糖，可以被generator function替换，但是有时使用它会让代码更简洁，清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import reprlib</div><div class="line"></div><div class="line">RE_WORD = re.compile(r&apos;\w+&apos;)</div><div class="line"></div><div class="line"></div><div class="line">class Sentence(object):</div><div class="line">    def __init__(self, text):</div><div class="line">        self.text = text</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        return (match.group() for match in RE_WORD.finditer(self.text))</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class="line">尽管没有使用yield，但是generator expression是generator工厂，所以返回了一个generator对象。</div></pre></td></tr></table></figure>
<p>尽管generator expression有诸多优点，但是generator function更加的灵活，可以表达逻辑复杂的代码。所以在选择上，通常当逻辑代码超过两行时，推荐使用generator function.</p>
<p>最后，如果你不太明白lazy实现的优点，可以用一个案例来帮助你理解下。假设我们要实现对没有边界的集合的迭代，那么意味着不论内存多大，放入这个集合后都会导致OOM。如果避免OOM，并且实现这个目标呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class ArithmeticProgression(object):</div><div class="line">    def __init__(self, begin, step, end=None):</div><div class="line">        self.begin = begin</div><div class="line">        self.step = step</div><div class="line">        self.end = end</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        result = type(self.begin + self.step)(self.begin)</div><div class="line">        forever = self.end is None</div><div class="line">        index = 0</div><div class="line">        while forever or result &lt; self.end:</div><div class="line">            yield result</div><div class="line">            index += 1</div><div class="line">            result = self.begin + self.step * index</div><div class="line">ap1 = ArithmeticProgression(1, 0.5, 2)</div><div class="line">print(list(ap1))</div><div class="line">ap2 = ArithmeticProgression(1, 0.5)</div><div class="line">for i in ap2:</div><div class="line">    print(i)</div><div class="line"></div><div class="line">ap2是没有边界的，除非强制终止，否则for循环会一直打印。但是调用这样一个对象，并不会触发OOM。</div></pre></td></tr></table></figure>
<h2 id="Using-the-new-yield-from-statement-to-combine-generators"><a href="#Using-the-new-yield-from-statement-to-combine-generators" class="headerlink" title="Using the new yield from statement to combine generators"></a>Using the new yield from statement to combine generators</h2><p>当我们的generator需要从另一个generator得到值时，要如何操作呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def chain(*iterables):</div><div class="line">    for it in iterables:</div><div class="line">        for i in it:</div><div class="line">            yield i</div><div class="line">s = &apos;ABC&apos;</div><div class="line">t = tuple(range(3))</div><div class="line">print(list(chain(s, t)))</div><div class="line"></div><div class="line">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 0, 1, 2]</div><div class="line"></div><div class="line">要注意unpack也是generator哦，虽然实现了这样的功能。但是Python的语法糖可以帮你省去内置的for循环。</div><div class="line">def chain(*iterables):</div><div class="line">    for it in iterables:</div><div class="line">        yield from it</div></pre></td></tr></table></figure>
<p>yield from 在内部生成器和外部生成器之间创建了一个通道，这个通道在coroutines中是非常重要的。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>最后，感谢阅读。generator的Trick就介绍到这里了，虽然它同python中的coroutines有一些共同点，但是它们也是不同的概念哦，深入的探索可以去了解coroutines的原理。</p>
<p>本章相关代码：<br><a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;Generator是Python里相当有趣的trick.不过在阅读本文前，希望你对iterable和
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Iterators and Iterables介绍</title>
    <link href="http://miks.top/2017/12/02/Python-Iterators-and-Iterables%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/12/02/Python-Iterators-and-Iterables介绍/</id>
    <published>2017-12-02T07:02:24.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需要对数据集进行<strong>惰性</strong>读取，意味着每次操作只读取一条数据—–而这就是Iterator模式。</p>
<h2 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h2><p><code>iterable</code>  任何对象通过内置iter()方法都可以得到一个iterator。对象如果实现了<strong> iter</strong>方法并且返回一个iterator，那么称对象是iterable.</p>
<p>在Python里所有的集合都是可迭代的，例如：</p>
<ul>
<li>for 循环</li>
<li>集合类型和其扩展</li>
<li>list, dict, set类型的解析式</li>
<li>tuple类型的unpack</li>
<li>对函数的*args形参进行unpack</li>
</ul>
<p>诸如此类的操作，都是iterable.</p>
<p>通过例子我们再来探索一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">RE_WORD = re.compile(r&apos;\w+&apos;)</div><div class="line">class Sentence(object):</div><div class="line">    def __init__(self, text):</div><div class="line">        self.text = text</div><div class="line">        self.words = RE_WORD.findall(self.text)</div><div class="line"></div><div class="line">    def __len__(self):</div><div class="line">        return len(self.words)</div><div class="line"></div><div class="line">    def __getitem__(self, index):</div><div class="line">        return self.words[index]</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class="line">    print(s)</div><div class="line">    for word in s:</div><div class="line">        print(word)</div><div class="line">    print(list(s))</div><div class="line">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class="line">The</div><div class="line">time</div><div class="line">has</div><div class="line">come</div><div class="line">the</div><div class="line">Walrus</div><div class="line">said</div><div class="line">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div><div class="line"></div><div class="line">通过迭代，for对其进行了打印操作，并尝试让Sentence对象成为list对象。</div></pre></td></tr></table></figure>
<h2 id="How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects"><a href="#How-the-iter-…-built-in-function-is-used-to-internally-to-hanlde-iterable-objects" class="headerlink" title="How the iter(…) built-in function is used to internally to hanlde iterable objects."></a>How the iter(…) built-in function is used to internally to hanlde iterable objects.</h2><p>每一个Python编程人员，都知道序列对象是可以迭代的，如list, dict。可为什么序列对象都支持迭代呢？<br>这是因为当我们进行迭代时，解释器会自动调用对象的iter()方法。</p>
<p>iter()方法的使用规则：</p>
<ol>
<li>检查对象是否实现了<strong> iter</strong>方法，如果有，则调用得到一个iterator.</li>
<li>如果<strong> iter</strong> 方法没有被实现，但是对象实现了<strong> getitem</strong>方法，那么Python会创建一个Iterator并按照顺序从0开始索引.</li>
<li>如果没有实现以上方法，或者操作失败。Python会抛出<strong>TypeError</strong>， 如：TypeError: ‘Sentence’ object is not iterable.</li>
</ol>
<p>而正是Python的序列对象都实现了 <strong> getitem</strong>方法，所以它们都是可迭代的。（通常标准的sequences也会实现 <strong> iter</strong>方法）</p>
<h2 id="How-to-implement-the-classic-Iterator-pattern-in-Python"><a href="#How-to-implement-the-classic-Iterator-pattern-in-Python" class="headerlink" title="How to implement the classic Iterator pattern in Python."></a>How to implement the classic Iterator pattern in Python.</h2><p>iterator都是由iterable对象得到的， 举一个日常代码中经常出现的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">s = &apos;ABC&apos;</div><div class="line">for char in s:</div><div class="line">    print(char)</div><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line">这应该是最常见的iterator实例了，iterator背后的使用逻辑如下。</div><div class="line"></div><div class="line">s = &apos;ABC&apos;</div><div class="line">it = iter(s)</div><div class="line">while True:</div><div class="line">    try:</div><div class="line">        print(next(it))</div><div class="line">    except StopIteration:</div><div class="line">        del it</div><div class="line">        break</div></pre></td></tr></table></figure>
<p><strong>StopIteration</strong> 意味着iterator失效了。这个异常会被for循环或者其他迭代操作捕获到，先对iterator进行释放后，之后退出循环。</p>
<p>标准的iterator接口有两个方法：</p>
<ol>
<li><strong> next</strong>  返回下一个可使用的item， 当没有可用的items时会抛出Stopiteration的异常。</li>
<li><strong> iter</strong>  返回自身；这样可用于for循环操作。</li>
</ol>
<p>当需要判断iterator是否有其余的items时，只能通过next()来进行。同样，当一个iterator失效后，不可能进行重设操作。如果你需要重新操作一次iterator的话，那么只能通过iterable对象的iter()方法来得到一个新的iterator。要记住，即使iterator实现了<strong> iter</strong> 方法，调用它也只能获得它本身，所以不可能进行重设操作。</p>
<p><code>iterator</code> 是指实现了<strong> next</strong> 和<strong> iter</strong>方法的对象, <strong> next</strong> 方法会在对象没有剩余items时抛出Stopiteration的异常来终止操作。由于Python的iterator内部也实现了<strong> iter</strong>方法，所以iterator同时也是iterable。</p>
<p>接下来通过一个标准的iterator实现来理解下iterable和iterator的概念及不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import reprlib</div><div class="line"></div><div class="line">RE_WORD = re.compile(r&apos;\w+&apos;)</div><div class="line"></div><div class="line">class Sentence(object):</div><div class="line">    def __init__(self, text):</div><div class="line">        self.text = text</div><div class="line">        self.words = RE_WORD.findall(self.text)</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)  # reprlib.repr limits the generated string to 30 characters.</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        return SentenceIterator(self.words)</div><div class="line"></div><div class="line"></div><div class="line">class SentenceIterator(object):</div><div class="line">    def __init__(self, words):</div><div class="line">        self.words = words</div><div class="line">        self.index = 0</div><div class="line"></div><div class="line">    def __iter__(self):</div><div class="line">        return self</div><div class="line"></div><div class="line">    def __next__(self):</div><div class="line">        try:</div><div class="line">            word = self.words[self.index]</div><div class="line">        except IndexError:</div><div class="line">            raise StopIteration()</div><div class="line">        self.index += 1</div><div class="line">        return word</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    s = Sentence(&apos;&quot;The time has come,&quot; the Walrus said,&apos;)</div><div class="line">    print(s)</div><div class="line">    for word in s:</div><div class="line">        print(word)</div><div class="line">    print(list(s))</div><div class="line">Sentence(&apos;&quot;The time ha... Walrus said,&apos;)</div><div class="line">The</div><div class="line">time</div><div class="line">has</div><div class="line">come</div><div class="line">the</div><div class="line">Walrus</div><div class="line">said</div><div class="line">[&apos;The&apos;, &apos;time&apos;, &apos;has&apos;, &apos;come&apos;, &apos;the&apos;, &apos;Walrus&apos;, &apos;said&apos;]</div></pre></td></tr></table></figure>
<p>通过这个例子，可以看到： iterable实现了 <strong> iter</strong>方法，每次调用会返回一个iterator实例。iterator对象实现了 <strong> next</strong> 方法，每次返回一个item，并在没有剩余items时抛出StopIteration(), <strong> iter</strong> 方法每次返回自身。<br>因此，我们可以说<strong>iterator是iterable，但是iterable不是iterator.</strong></p>
<p>最后我们作出一个猜想： 我们可不可以在Sentence类里实现<strong> next</strong>方法呢，使Sentence既是iterator也是iterable，岂不美哉？</p>
<p>答案很明确，这是一个非常糟糕的想法。但是如果你对答案产生困惑也没关系，我们再一起来了解一下，为什么不要在Python里尝试这样做。</p>
<p><strong>Iterator Pattern</strong>里有一点：to support multiple traversals of aggregate objects.<br>如果要满足这点，意味着iterable必须产生多个独立的新iterator对象。每一个iterator都在内部保持自己的状态，不进行互相干扰。所以iterable的本质就是要对其进行iter()操作时可以获得独立的，新的iterator。而如果实现了<strong> next</strong>方法，则不能产生新的iterator，会破坏这一设计原则，所以这是很糟糕的想法。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>感谢阅读，希望你读到这里时，对于iterable和iterator的概念，能有一个新的认识。</p>
<p>本文代码链接:<a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Iterators_and_generators_demo</a></p>
<p>如果文章中有错误，或者你还有不理解的地方，欢迎在下方的评论／邮件中提交你的想法／困惑。</p>
<p>值得一说的是，尽管我们对iterable和iterator的介绍已经结束了，但是在Python中还有一个非常重要的概念<strong>generator</strong>也与其有关。因为篇幅原因，我将其拆分为另一篇文章<a href="a">a</a>，打铁要趁热！！！快来学习一下！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;headerlink&quot; title=&quot;Concept&quot;&gt;&lt;/a&gt;Concept&lt;/h2&gt;&lt;p&gt;Iteration是对数据进行函数式的操作。假设当你需要从内存无法装下的数据集中读取数据时，你可能需
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Function Decorators and Closures介绍</title>
    <link href="http://miks.top/2017/11/29/Python-Function-Decorators-and-Closures%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/11/29/Python-Function-Decorators-and-Closures介绍/</id>
    <published>2017-11-29T08:17:13.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tricky mechanism. <strong>注意</strong>本文只讲解了函数装饰器，如果你想了解类装饰器，请不要继续阅读。</p>
<h2 id="How-Python-evaluates-decorator-syntax"><a href="#How-Python-evaluates-decorator-syntax" class="headerlink" title="How Python evaluates decorator syntax?"></a>How Python evaluates decorator syntax?</h2><p>Python对装饰器的使用了语法糖，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@decorate</div><div class="line">def target():</div><div class="line">    print(&apos;Running target()&apos;)</div><div class="line"></div><div class="line">def target():</div><div class="line">    print(&apos;Running target()&apos;)</div><div class="line">target = decorate(target)</div></pre></td></tr></table></figure>
<p>二者的结果是相等的，但被装饰器注册后可以不必再引用原始的target对象，所以返回对象是由decorate(target)来决定的。</p>
<h2 id="When-Python-executes-decorators"><a href="#When-Python-executes-decorators" class="headerlink" title="When Python executes decorators?"></a>When Python executes decorators?</h2><p>首先明确import time和run time这两个概念，前者是模块被导入的时刻，后者是指模块内程序运行的时刻。<br>装饰器是在import time被执行的，我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">registry = []</div><div class="line">def register(func):</div><div class="line">    print(&apos;running register(%s)&apos; % func)</div><div class="line">    registry.append(func)</div><div class="line">    return func</div><div class="line"></div><div class="line">@register</div><div class="line">def f1():</div><div class="line">    print(&apos;Running f1()&apos;)</div><div class="line"></div><div class="line">@register</div><div class="line">def f2():</div><div class="line">    print(&apos;Running f2()&apos;)</div><div class="line"></div><div class="line">def main():</div><div class="line">    print(&apos;running main&apos;)</div><div class="line">    print(&apos;registry -&gt;&apos;, registry)</div><div class="line">    f1()</div><div class="line">    f2()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div><div class="line">------------------------------------------------------------------------    </div><div class="line">running register(&lt;function f1 at 0x100c70158&gt;)</div><div class="line">running register(&lt;function f2 at 0x100c701e0&gt;)</div><div class="line">running main</div><div class="line">registry -&gt; [&lt;function f1 at 0x100c70158&gt;, &lt;function f2 at 0x100c701e0&gt;]</div><div class="line">Running f1()</div><div class="line">Running f2()</div></pre></td></tr></table></figure>
<p>通过打印我们可以看到，在main()调用之前，装饰器已经完成了注册。</p>
<h2 id="How-Python-decides-whether-a-variable-is-local"><a href="#How-Python-decides-whether-a-variable-is-local" class="headerlink" title="How Python decides whether a variable is local?"></a>How Python decides whether a variable is local?</h2><p><strong>Variable scope rules</strong>这个概念非常重要，介绍这个概念前，我们先看两个非常有代表性的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">def f1(a):</div><div class="line">    print(a)</div><div class="line">    print(b)</div><div class="line"></div><div class="line">f1(3)</div><div class="line">3</div><div class="line">NameError: name &apos;b&apos; is not defined</div><div class="line">b = 6</div><div class="line">f1(3)</div><div class="line">3</div><div class="line">6</div><div class="line"></div><div class="line">接下来的例子可能会让你很困惑，不过没关系，我会在后面解释清楚。</div><div class="line">def f2(a):</div><div class="line">    print(a)</div><div class="line">    print(b)</div><div class="line">    b = 9</div><div class="line">f2(3)</div><div class="line">3</div><div class="line">UnboundLocalError: local variable &apos;b&apos; referenced before assignment</div><div class="line">希望你可以先思考一下为什么没有打印出6。</div><div class="line">事实上Python在编译函数体时，因为有赋值操作，所以将b定义为local变量，而不是global变量，</div><div class="line">print()时发现b还未被赋值，所以抛出了错误。</div><div class="line">我们再通过字节码来确认一下是不是这样。</div><div class="line"></div><div class="line">print(dis.dis(f1))</div><div class="line">  5           0 LOAD_GLOBAL              0 (print)</div><div class="line">              3 LOAD_FAST                0 (a)</div><div class="line">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class="line">              9 POP_TOP</div><div class="line"></div><div class="line">  6          10 LOAD_GLOBAL              0 (print)</div><div class="line">             13 LOAD_GLOBAL              1 (b)</div><div class="line">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class="line">             19 POP_TOP</div><div class="line">             20 LOAD_CONST               0 (None)</div><div class="line">             23 RETURN_VALUE</div><div class="line"></div><div class="line">print(dis.dis(f2))</div><div class="line">  9           0 LOAD_GLOBAL              0 (print)</div><div class="line">              3 LOAD_FAST                0 (a)</div><div class="line">              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class="line">              9 POP_TOP</div><div class="line"></div><div class="line"> 10          10 LOAD_GLOBAL              0 (print)</div><div class="line">             13 LOAD_FAST                1 (b)</div><div class="line">             16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)</div><div class="line">             19 POP_TOP</div><div class="line"></div><div class="line"> 11          20 LOAD_CONST               1 (9)</div><div class="line">             23 STORE_FAST               1 (b)</div><div class="line">             26 LOAD_CONST               0 (None)</div><div class="line">对比一下。我们可以看到在f2里是LOAD_FAST，这也证明了我们的观点：b被当作了local变量。</div></pre></td></tr></table></figure>
<p>如果你明白了作用域的规则，那么恭喜你，我们可以开始学习闭包的概念了；如果没有明白，我希望你能回头再理解一下，因为明白作用域的规则是非常重要的。</p>
<h2 id="Why-closures-exist-and-how-they-work"><a href="#Why-closures-exist-and-how-they-work" class="headerlink" title="Why closures exist and how they work?"></a>Why closures exist and how they work?</h2><p><strong>闭包</strong>，老样子，我们还是先思考一个例子。<br>假设你现在需要一个函数去计算，某股票未来三天的均价，每天都会插入一个新的价格，同时我们也要保存之前的价格以便后续的计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">它的实现结果看起来应该是这样的</div><div class="line">avg(10)</div><div class="line">10.0</div><div class="line">avg(11)</div><div class="line">10.5</div><div class="line">avg(12)</div><div class="line">11.0</div><div class="line"></div><div class="line">如果你已经思考过怎么实现这个函数了，那么继续往下看吧。</div><div class="line"></div><div class="line">def make_averager():</div><div class="line">    series = []</div><div class="line"></div><div class="line">    def averager(new_value):</div><div class="line">        series.append(new_value)</div><div class="line">        total = sum(series)</div><div class="line">        return total / len(series)</div><div class="line"></div><div class="line">    return averager</div><div class="line"></div><div class="line">avg = make_averager()</div><div class="line">print(avg(10))</div><div class="line">print(avg(11))</div><div class="line">print(avg(12))</div></pre></td></tr></table></figure>
<p>我们通过series这个变量来记录每一天的价格，并用它来计算均值。但是要注意series是<br>make_averager的本地变量，我们在创建avg = make _averager()已经初始化了series，<br>并且在后续的调用时make _averager的local作用域已经结束了。那么是python如何series的呢？</p>
<p>python里有个概念是<strong>free variable</strong>，而avarager里的series就是<strong>free variable</strong>.我们可以打印出来看看是不是这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    print(avg.__code__.co_varnames)</div><div class="line">    print(avg.__code__.co_freevars)</div><div class="line">    print(avg.__closure__[0].cell_contents)</div><div class="line">(&apos;new_value&apos;, &apos;total&apos;)</div><div class="line">(&apos;series&apos;,)</div><div class="line">[10, 11, 12]</div></pre></td></tr></table></figure>
<p>可以看到，确实存在<strong>free variable</strong>这个属性，并且值是series.</p>
<p><strong>总结一下</strong><br>闭包保存了函数在绑定时local作用域的对象，并将其保存为自由变量。所以尽管被绑定的函数local作用域不再可用，但是自由变量是仍然可以使用的。</p>
<h2 id="What-problem-is-solved-by-nonlocal"><a href="#What-problem-is-solved-by-nonlocal" class="headerlink" title="What problem is solved by nonlocal?"></a>What problem is solved by nonlocal?</h2><p>爱思考的你，想必已经发现了，之前我们实现的averager其实并不高效，因为我们要耗费空间去保存每一天的价格，并且每次都要调用sum()去计算总价。ok，既然我们已经发现了问题所在，那么一起来优化一下averager吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def make_averager():</div><div class="line">    count = 0</div><div class="line">    total = 0</div><div class="line">    def averager(new_value):</div><div class="line">        total += new_value</div><div class="line">        count += 1</div><div class="line">        return total / count</div><div class="line">    return averager</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    avg = make_averager()</div><div class="line">    avg(10)    </div><div class="line">&gt;&gt;&gt; UnboundLocalError: local variable &apos;total&apos; referenced before assignment</div><div class="line"></div><div class="line">因为 total += new_value 相当于 total = total + new_value, 执行了赋值操作，</div><div class="line">根据上面介绍的作用域规则，我们很快能想到，因为赋值操作导致了total变成了local变量</div><div class="line">而不再是自由变量了。而前一个版本的实现，由于我们没有对series进行赋值操作，所以series</div><div class="line">一直是avg的自由变量。</div></pre></td></tr></table></figure>
<p>所有的不可变类型变量，对其操作都会将其作为local变量进行重新绑定。因此变量不能保存在闭包里，后续如果对其操作，就会导致错误的发生。而python3.x中增加了nonlocal操作，可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def make_averager():</div><div class="line">    count = 0</div><div class="line">    total = 0</div><div class="line">    def averager(new_value):</div><div class="line">        nonlocal total, count</div><div class="line">        total += new_value</div><div class="line">        count += 1</div><div class="line">        return total / count</div><div class="line">    return averager</div><div class="line">avg = make_averager()</div><div class="line">print(avg(10))</div><div class="line">print(avg(11))</div><div class="line">print(avg(12))</div><div class="line"></div><div class="line">10.0</div><div class="line">10.5</div><div class="line">11.0</div></pre></td></tr></table></figure>
<h2 id="Implementing-a-simple-decorator"><a href="#Implementing-a-simple-decorator" class="headerlink" title="Implementing a simple decorator"></a>Implementing a simple decorator</h2><p>通过上面概念的学习，我们可以开始实现一个简单的函数装饰器了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line"></div><div class="line">def clock(func):</div><div class="line">    series = []</div><div class="line">    def clocked(*args):</div><div class="line">        t0 = time.perf_counter()</div><div class="line">        series.append(func)</div><div class="line">        _result = func(*args)</div><div class="line">        elapsed = time.perf_counter() - t0</div><div class="line">        name = func.__name__</div><div class="line">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class="line">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class="line">        return _result</div><div class="line">    return clocked</div><div class="line"></div><div class="line">@clock</div><div class="line">def snooze(seconds):</div><div class="line">    time.sleep(seconds)</div><div class="line"></div><div class="line">print(&apos;*&apos; * 40, &apos;Calling snooze(0.123)&apos;)</div><div class="line">snooze(.123)</div><div class="line"></div><div class="line">&gt;&gt;&gt;**************************************** Calling snooze(0.123)</div><div class="line">&gt;&gt;&gt;[0.12566963s] snooze (0.123) -&gt; None</div><div class="line"></div><div class="line">print(snooze.__name__)</div><div class="line">clocked</div><div class="line"></div><div class="line">如果你想要消除对__name__和__doc__的影响，可以使用@functools.wraps()</div><div class="line"></div><div class="line">def clock(func):</div><div class="line">    series = []</div><div class="line">    @functools.wraps(func)</div><div class="line">    def clocked(*args):</div><div class="line">        t0 = time.perf_counter()</div><div class="line">        series.append(func)</div><div class="line">        _result = func(*args)</div><div class="line">        elapsed = time.perf_counter() - t0</div><div class="line">        name = func.__name__</div><div class="line">        arg_str = &apos;,&apos;.join(repr(arg) for arg in args)</div><div class="line">        print(&apos;[%0.8fs] %s (%s) -&gt; %r &apos; % (elapsed, name, arg_str, _result))</div><div class="line">        return _result</div><div class="line"></div><div class="line">    return clocked</div><div class="line">像上面这样的使用，就能消除装饰器的影响了。</div></pre></td></tr></table></figure>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>感谢阅读，希望你能从这篇文章中有所收获。<br>如果想要进一步的阅读，可以去探索内置的lru_cache和singledispatch装饰器的内部实现。</p>
<p>本文的代码链接：<a href="https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/tree/master/Fluent_Python_demo/Function_decorators</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h2&gt;&lt;p&gt;本文尽量用最简单，清晰的文字来介绍python的闭包与装饰器。希望你可以静下心来跟我一同思考这个tr
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python内置模块bisect介绍</title>
    <link href="http://miks.top/2017/11/20/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97bisect%E4%BB%8B%E7%BB%8D/"/>
    <id>http://miks.top/2017/11/20/Python内置模块bisect介绍/</id>
    <published>2017-11-20T06:33:07.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的<strong>bisect</strong>模块.    </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于bisect，官网的解释是：</p>
<p>This module provides support for maintaining a list in sorted order without having to sort the list after each insertion. For long lists of items with expensive comparison operations, this can be an improvement over the more common approach. The module is called bisect because it uses a basic bisection algorithm to do its work. The source code may be most useful as a working example of the algorithm (the boundary conditions are already right!).</p>
<p>大意是说：模块提供了对列表顺序的维护，无需每次插入后对列表排序。使用了基础的二分算法，对操作大数量的列表，可以显著的减少比较操作的次数。</p>
<h2 id="模块内提供的函数"><a href="#模块内提供的函数" class="headerlink" title="模块内提供的函数"></a>模块内提供的函数</h2><h4 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h4><p><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code></p>
<p>a是需要操作的对象，x是需要查找的目标，lo和hi会切割数组，使<code>all(val &lt; x for val in a[lo:i])</code> 在左侧， <code>all(val &gt;= x for val in a[i:hi])</code> 在右侧。返回值为可插入的第一个位置(有相同的item).</p>
<p><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code></p>
<p><code>bisect.bisect(a, x, lo=0, hi=len(a))</code></p>
<p>这两个函数相同，且与bisect.bisect_left操作类似。区别在于，返回值为可插入的最后一个位置。即<code>all(val &lt;= x for val in a[lo:i])</code> 在左侧 <code>all(val &gt; x for val in a[i:hi])</code> 在右侧。</p>
<h4 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h4><p><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code></p>
<p>函数相当于a.insert(bisect.bisect_left(a, x, lo=0, hi=len(a)), x). 其中list.insert()的时间复杂度为O(n),查找的时间复杂度为O(logn).</p>
<p><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code></p>
<p><code>bisect.insort(a, x, lo=0, hi=len(a))</code></p>
<h2 id="事例讲解"><a href="#事例讲解" class="headerlink" title="事例讲解"></a>事例讲解</h2><p>用一个排序后的lists查找案例来练习一下吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">def index(a, x):</div><div class="line">    &apos;Locate the leftmost value exactly equal to x&apos;</div><div class="line">    i = bisect.bisect_left(a, x)</div><div class="line">    if i != len(a) and a[i] == x:</div><div class="line">        return i</div><div class="line">    raise ValueError</div><div class="line"></div><div class="line"></div><div class="line">def find_lt(a, x):</div><div class="line">    &apos;Find rightmost value less than x&apos;</div><div class="line">    i = bisect.bisect_left(a, x)</div><div class="line">    if i:</div><div class="line">        return a[i - 1]</div><div class="line">    raise ValueError</div><div class="line"></div><div class="line"></div><div class="line">def find_le(a, x):</div><div class="line">    &apos;Find rightmost value less than or equal to x&apos;</div><div class="line">    i = bisect.bisect_right(a, x)</div><div class="line">    if i:</div><div class="line">        return a[i - 1]</div><div class="line">    raise ValueError</div><div class="line"></div><div class="line"></div><div class="line">def find_gt(a, x):</div><div class="line">    &apos;Find leftmost value greater than x&apos;</div><div class="line">    i = bisect.bisect_right(a, x)</div><div class="line">    if i != len(a):</div><div class="line">        return a[i]</div><div class="line">    raise ValueError</div><div class="line"></div><div class="line"></div><div class="line">def find_ge(a, x):</div><div class="line">    &apos;Find leftmost item greater than or equal to x&apos;</div><div class="line">    i = bisect.bisect_left(a, x)</div><div class="line">    if i != len(a):</div><div class="line">        return a[i]</div><div class="line">    raise ValueError</div></pre></td></tr></table></figure>
<h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p>最后leetcode的题目是：</p>
<p>Implement a MyCalendar class to store your events.<br>A new event can be added if adding the event will not cause a double booking.<br>Your class will have the method, book(int start, int end).<br>Formally, this represents a booking on the half open interval [start, end),<br>the range of real numbers x such that start &lt;= x &lt; end.<br>A double booking happens when two events have some non-empty intersection<br>(ie., there is some time that is common to both events.)<br>For each call to the method MyCalendar.book,<br>return true if the event can be added to the calendar successfully without causing a double booking. Otherwise,<br>return false and do not add the event to the calendar.<br>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import bisect</div><div class="line"></div><div class="line"></div><div class="line">class MyCalendar(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.calendar = []</div><div class="line">        self._start_sorted = []</div><div class="line"></div><div class="line">    def book(self, start, end):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type start: int</div><div class="line">        :type end: int</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        if not self.calendar:</div><div class="line">            self.calendar += (start, end),</div><div class="line">            self._start_sorted += start,</div><div class="line">            return True</div><div class="line">        floor_index = bisect.bisect_left(self._start_sorted, start)</div><div class="line">        if floor_index and self.calendar[floor_index - 1][1] &gt; start:</div><div class="line">                return False</div><div class="line"></div><div class="line">        ceiling_index = bisect.bisect_right(self._start_sorted, start)</div><div class="line">        if self.calendar[ceiling_index - 1][0] == start and self.calendar[ceiling_index - 1][0] &lt; end:</div><div class="line">                return False</div><div class="line">        elif ceiling_index != len(self.calendar) and self.calendar[ceiling_index][0] &lt; end:</div><div class="line">                return False</div><div class="line"></div><div class="line">        self.calendar.insert(floor_index, (start, end))</div><div class="line">        self._start_sorted.insert(floor_index, start)</div><div class="line">        return True</div></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>详细的代码和用例：<br><a href="https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py" target="_blank" rel="external">https://github.com/Miksztowi/CorePython/blob/master/bisect_demo.py</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Leetcode Weekly Contest 59上有一道题，需要在插入时保持序列顺序，从而我去了解了Python内置的&lt;strong&gt;bisect&lt;/strong&gt;模块.    &lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerl
    
    </summary>
    
    
      <category term="Python" scheme="http://miks.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>联合-查找算法</title>
    <link href="http://miks.top/2017/11/06/%E8%81%94%E5%90%88-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://miks.top/2017/11/06/联合-查找算法/</id>
    <published>2017-11-06T05:26:47.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍这个算法前，先梳理一些相关词组的概念：</p>
<p><strong>并查集</strong>： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.</p>
<p><strong>Find(node)函数</strong>： 确定元素属于哪一个子集.它可以用来确定两个元素是否属于同一个子集.</p>
<p><strong>Union(node_a, node_b)函数</strong>： 将两个子集合并成同一个集合.</p>
<p><strong>并查集森林</strong>： 并查集森林中每个节点保存的都是其父节点的引用。</p>
<p><strong>下面从基础版本分析，再到两种优化来讲解这个算法。</strong></p>
<ul>
<li>基础版本的联合-查找算法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def find(node):</div><div class="line">	if parent[node] == node:</div><div class="line">		return node</div><div class="line">	else:</div><div class="line">		return find(parent[node])</div><div class="line">		</div><div class="line">def union(node_a, node_b):</div><div class="line">	root_a = find(node_a)</div><div class="line">	root_b = find(nond_b)</div><div class="line">	parent[root_a] = roo_b</div></pre></td></tr></table></figure>
<p>这是并查集森林的最基础的表示方法，这个方法不会比链表法好，这是因为创建的树可能会严重不平衡；然而，可以用两种办法优化。</p>
<ul>
<li>按秩合并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def union(node_a, node_b):</div><div class="line">    root_a = get_parent(node_a)</div><div class="line">    root_b = get_parent(node_b)</div><div class="line"></div><div class="line">    if rank[root_a] &gt; rank[root_b]:</div><div class="line">        parent[root_b] = root_a</div><div class="line">    elif rank[root_a] &lt; rank[root_b]:</div><div class="line">        parent[root_a] = root_b</div><div class="line">    else:</div><div class="line">    	  parent[root_a] = root_b</div><div class="line">        rank[root_b] += 1</div></pre></td></tr></table></figure>
<p>这里的秩也可以理解树的深度，对于单元素的树，秩设为0。用变量rank去保存每个节点的深度，在合并的时候将更小深度树合并到较大深度的树上，且rank只有当两个树的深度相同时才会加一。因为影响时间效率的是树的深度，所以采用这种方法在最坏的情况，时间复杂度为O(logn).</p>
<ul>
<li>路径压缩</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def get_parent(node):</div><div class="line">    if parent[node] == node:</div><div class="line">        return node</div><div class="line">    parent[node] = get_parent(parent[node])</div><div class="line">    return parent[node]</div></pre></td></tr></table></figure>
<p>在执行查找函数的同时，扁平化当前树。关键在于路径上的每个节点可以直接连接到根节点上，为后续的引用节点操作加速。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>我们用一道题目来梳理一下这个算法。</strong></p>
<p>Leet Code Weekly Contest 57 里有一道题目：</p>
<p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account, in sorted order.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the format they were given: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>
<p>题目的<strong>大意</strong>是： 给定一组账号，每个账号里包含用户姓名和一组邮箱，根据邮箱来对账号进行合并。（名字重复也可能表示两个不同的用户，但是邮箱是唯一确定的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Solution(object):</div><div class="line">    def accountsMerge(self, accounts):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type accounts: List[List[str]]</div><div class="line">        :rtype: List[List[str]]</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">        def get_parent(node):</div><div class="line">            if parent[node] == node:</div><div class="line">                return node</div><div class="line">            parent[node] = get_parent(parent[node])</div><div class="line">            return parent[node]</div><div class="line"></div><div class="line">        def union(node_a, node_b):</div><div class="line">            root_a = get_parent(node_a)</div><div class="line">            root_b = get_parent(node_b)</div><div class="line"></div><div class="line">            if rank[root_a] &lt; rank[root_b]:</div><div class="line">                parent[root_a] = root_b</div><div class="line">            else:</div><div class="line">                parent[root_b] = root_a</div><div class="line">                rank[root_a] += 1</div><div class="line"></div><div class="line">        rank = collections.defaultdict(int)</div><div class="line">        parent = &#123;&#125;</div><div class="line">        owner = &#123;&#125;</div><div class="line">        result = collections.defaultdict(list)</div><div class="line">        emails_set = set()</div><div class="line"></div><div class="line">        for i, account in enumerate(accounts):</div><div class="line">            name, emails = account[0], account[1:]</div><div class="line">            for email in emails:</div><div class="line">                emails_set.add(email)</div><div class="line">                owner[email] = name</div><div class="line">                if email not in parent:  # 生成并查集森林</div><div class="line">                    parent[email] = email</div><div class="line"></div><div class="line">            for email in emails[1:]:  </div><div class="line">                union(emails[0], email)</div><div class="line"></div><div class="line">        for email in emails_set:</div><div class="line">            result[get_parent(email)].append(email)</div><div class="line">        return [[owner[email]] + sorted(result[email]) for email in result]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍这个算法前，先梳理一些相关词组的概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并查集&lt;/strong&gt;： 并查集是一种树型的数据结构，用于处理一些不想交集合的合并以及查询问题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Find(node)函数&lt;/strong&gt;： 确定元素属于哪一个子集.
    
    </summary>
    
    
      <category term="算法" scheme="http://miks.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
<<<<<<< HEAD
    <title>函数式编程 Report</title>
    <link href="http://miks.top/2017/11/04/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://miks.top/2017/11/04/函数式编程/</id>
    <published>2017-11-04T07:27:45.000Z</published>
    <updated>2017-11-04T09:32:09.000Z</updated>
=======
    <title>检查清单 Report</title>
    <link href="http://miks.top/2017/11/04/%E6%A3%80%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <id>http://miks.top/2017/11/04/检查清单/</id>
    <published>2017-11-04T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
    
    <content type="html"><![CDATA[<p>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程&lt;br&gt;不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你&lt;br&gt;1）代码更简单了。&lt;br&gt;2）数据集，操作，返回值都放到了一起。&lt;br&gt;3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。&lt;br&gt;4）你的代码变成
    
    </summary>
    
    
<<<<<<< HEAD
=======
      <category term="清单" scheme="http://miks.top/tags/%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程 Report</title>
    <link href="http://miks.top/2017/11/04/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://miks.top/2017/11/04/函数式编程/</id>
    <published>2017-11-04T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程&lt;br&gt;不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你&lt;br&gt;1）代码更简单了。&lt;br&gt;2）数据集，操作，返回值都放到了一起。&lt;br&gt;3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。&lt;br&gt;4）你的代码变成
    
    </summary>
    
    
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
      <category term="函数式" scheme="http://miks.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>问题清单 Report</title>
    <link href="http://miks.top/2017/11/04/%E9%97%AE%E9%A2%98%E6%B8%85%E5%8D%95/"/>
    <id>http://miks.top/2017/11/04/问题清单/</id>
    <published>2017-11-04T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下Git分支的知识</p>
<p>from sqlalchemy import Column, Integer, String</p>
<p>class User(Base):<br>…<br>tablename<br> = ‘users’<br>…<br>…     id = Column(Integer, primary_key=True)<br>…     name = Column(String)<br>…     fullname = Column(String)<br>…     password = Column(String)<br>…<br>…     def<br>repr<br>(self):<br>…        return “<br>“ % (<br>…                             self.name, self.fullname, self.password)</p>
<p>json.dumps()把python结构变成json， json.loads()反之 </p>
<p>TypeError: vars() argument must have<br>dict<br> attribute vars可以得到<br>dict<br>的属性值</p>
<p>list.extend(iterable)<br>Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.</p>
<p>from collections import deque ,<br>use deque<br>like a queue</p>
<p>如何使用sqlalchemy搭配scrapy 减少参数配置呢？？？</p>
<p>Counter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。</p>
<p>how to realize keys option?</p>
<p>为什么同一个路径下搜索不到文件，pycharm中的terminal有问题，</p>
<p>绝对路径相对于文件还是运行位置的理解，看os源码理解。设计一套方法预先解决运行路径变更的问题。</p>
<p>为什么%s可以 但是{}会出问题？？</p>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。</p>
<p>为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>这里对 object() 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
<p>数据集我已经拥有？！！！！</p>
<p>我觉得LeakPasswd这个Project背后用的是类似华西安全网的APi.</p>
<p>google analytics</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一下Git分支的知识&lt;/p&gt;
&lt;p&gt;from sqlalchemy import Column, Integer, String&lt;/p&gt;
&lt;p&gt;class User(Base):&lt;br&gt;…&lt;br&gt;tablename&lt;br&gt; = ‘users’&lt;br&gt;…&lt;br&gt;…    
    
    </summary>
    
    
      <category term="清单" scheme="http://miks.top/tags/%E6%B8%85%E5%8D%95/"/>
<<<<<<< HEAD
    
  </entry>
  
  <entry>
    <title>检查清单 Report</title>
    <link href="http://miks.top/2017/11/04/%E6%A3%80%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <id>http://miks.top/2017/11/04/检查清单/</id>
    <published>2017-11-04T07:27:45.000Z</published>
    <updated>2017-11-04T09:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>写代码前</p>
<p>写代码的要思考到明确<br>做什么<br>，而不仅仅是<br>怎么做<br>。</p>
<p>先Google,gitHub看看有没有已经成熟的思路，先找资源。</p>
<p>把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。</p>
<p>如果要去学习新的工具，应该直接学习底层封装的API，这样再次学习类似工具时，可以降低学习成本。</p>
<p>文件操作</p>
<p>操作文件时候，写路径的时候要用os模块操作，千万要避免文件换了一个位置就会出错的问题。</p>
<p>数据结构</p>
<p>注意可变对象和不可变对象（list和dict），防止做参数时被污染。</p>
<p>数据操作部分，先明确数据结构。能用Tuple解决的不用List，同时要注意Dict读数据是的时候是无序的。</p>
<p>对数据集有操作，一定要用Set，并集|，交集&amp;，差集-，对称差集^（项在t或s中，但不会同时出现在二者中）</p>
<p>检查需要</p>
<p>先检查输入类型，用isinstance去限定所需要的数据类型。</p>
<p>输入数据是Int，考虑变成float会怎么样。List,string,dict为空时都默认等于false。</p>
<p>数据库的操作是否已经最少了，如果不是最少的话，尝试用Innerjoin 连接出数据，避免多次查询。</p>
<p>用assert 来确定数据是可用的(assert A,B = if not A do B)</p>
<p>节约资源的方法</p>
<p>reduce，map，filter三个内置函数，返回的都是生成器。节约开销，能用时尽量用。</p>
<p>数据库操作</p>
<p>对数据库操作，不要再用mysql这个库，用sqlachemy，兼容2和3，同时可以用Orm来操作数据库。</p>
<p>对数据库操作的函数，如果可以写缓存，尽量用Redis做缓存，避免Mysql的查询。</p>
<p>尽量不要用Where这种隐形连接，用Inner Join这种显性连接。</p>
<p>对数据库有操作，要用log记录下来，以便数据恢复使用。</p>
<p>错误处理</p>
<p>死循环，给第一行print，第二行continue。</p>
<p>如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。 </p>
<p>团队沟通</p>
<p>换位思考，从对方的思路开始思考，先明白对方问题的原因。</p>
<p>不仅要有自己的想法，还要对于想法有可行的方案。</p>
<p>前端问题复杂的时候，后端要帮忙简化问题， 互相帮助！</p>
<p>HTML操作</p>
<p>w3lib.html.remove_tags()可以过滤Html标签。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码前&lt;/p&gt;
&lt;p&gt;写代码的要思考到明确&lt;br&gt;做什么&lt;br&gt;，而不仅仅是&lt;br&gt;怎么做&lt;br&gt;。&lt;/p&gt;
&lt;p&gt;先Google,gitHub看看有没有已经成熟的思路，先找资源。&lt;/p&gt;
&lt;p&gt;把问题拆分到可以直接去思考做法的程度，画树，逐层写方法。&lt;/p&gt;
&lt;p&gt;如果
    
    </summary>
    
    
      <category term="清单" scheme="http://miks.top/tags/%E6%B8%85%E5%8D%95/"/>
=======
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
    
  </entry>
  
  <entry>
    <title>2017-08-20 Report</title>
    <link href="http://miks.top/2017/08/20/2017-08-20/"/>
    <id>http://miks.top/2017/08/20/2017-08-20/</id>
    <published>2017-08-20T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补交8月18日Daily Report&lt;br&gt;当天完成的工作内容&lt;br&gt;1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。&lt;br&gt;当天的收获&lt;br&gt;1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？&lt;br&gt;2.反思： 提供他人使用的程序，功能是
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-18 Report</title>
    <link href="http://miks.top/2017/08/18/2017-08-18/"/>
    <id>http://miks.top/2017/08/18/2017-08-18/</id>
    <published>2017-08-18T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>补交8月18日Daily Report<br>当天完成的工作内容<br>1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。<br>当天的收获<br>1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？<br>2.反思： 提供他人使用的程序，功能是核心。但是相比于自己使用的话，需要注意使用的友好程度，使用的上手难度，以及合作开发人员与后期维护人员的工作效率。<br>3.总结:<br>首先，<br>1.面向使用者来说，重要的是简单，易用。能用一行命令行执行的功能，绝不让使用者输入两行。比如数据库的建表，“是否要建表，建一张什么样的表..”这样的问题完成到使用者只需要指定Mysql,Sqlite此类的DBMS即可。 配有程序功能详细的Tutorial，毕竟我在Github上，对于使用越简单的程序，好感度越高！<br>2.面向合作开发人员，写好程序功能的架构图，让对方快速明白目前已经实现的功能，以及功能间的联系与使用技术。<br>明天的计划<br>1.先沟通好新人周报自动化的需求，然后再将可以完成需求的技术进行对比，择优选择。<br>提出疑问或寻求帮助<br>1.赵赵和伟哥有没有开发过一些自己觉得很酷Cool，但是用户的反馈并不好的程序呢？如果有，原因是什么呢？<br>今日翻译<br>“Mr. Jones, of the Manor Farm, had locked the hen-houses for the night, but was too drunk to remember to shut the popholes. With the ring of light from his lantern dancing from side to side, he lurched across the yard, kicked off his boots at the back door, drew himself a last glass of beer from the barrel in the scullerhey, and made his way up to bed, where Mrs. Jones was already snoring.”<br>我的翻译<br>Jones先生，是庄园的主人。这晚他锁上马棚，但是喝的太多了不记得去关上马槽。伴随着，晃来晃去从灯笼里发出的光亮。他蹒跚的穿过了庭院，用他的靴子踢开了后门。他给自己从桶里取了最后一杯酒，然后上了床。之后Jones先生已经开始打呼噜了。<br>正确翻译<br>故事发生在曼纳庄园里。这天晚上，庄园的主人琼斯先生说是已经锁好了鸡棚， 由于他喝得醉意十足，竟把里面的那些小门都忘了关上。他提着马灯踉踉跄跄地穿过院子，马灯光也跟着一直不停地晃来晃去，到了后门，他把靴子一脚一只踢了出去，又从洗碗间的酒桶里舀起最后一杯啤酒，一饮而尽，然后才上床休息。此时，床上的琼斯夫人已是鼾声如雷了。<br>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。<br>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。<br>函数式编程<br>不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你<br>1）代码更简单了。<br>2）数据集，操作，返回值都放到了一起。<br>3）你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。<br>4）你的代码变成了在描述你要干什么，而不是怎么去干<br>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补交8月18日Daily Report&lt;br&gt;当天完成的工作内容&lt;br&gt;1.将车型数据库的爬虫脚本，打包成线上可以允许的程序。&lt;br&gt;当天的收获&lt;br&gt;1.问题： 如何让使用者在最短的时间内，做到同开发人员一样熟练的使用程序呢？&lt;br&gt;2.反思： 提供他人使用的程序，功能是
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-16 Report</title>
    <link href="http://miks.top/2017/08/16/2017-08-16/"/>
    <id>http://miks.top/2017/08/16/2017-08-16/</id>
    <published>2017-08-16T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.update 合并数据的自动化脚本。<br>2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。<br>当天的收获<br>1.问题： 不记录日志带来的麻烦<br>2.反思： firestone和edmunds的爬虫，在爬取的时候有数据调试，但是没有日志记录。这样在之后对数据进行验证的时候，没有信息可以参考。同时对于爬虫运行的状态无法确定。<br>3.方法： 对于自动化的脚本，要搭配日志使用。 在Settings模块里，配置Logger，爬取数据时将爬取结果写入日志中。在爬取结束后，核对日志，确保数据的完整性。<br>明天的计划<br>1.用日志确认Edmunds和Firestone的爬虫功能是否完善。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Notice that the weight of the position to the left of the units position is 8. This is 8 times 1. Then notice that the weight of the next position is 64, or 8 times 8. If another position existed, it would be 64 times 8, or 51 2. To find the weight of the next higher-order position, multiply the weight of the current position by the number base (or 8, in this example). To calculate the weights of position to the right of the radix point, divide by the number base. In the octal system, the position immediately to the fight of the octal point is 1/8, or .125. The next position is .125/8, or .015625, which can also be written as 1/64.<br>我的翻译<br>注意到个位的左边值是8。这是8的一次方。注意到下一个位置的值是64，或8的8次方。如果另一个位置存在，它将是64的8次方，或者512。为了找到下个高位的值，乘当前位置的基数（在这个例子中是8）为了计算出正确的指数位的值，除以基数。在八进制的中，八进制点的位置直接用1/8找到，或者.125。下一个位置是.125/8，或者.015625，也可以被写成1/64。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.update 合并数据的自动化脚本。&lt;br&gt;2.firestone的爬虫增加了特殊字符的处理，又获得了27015条车型数据。&lt;br&gt;当天的收获&lt;br&gt;1.问题： 不记录日志带来的麻烦&lt;br&gt;2.反思： firestone和edmunds的爬虫，
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-14 Report</title>
    <link href="http://miks.top/2017/08/14/2017-08-14/"/>
    <id>http://miks.top/2017/08/14/2017-08-14/</id>
    <published>2017-08-14T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.看avatar爬虫部分的源码。<br>当天的收获<br>1.当问题拆分后，如何思考解决方案？<br>总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到更加专注的解决；降低方案的复杂性。<br>明天的计划<br>1.优化一下edmunds和firestone的爬虫，使其支持断点续爬。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The position to the left of the units position is always the number base raised to the first power; in a decimal system, this is l01, or l0. In a binary system, it is 21, or 2; and in an octal system it is 81, or 8. Therefore, an 11 decimal has a different value from an 11 binary. The 1l decimal is composed of 1 ten plus 1 unit and has a value of 11 units; while the binary number 11 is composed of 1 two plus 1 unit, for a value of 3 decimal units. The 11 octal has a value of 9 units.<br>我的翻译<br>在个位左边的位置总是数字的1次幂，在十进制中，101，或10。在二进制中21，或2。在八进制中为81，或8。因此，一个十进制的11不同于二进制的11的值。十进制中的11，由一个十位加1个单位，表示值11.然而二进制中的11，由一个二加1个单位，表示十进制中的3.八进制中11的值为9。<br>正确翻译<br>个位左边的位总是基数的1次幂，在十进制系统中是101，或10；在二进制中是21，或2；而在八进制中是81，或8。因此，十进制的11与二进制的11具有不同的数值。十进制11表示—个10加上一个1，其值为11；二进制11表示—个2加上—个1，其值为3；八进制11的值为9。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.看avatar爬虫部分的源码。&lt;br&gt;当天的收获&lt;br&gt;1.当问题拆分后，如何思考解决方案？&lt;br&gt;总结： 问题要彼此不重合的独立拆开，同样，设想的解决方案也应该彼此不重合，只解决其对应的问题。解决方案只对应其当前问题，可以使逻辑保持清晰，做到
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-10 Report</title>
    <link href="http://miks.top/2017/08/10/2017-08-10/"/>
    <id>http://miks.top/2017/08/10/2017-08-10/</id>
    <published>2017-08-10T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚耽误了很久，今天的总结并不好。<br>当天完成的工作内容<br>1.继续合并firestone和edmunds的数据库。<br>当天的收获<br>1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思路比以前清晰很多。<br>2.问题： 尽管思路清晰了一些，但是晚上重看思维导图的时候发现在拆分问题上，仍然存在问题。问题拆分的混乱，层级关系有些存在错误。<br>3.反思： 对于名称的合并上，有几类都是同一个问题下的子问题，但是在当时划分的时候我把它们划分到不同的类别中。 –&gt;  能够用统一的手段解决，变成了每个小问题都单独解决一次。 –&gt; 为什么当时问题没有归类正确？ ——&gt; 因为只带着目标去思考问题，没有在分析问题时，考虑它的对立/相似等其他情况。 –&gt; 忽略了这些思考，导致即使碰到了对立/相似的问题也会遗忘这类问题已经在某个地方被列出来过了。 ——&gt; 所以将它们放到了一个不是最匹配的类目下。<br>4.方法： 对于问题的拆分，带着目标的同时，也要将其能考虑到的对立/相似问题罗列出来 –&gt; 避免时间间隔久了，再碰到相似问题会重新定义。 –&gt; 罗列出来不必急着写解决方案，等遇到了在考虑，所以就算没有遇到也不会有时间浪费。<br>明天的计划<br>1.完成三张数据表完整的合并。<br>提出疑问或寻求帮助<br>无。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今晚耽误了很久，今天的总结并不好。&lt;br&gt;当天完成的工作内容&lt;br&gt;1.继续合并firestone和edmunds的数据库。&lt;br&gt;当天的收获&lt;br&gt;1.反馈：昨天总结的是有效解决问题中的拆分问题。今天在工作的时候，按照方法，把目标拆分成了十多个小节。这样逐个模块得解决，思
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-09 Report</title>
    <link href="http://miks.top/2017/08/09/2017-08-09/"/>
    <id>http://miks.top/2017/08/09/2017-08-09/</id>
    <published>2017-08-09T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.爬取了firestone上的胎压数据。<br>2.合并了部分胎压数据到 edmunds的车型数据库中。<br>当天的收获<br>1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）<br>2.陈述：这个问题在之前的daily report中也有过总结，但是从实践来看，效果并不好。之前总结的是先拆分–&gt;思考方案–&gt;验证方案–&gt;反馈–&gt;确认结果–&gt;问题解决。<br>3.目标： 我要做到快速有效的解决问题，而不是仅仅是解决问题。<br>4.反思： 之前总结的方案，从流程上来说解决问题确实是这些步骤，但是为什么效果不好呢？ ——&gt; 因为这些流程中每个步骤的细节没有总结 –&gt; 不总结到明确每个步骤做什么，那么总结的可行性会大大降低。 –&gt; 把这个流程中的步骤，都单独总结。 –&gt; 今天总结如何拆分问题。<br>5.总结： 面对问题时，比如今天的任务是合并两个部分兼容的车型数据库。 ——&gt; 先从目标考虑，目标是合并数据库。 ——&gt; 那么现在是否可以直接合并？如果是，那么直接合并了；如果不能合并，要怎么做才可以合并呢？ –&gt; 从目标上，把问题做了一次拆分。现在进入的是不可以直接合并模块 –&gt; 既然不可以合并，那是所有的数据都不可以合并，还是部分不可以合并？ –&gt; 是部分不可以直接合并，那么对于直接可以合并的数据也不要着急合并，继续进入部分数据不可以直接合并的思考 –&gt; 是什么导致了这部分的数据不可以直接合并呢？ ——&gt; 因为二者都有一部分数据是互不包含的，只有部分数据是二者的交集。 –&gt; 那么不包含意味着不能直接合并，那么交集中数据是不是已经可以直接合并了？ ——&gt; 交集中因为两个车型数据库的车型匹配规则不同，所以有部分数据虽然在交集内，但是仍然不能直接合并 –&gt; 规则相同或者不受规则影响的那部分是可以直接合并的，那么受到规则影响的数据是不是全部不可以直接合并？ –&gt; 思考到这一步的时候，需要开始实践才可以继续往下，此时才算把问题拆分到自己能考虑到的全部。<br>5.简述：总结的方法是对如何拆分问题做的实践，这个过程中，每一次的拆分都要先问此时能不能达到目标了，如果可以就开始思考方案和实践方案，如果仍然不能解决那么继续拆分并且之前的过程。<br>明天的计划<br>1.将firestone和edmunds二者可以合并的数据，合并完整。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>The exponential powers of the positions are critical for understanding numbers in other numbering systems. The position to the left of the radix (number base) point, called a decimal point only in the decimal system, is always the units position in any number system. For example, the position to the left of the binary point is always 20 or 1; the position to the left of the octal point is 80 or 1. In any case, any number raised to its zero power is always 1, or the units position.<br>我的翻译<br>指数的位置幂可以被理解其他数值系统中的数字所借鉴。基数左边的位置的点被称为十进制点，只在十进制系统中有。个位总是在任何数值系统中。举个例子，二进制左边的位置总是20或者1，八进制左边的位置是80或者1。在任何地方，任意数字上方有0都表示1，或者个位位置。<br>正确翻译<br>位的指数幂在理解其他计数制中的数时是个关键。基数小数点，在十进制中称为十进制小数点，其左边的位在任何数制中都是个位。例如，二进制小数点左边的位是20或1。而八进制小数点左边的位是80或1。在任何情况下，任何数的零次幂总是1，或1个单位。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.爬取了firestone上的胎压数据。&lt;br&gt;2.合并了部分胎压数据到 edmunds的车型数据库中。&lt;br&gt;当天的收获&lt;br&gt;1.问题：如何快速有效的解决问题？（今日总结如何拆分问题）&lt;br&gt;2.陈述：这个问题在之前的daily report
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-08 Report</title>
    <link href="http://miks.top/2017/08/08/2017-08-08/"/>
    <id>http://miks.top/2017/08/08/2017-08-08/</id>
    <published>2017-08-08T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。<br>当天的收获<br>1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。<br>2.反思： 每天总是想看的太多，比如想看python数据相关的包，又想看一些数据结构的教程，每天又有Github新的star，又把当天工作中遇到的代码问题弄懂…. –&gt; 总是觉得这些方方面面都挺重要，但是又不能兼顾。这些想的太多，不仅看不全而且还很焦虑。导致每天晚上每个部分只弄了一点，然后第二天起来又忘了，这样更加焦虑。最近心里越来越烦，越来越焦虑。 –&gt; 我也花了时间，但是效率非常低。 –&gt; 对学习计划，规划不清晰 –&gt; 把目标定的太长远了，没有规划好每天的计划。 –&gt; 应该用天来规划，而不是用周或者是月，因为工作期间的时间太碎片了，如果还按照学校那样一周一个安排，那这一周基本上什么也做不出来。 –&gt; 要把计划迭代的周期缩短，同时把想做的事情按照重要性来排序。<br>3.方法： 先把想做的事情按重要性做个排序。权衡了一番。<br>解决与思考工作上遇到的问题 &gt;&gt;  看scrapy的源码（每天只看一章） &gt;&gt; 看github里的star，技术博客等。 –&gt; 每天晚上就做这些简单清晰的事情，想做的太多反而焦虑。 –&gt; 任何没有反馈的学习是不可靠的 –&gt; fork scrapy，每天在看完的代码里面写注释即可。<br>明天的计划<br>1.把firestonecompleteautocare中的车型数据爬取下来。<br>2.对应firestonecompleteautocare的车型数据，爬取其对应的胎压数据。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>Once the digits of a number system are understood, larger numbers are constructed by using positional notation. In grade school, we learned that the position to the left of the units position was the tens position, the position to the left of the tens position was the hundreds position, and so forth. (An example is the decimal number 132: This number has 1 hundred, 3 tens, and 2 units.) What probably was not learned was the exponential value of each position: The units position has a weight of 100 or 1; the tens position has weight of 101, or 10; and the hundreds position has a weight of 102, or 100.<br>我的翻译<br>一旦明白了数字的计数系统，就可以通过位置表示构造出更大的数字。在高中，我们学过个位的左边是十位，十位的左边是百位，以此类推。（举个十进制的132的例子，这个数字有1个百位，3个十位，2个个位）。可能没有学过指数的每个位置：个位的有一个重量10的0次方为1，十位有一个重量10的1一次方为10，百位的有一个重量10的2次方为100。<br>正确翻译<br>一旦我们理解了计数制的数字后，就可用位计数法构造更大的数值。在小学时我们都学过个位的左边一位是十位，十位左边一位是百位，以此类推(例如十进制数132,这个数字有—个百，三个十和两个一)。或许我们没有学过每个位的指数值：个位的权为l00，即1；十位的权为101或10；而百位的权为102或100。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.解析了firestonecompleteautocare这个网站的爬取规则，完成了车型的spider脚本。计划将其数据全部爬下来后再合并到已有的车型数据中。&lt;br&gt;当天的收获&lt;br&gt;1.问题： 业余时间的规划不清晰，无端的焦虑，效率也很低下。&lt;
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
    
  </entry>
  
  <entry>
    <title>2017-08-07 Report</title>
    <link href="http://miks.top/2017/08/07/2017-08-07/"/>
    <id>http://miks.top/2017/08/07/2017-08-07/</id>
    <published>2017-08-07T07:27:45.000Z</published>
    <updated>2018-01-11T04:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.get features of car from edmunds<br>当天的收获<br>1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。<br>2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——&gt; 在A中开始爬取就会有no find的问题，但是在B中爬取文件就没有问题。 –&gt; 那么既然运行的文件和目标文件都在同一个文件夹里，怎么会有这样的问题呢？ ——&gt; 用os.getcwd()做个测试，发现在A中运行B中的文件和B中直接运行得到的路径是不一样的 –&gt; 所以路径取决于运行文件的位置而不是文件所在的位置。<br>3.方法： 遇到no find file or directory的问题 ——&gt; 先检查一遍文件名的反斜杠，避免转义的问题。 –&gt; 文件名，如果使用相对路径，那么检查运行文件的位置时候是跟文件所处的路径相同。 –&gt; 如果路径不同，那么要修改文件名为运行的路径位置，或者使用绝对路径。<br>总结： 如果程序运行的路径，不能保证与.py文件是相同的，最好在里面open的时候使用绝对路径。<br>明天的计划<br>1.get tire pressure data。<br>提出疑问或寻求帮助<br>无。<br>今日翻译<br>If the base of a number exceeds 10, the additional digits use the letters of the alphabet, beginning with an A, For example, a base 12 number contains 12 digits: 0 through 9, followed by A for 10 and B for 11, Note that a base 10 number does not contain a 10 digit, just as a base 8 number does not contain an 8 digit. The most common numbering systems used with computers are decimal, binary, and hexadecimal (base 16). (Many years ago octal numbers were popular.) Each system is described and used in this section of the chapter.</p>
<p>我的翻译<br>如果基数超过10，那么10之后的数字使用字母，从A开始。举个例子，12进制包含12个数字，0到9，之后是A表示10，B表示11。注意10进制不包括10这个数字，就好像8进制没有8。最常使用的数字系统是十进制和十六进制（许多年以前流行八进制）。每一个系统被这个部分的章节使用和描述。<br>正确翻译<br>如果基数大于10，其余数字用从A开始的字母表示，例如，以12为基的数包含12个数字，0到9，之后用A代表10，B代表11。注意，以10为基的数不包含数字10，如同以8为基的数不包括数字8一样。计算机中最通用的计数制是十进制、二进制、八进制和十六进制(基为16)。每种计数制都将在本节中进行说明和应用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.get features of car from edmunds&lt;br&gt;当天的收获&lt;br&gt;1.问题： 今天写代理池的时候，遇到了一个打开文件的路径问题。&lt;br&gt;2.反思： B是A文件的子目录，爬虫需要打开的代理文件和爬虫文件都在B中。 ——&amp;g
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
<<<<<<< HEAD
    
  </entry>
  
  <entry>
    <title>2017-08-06 Report</title>
    <link href="http://miks.top/2017/08/06/2017-08-06/"/>
    <id>http://miks.top/2017/08/06/2017-08-06/</id>
    <published>2017-08-06T07:27:45.000Z</published>
    <updated>2017-11-04T09:51:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>当天完成的工作内容<br>1.写了xxx api<br>2.在xxx中修改了xx方法。<br>当天的收获<br>1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在文本里梳理了一遍解决问题的过程，完成了整个流程后我得到了一些关键性的数据，可是之后一直卡在了这个地方（有了关键数据，但是不知道怎么开始解决问题），想不到解决的办法后我把这个问题反馈给了伟哥。伟哥在对bug调试了一会后，跟我得到了相同的信息（截止到这一步，方法没有出现偏差），但是伟哥根据这些数据在纸上画出了整个问题中解决的流程，我看到了流程后感觉将之前所有的思路都理了一遍，并且之后我在重新绘图的过程中，突然想明白了Bug发生的原因（当时我跟伟哥说这是灵感乍现，但是回头想想为什么一开始不乍现而是等到绘图之后才有呢，所以这应该算是整个逻辑理顺后推出来的结果）。现在回头去看当时被卡住的情况，不是由于数据或者关键信息的缺失，而是没有把逻辑整理好，归纳出一个清晰的执行计划而导致的。<br>可见确保每一个目标都有清晰的执行计划和实践步骤是非常关键的<br>，遇到问题后先要用MECE分析一遍，再开始执行。<br>明天的计划<br>1.继续熟悉xxxxxx的架构。<br>提出疑问或寻求帮助<br>无。<br>当天完成的工作内容<br>1.写了一个xxxxxapi。<br>当天的收获<br>1.今天伟哥给我review的时候，跟我解释了在公司工作的目标和自己利用空余时间进行自我提升的协调。以及如何该使二者达到平衡，在公司要重视效率完成work，回去后把work中的原理去深究，每一次深究都是对自我的提升，只有用时间去钻研后才能做到消耗一次的时间解决相同的问题，避免在工作中每次碰到相同的问题都需要去重新思考一遍。<br>2.在伟哥的指点下，学习了MECE分析法，这个方法真的非常抑制我的坏习惯（行动快于思考），但是光理解不够，要将这个方法运用到实践中。明天将解决的问题的思路都在纸上用MECE过一遍。<br>明天的计划<br>1.继续熟悉avatar的架构。<br>提出疑问或寻求帮助<br>无。<br>今天感觉好疲惫，daily report没有用心写了QAQ</p>
<p>当天完成的工作内容<br>1.修复了xxxx前端和后端的几个小bug。<br>当天的收获<br>1.今天修复了几个关于前端的bug，其实对于前端的知识，我了解得很少。一开始听到伟哥给我的任务，完全没有思路，不过公司跟学校是完全不一样的，我不需要了解任务背后的原理，我只需要完成目标就好（不限制方法）。所以在解决问题上，我把解决的逻辑想明白后，代码具体操作的部分，去跟超哥请教，得以顺利的修复了Bug。<br>明天的计划<br>1.继续熟悉avatar数据处理部分的逻辑。<br>提出疑问或寻求帮助<br>无。</p>
<p>title: 《教父》摘录</p>
<p>date: 2017-06-10 00:11:12</p>
<p>tags:书中的一些笔记</p>
<p>他已经学会从不出言威胁，唐教会了他这一点，但卡洛完全明白了他的意思：他离死只差半步。 </p>
<p>就在这时，唐· 柯里昂发表了将被长久纪念的演说，巩固了他在众人中最具远见的领袖地位，演说充满逻辑常理，发自肺腑，切中要害。他在演说中创造了一个短语，日后像丘吉尔的“ 铁幕” 一样变得人尽皆知，但到十年后才进入公众视线。他第一次起身对委员会说话。他个子不高，因为“ 病况” 有点消瘦，六十岁的年龄终究显出了几分老态，但无疑已经恢复了过去的全部力量，仍旧拥有过去的所有智慧。“我们如果失去理性，那算是什么样的人啊，” 他说，“ 没有理性，我们和丛林野兽还有什么分别？但是，我们毕竟有理性，能够彼此说理，能够和自己说理。重新挑起所有争端，诉诸暴力和混战，能够满足我的什么目标呢？我的儿子死了，这是不幸，我必须承受，不能让我周围的世界随我一同受苦。因此，我今天说，我以名誉发誓，我不会寻求复仇，不会追查往事的前因后果。我将胸怀坦荡离开这里。“有一点我想说的是，我们必须看顾自己的利益。我们这些人都拒绝当傻瓜，拒绝当傀儡，被高处的人扯着线蹦蹦跳跳。我们在这个国家运气不错。我们的大部分子女已经过上了更好的生活。你们有些人的儿子是教授、科学家、音乐家—— 真是走运。你们的孙子也许会成为新的首领。我们谁都不希望见到儿孙走上我们的老路，那样过日子太艰难了。他们可以和其他人一样，我们的勇气赢来了他们的地位和安稳。我已经有了孙子，希望他们的孩子有朝一日能成为—— 谁知道呢？—— 州长？总统？在美国一切皆有可能。可是，我们必须跟着时代向前走。刀枪刺杀的年月已经过去。我们要像商人一样狡猾，从商的钱更多，对我们的儿孙更好。“至于我们的行为，我们不需要对那些炮筒子、那些首领负责，他们擅自决定我们该怎么处理我们的生命，他们宣战，希望我们用血肉保护他们的战果。我们凭什么为了保护他人的利益而伤害自己？而我们看顾我们自己的利益，他们凭什么插手？这是我们的事业12。” 唐· 柯里昂说，“ 这是我们自己的事业。我们管理自己的世界，因为这就是我们的世界，我们的事业。我们必须紧密团结，抵抗外来的干涉。否则他们就会给我们套上鼻环，就像他们已经给美国的另外几百万那不勒斯人和意大利人套上了鼻环一样。“为了这个原因，我愿意为儿子报仇，这是为了大家的利益。我现在发誓，只要我还负责指挥家族的行动，若是没有正当理由和遇到最激烈的挑衅，就连一个指头也不会举起来反对在座各位。我愿意为了共同利益牺牲我的商业利益。我发誓保证，以名誉保证，你们都清楚我从没有违背过誓言和名誉。“不过，我也有个自私的目的。因为受到索洛佐和那位警长的凶杀指控，我最小的儿子不得不逃跑。我必须安排他安全回国，洗清污名。这是我个人的事情，我会自己做些安排。也许我必须找到真凶，或者向政府证明他的无辜，也许证人和线人会撤回他们的谎言。可是，我还是要说，这是我个人的事情，我相信我能把我的儿子带回家。“但是，有句话我得说在前头。我是个迷信的人，这个毛病多么可笑，但我不得不说，要是什么倒霉的变故落在我的小儿子头上，要是某个警察不小心开枪打死他，要是他在牢房里上吊自杀，要是什么新证人冒出来证明他有罪，那迷信就会让我觉得这是因为在座有人还对我心怀恶意。再进一步说，假如我的儿子被雷劈了，我都会怪罪在座的某些人。要是他乘的飞机坠海，乘的船只沉入滚滚波涛，他得上致命的热病，汽车被火车撞了，迷信同样会让我归咎于在座某些人的恶意。各位先生，这种恶意，这种厄运，我可永远不会原谅。但除此之外，我愿意拿我孙子辈的灵魂起誓，我绝对不会打破我们缔结的和平。说到底，我们毕竟比那些双手沾满无数人类鲜血的领袖要好，不是吗？” 说完这些，唐· 柯里昂从他的位置顺着会议桌走向唐· 塔塔利亚的座位。塔塔利亚起身迎接他，两人拥抱，彼此亲吻面颊。房间里的其他唐鼓掌，见到谁都使劲握手，祝贺唐· 柯里昂和唐· 塔塔利亚新建立的友谊。这恐怕不是全世界最美好的友谊，他们不会互送圣诞礼物，但他们也不会彼此仇杀。在他们的世界里，这样的友谊就足够了，需要的也只是这样的友谊。</p>
<p>唉，老天应该允许每个人一辈子犯一次傻。</p>
<p>女人和孩子能够承担粗心大意的后果，男人却不行。</p>
<p>他的手底下是个活生生的器官，活生生的器官需要另外一个活生生的器官。</p>
<p>他第一次理解了意大利男人那闻名遐迩的嫉妒。此时此刻，要是有谁敢碰一下这女孩，妄图宣称拥有她，从他手里夺走她，他就会毫不犹豫杀死对方。他想占有她，就像吝啬鬼想占有金币那样疯狂，就像小佃农想拥有一片土地那样饥渴，想把她锁在房间里，囚禁她，只有他一个人能碰。</p>
<p>让朋友低估你的优点，让敌人高估你的缺点。</p>
<p>履行职责的人能获得恰当的奖赏。</p>
<p>你对你所爱的人不能随便说‘不’字，也不能常常说，这就是诀窍。当你说‘不’字时，你得把‘不’字说得听上去就像‘是’字一样悦耳。另一个办法就是你得设法让他们说‘不’字。你得耐心，还得不怕麻烦。不过，我是个老朽，你是新的时髦的一代，你不必听我这老一套。” 这就是说话的艺术，如同上面，你要跟他讲道理，让他无法拒绝，我想我的生命中缺少这个勇气，我不是很愿意违背朋友的愿望，但是有时却还是受到了伤害，我一直在学习如何说不，人善被人欺，所以我一直也在不断学，学会说，学会做人，我希望能把身边所谓我认为应该学的品质学会，那么那时，我也可以大声说不，这也是小说最能打动我的话，但我很早之前以前明白了他的道理，只是，我没在履行。</p>
<p>伟大的人不是生下来就伟大的，而是在成长过程中显示其伟大的。</p>
<p>今天做了什么</p>
<p>写了一个调用amazon’s api的脚本，根据输入的Searchindex的BrowseNodeId，得到当前SearchIndex的叶子节点。</p>
<p>今天学到了什么</p>
<p>今天下班的时候，脚本功能仍然没有实现，伟哥给我检查代码后，发现问题出在xpath的书写上，因为我<br>想当然<br>的认为数据是按照我所写的xpath提取出来的，所以问题迟迟没有解决。之后用命令空间对每个tag进行精确的定位后，问题得到了解决。这个问题是由于我的想当然导致的，同样没有对代码进行<br>Double check<br>也使得问题迟迟没有被发现。所以，以后写代码<br>不能想当然<br>，只有<br>通过Double check<br>的逻辑，才是可以开始实现的逻辑。</p>
<p>mac系统操作的简洁与高效比windows更适合开发，尽快的熟悉mac系统的操作，提高自己的工作效率。</p>
<p>同样的错误不要犯两次。</p>
<p>明天的计划<br>1.继续找车型数据库。<br>2.利用休息时间把mac上工作环境配置完善。<br>3.尽力完成好mentor的每一个要求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当天完成的工作内容&lt;br&gt;1.写了xxx api&lt;br&gt;2.在xxx中修改了xx方法。&lt;br&gt;当天的收获&lt;br&gt;1.今天在fix Bug的时候，被卡住了很久。这个bug是之前xxxx代码中xxxx部分隐含的，今天在扩展功能的时候暴露了出来。刚开始碰到这个问题的时候，首先我在
    
    </summary>
    
    
      <category term="daily report" scheme="http://miks.top/tags/daily-report/"/>
=======
>>>>>>> ce5d3157bc6368f3ac4839b3ce6ec2d4bdc7fdc2
    
  </entry>
  
</feed>
